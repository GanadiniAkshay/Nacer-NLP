6.4. Combining generators and promises
In this section, we’ll combine generators (and their capability to pause and resume their execution) with promises, in order to achieve more elegant asynchronous code. We’ll use the example of a functionality that enables users to get details of the highest-rated mission done by the most popular ninja. The data representing the ninjas, the summaries of their missions, as well as the details of the missions are stored on a remote server, encoded in JSON.
All of these subtasks are long-running and mutually dependent. If we were to implement them in a synchronous fashion, we’d get the following straightforward code:
try {
const ninjas = syncGetJSON("data/ninjas.json");
const missions = syncGetJSON(ninjas[0].missionsUrl);
const missionDetails = syncGetJSON(missions[0].detailsUrl);
//Study the mission description
} catch(e){
//Oh no, we weren't able to get the mission details
}
Although this code is great for its simplicity and error handling, it blocks the UI, which results in unhappy users. Ideally, we’d like to change this code so that no blocking occurs during a long-running task. One way of doing this is by combining generators and promises.
As we know, yielding from a generator suspends the execution of the generator without blocking. To wake up the generator and continue its execution, we have to call the next method on the generator’s iterator. Promises, on the other hand, allow us to specify a callback that will be triggered in case we were able to obtain the promised value, and a callback that will be triggered in case an error has occurred.
The idea, then, is to combine generators and promises in the following way: We put the code that uses asynchronous tasks in a generator, and we execute that generator function. When we reach a point in the generator execution that calls an asynchronous task, we create a promise that represents the value of that asynchronous task. Because we have no idea when that promise will be resolved (or even if it will be resolved), at this point of generator execution, we yield from the generator, so that we don’t cause blocking. After a while, when the promise gets settled, we continue the execution of our generator by calling the iterator’s next method. We do this as many times as necessary. See the following listing for a practical example.
Listing 6.19. Combining generators and promises
async(function*(){
#A
try {
const ninjas = yield getJSON("data/ninjas.json");
#B
const missions = yield getJSON(ninjas[0].missionsUrl);
#B
const missionDescription = yield getJSON(missions[0].detailsUrl);
#B
//Study the mission details
}
catch(e) {
#C
//Oh no, we weren't able to get the mission details
#C
}
#C
});
function async(generator) {
#D
var iterator = generator();
#E
function handle(iteratorResult) {
#F
if(iteratorResult.done) { return; }
#G
const iteratorValue = iteratorResult.value;
if(iteratorValue instanceof Promise) {
#H
iteratorValue.then(res => handle(iterator.next(res))
#H
.catch(err => iterator.throw(err));
#H
}
#H
}
try {
#I
handle(iterator.next());
#I
}
#I
catch (e) { iterator.throw(e); }
#I
}
#A - The function using asynchronous results should be able to pause while waiting for results. Notice the function*. We’re using generators!
#B - Yield on each asynchronous task.
#C - We can still use all standard language constructs such as try-catch statements or loops.
#D - Defines a helper function that will control our generator
#E - Creates an iterator through which we’ll control the generator
#F - Defines the function that will handle each value generated by the generator
#G - Stops when the generator has no more results
#H - If the generated value is a promise, register a success and a failure callback. This is the asynchronous part. If the promise succeeds, great, resume the generator and send in the promised value. If there’s an error, throw an exception to the generator
#I - Restarts the generator execution.
!@%STYLE%@!
{"css":"{\"css\": \"font-weight: bold;\"}","target":"[]"}
!@%STYLE%@!
The async function takes a generator, calls it, and creates an iterator that will be used to resume the generator execution. Inside the async function, we declare a handle function that handles one return value from the generator—one “iteration” of our iterator. If the generator result is a promise that gets resolved successfully, we use the iterator’s next method to send the promised value back to the generator and resume the generator’s execution. If an error occurs and the promise gets rejected, we throw that error to the generator by using the iterator’s throw method (told you it would come in handy). We keep doing this until the generator says it’s done.
Note
This is a rough sketch, a minimum amount of code needed to combine generators and promises. We don’t recommend that you use this code in production.
Now let’s take a closer look at the generator. On the first invocation of the iterator’s next method, the generator executes up to the first getJSON("data/ninjas.json") call. This call creates a promise that will eventually contain the list of information about our ninjas. Because this value is fetched asynchronously, we have no idea how much time it will take the browser to get it. But we know one thing: We don’t want to block the application execution while we’re waiting. For this reason, at this moment of execution, the generator yields control, which pauses the generator, and returns the control flow to the invocation of the handle function. Because the yielded value is a getJSON promise, in the handle function, by using the then and catch methods of the promise, we register a success and an error callback, and continue execution. With this, the control flow leaves the execution of the handle function and the body of the async function, and continues after the call to the async function (in our case, there’s no more code after, so it idles). During this time, our generator function patiently waits suspended, without blocking the program execution.
Much, much later, when the browser receives a response (either a positive or a negative one), one of the promise callbacks is invoked. If the promise was resolved successfully, the success callback is invoked, which in turn causes the execution of the iterator’s next method, which asks the generator for another value. This brings back the generator from suspension and sends to it the value passed in by the callback. This means that we reenter the body of our generator, after the first yield expression, whose value becomes the ninjas list that was asynchronously fetched from the server. The execution of the generator function continues, and the value is assigned to the plan variable.
In the next line of the generator, we use some of the obtained data, ninjas[0].missionUrl, to make another getJSON call that creates another promise that should eventually contain a list of missions done by the most popular ninja. Again, because this is an asynchronous task, we have no idea how long it’s going to take, so we again yield the execution and repeat the whole process.
This process is repeated as long as there are asynchronous tasks in the generator.
This was a tad on the complex side, but we like this example because it combines a lot of things that you’ve learned so far:
Functions as first-class objects— We send a function as an argument to the async function.
Generator functions— We use their ability to suspend and resume execution.
Promises— They help us deal with asynchronous code.
Callbacks— We register success and failure callbacks on our promises.
Arrow functions— Because of their simplicity, for callbacks we use arrow functions.
Closures— The iterator, through which we control the generator, is created in the async function, and we access it, through closures, in the promise callbacks.
Now that we’ve gone through the whole process, let’s take a minute to appreciate how much more elegant the code that implements our business logic is. Consider this:
getJSON("data/ninjas.json", (err, ninjas) => {
if(err) { console.log("Error fetching ninjas", err); return; }
getJSON(ninjas[0].missionsUrl, (err, missions) => {
if(err) { console.log("Error locating ninja missions", err); return; }
console.log(misssions);
})
});
Instead of mixed control-flow and error handling, and slightly confusing code, we end up with something like this:
async(function*() {
try {
const ninjas = yield getJSON("data/ninjas.json");
const missions = yield getJSON(ninjas[0].missionsUrl);
//All information recieved
}
catch(e) {
//An error has occurred
}
});
This end result combines the advantages of synchronous and asynchronous code. From synchronous code, we have the ease of understanding, and the ability to use all standard control-flow and exception-handling mechanisms such as loops and try-catch statements. From asynchronous code, we get the nonblocking nature; the execution of our application isn’t blocked while waiting for long-running asynchronous tasks.
